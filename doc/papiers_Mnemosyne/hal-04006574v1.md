Symboling : utiliser des structures symboliques dotÃ©es
dâ€™une mÃ©trique
Paul Bernard, Benjamin Hate, Morgane Laval

To cite this version:

Paul Bernard, Benjamin Hate, Morgane Laval. Symboling : utiliser des structures symboliques dotÃ©es
dâ€™une mÃ©trique. RR-9499, Inria & Labri, Univ. Bordeaux. 2023, pp.18. ï¿¿hal-04006574ï¿¿

HAL Id: hal-04006574

https://inria.hal.science/hal-04006574

Submitted on 3 Mar 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

Lâ€™archive ouverte pluridisciplinaire HAL, est
destinÃ©e au dÃ©pÃ´t et Ã  la diffusion de documents
scientifiques de niveau recherche, publiÃ©s ou non,
Ã©manant des Ã©tablissements dâ€™enseignement et de
recherche franÃ§ais ou Ã©trangers, des laboratoires
publics ou privÃ©s.

Distributed under a Creative Commons Attribution 4.0 International License

Symboling : utiliser des structures symboliques dotÃ©es dâ€™une mÃ©trique

Paul Bernard1 , Benjamin Hate2,
Morgane Laval3
Project-Teams Mnemosyne

Research Report NÂ° 9999 â€” FÃ©vrier 2023 â€” 18 pages.

RÃ©sumÃ©: Nous proposons de manipuler des structures de donnÃ©es symboliques au sein dâ€™algorithmes
d'apprentissage automatique habituels, par exemple en considÃ©rant un systÃ¨me rÃ©actif engagÃ© dans une tÃ¢che
de rÃ©solution de problÃ¨mes ouverte et mal dÃ©ï¬nie. Nous dÃ©ï¬nissons les tÃ¢ches de rÃ©solution de problÃ¨mes Ã 
un niveau gÃ©omÃ©trique, en considÃ©rant que nous sommes situÃ©s quelque part dans un espace d'Ã©tats, dans le
but d'atteindre un Ã©tat ï¬nal (unique ou alternatif, Ã©ventuellement partiellement dÃ©ï¬ni), et de trouver un chemin
du premier au dernier tout en respectant les contraintes du chemin.
L'idÃ©e centrale de cette dÃ©ï¬nition gÃ©omÃ©trique est de considÃ©rer un espace d'Ã©tat abstrait oÃ¹ chaque point est
une structure de donnÃ©es symboliques, reprÃ©sentant des informations contextuelles sur l'espace physique et
sur l'Ã©tat interne de l'agent. SÃ©lectionner une trajectoire locale correspond Ã  dÃ©cider, comme Ã©tape du
processus de rÃ©solution du problÃ¨me, de modiï¬er certaines caractÃ©ristiques de l'espace d'Ã©tats tant au niveau
externe (e.g., dÃ©placer un objet) qu'au niveau interne (i.e., modiï¬er la reprÃ©sentation interne).
L'ingrÃ©dient principal est de spÃ©ciï¬er une distance. Le levier est une notion de distance d'Ã©dition, c'est-Ã -dire le
fait qu'une valeur de donnÃ©e symbolique est Ã©ditÃ©e pas Ã  pas pour Ã©galer une autre valeur. De plus, Ã©tant
donnÃ© un type de donnÃ©es, cette spÃ©ciï¬cation inclut la projection d'une valeur de donnÃ©es au voisinage de la
rÃ©gion spÃ©ciï¬ant un type de donnÃ©es sur celui-ci, comme dÃ©veloppÃ© ici.
Ce rapport introduit ces notions plutÃ´t abstraites en les rendant les plus accessibles possibles, notamment en
montrant leur relation avec la modÃ©lisation en neuroscience computationnelle et en les illustrant Ã  l'aide d'un
exemple de dessins et d'un exemple musical.

Mots-clÃ©s: RÃ©solution de problÃ¨mes. ReprÃ©sentations symboliques. Distance dâ€™Ã©dition.

1 ENSC - Bordeaux INP â€“ pbernard007@ensc.fr; 2ENSC â€“ pbhate@ensc.fr; 3ENSC â€“ molaval@ensc.fr;

Symboling : using symbolic structures equipped with a metric.

Abstract: We consider manipulating symbolic data structure within usual machine learning algorithms, for
instance considering a reactive system engaged in some open-ended, ill-deï¬ned problem-solving task. We
deï¬ne the problem-solving tasks at a geometric level, considering being located somewhere in a state-space,
with the goal of reaching some ï¬nal (unique or alternative, eventually partially deï¬ned) state, and ï¬nding a way
from the former to the latter while satisfying the path constraints.

The pivotal idea of this geometric deï¬nition is to consider an abstract state space where each point is a
symbolic data structure, representing contextual information about the physical space and about the agent's
internal state. Selecting a local trajectory corresponds to deciding, as a step in the problem-solving process, to
modify some characteristics of the state space both at the external level (e.g., moving an object) and at the
internal level (i.e., modifying the internal representation).

The primary ingredient is to specify a distance. The lever is the notion of editing distance, i.e., the fact that a
symbolic data value is step-by-step edited in order to equal another value. Moreover, given a data type, this
speciï¬cation includes the projection of a data value in the neighborhood of the data type region onto it, as
developed here.

This French report introduces these rather absconding notions making them as much as possible accessible,
including showing their relation with computational neuroscience modeling and illustrating them using one
drawing and one musical example.

Keywords: Problem-Solving. Symbolic representation. Editing distance.

Symboling : utiliser des structures symboliques dotÃ©es dâ€™une mÃ©trique 5

1 Introduction

2 RÃ©solution cognitives de problÃ¨mes

3 Lâ€™approche dite â€œsymbolingâ€ en rÃ©solution de problÃ¨mes

3.1 ModÃ©lisation hiÃ©rarchique

3.2 Introduction dâ€™une mÃ©trique

3.3 Calcul eï¬€ectif de la mÃ©trique

3.4 Application Ã  la rÃ©solution de problÃ¨mes

4 ExpÃ©rimentation du logiciel Ã  Ã©valuer

4.1 Utilisation de la syntaxe wJSON

4.2 DÃ©monstrations illustratives

4.2.1 DÃ©monstration graphique : â€œLa tÃªte Ã  Toto vers la tÃªte Ã  Titiâ€

4.2.2 DÃ©monstration musicale : la distance entre deux musiques

5 Conclusion

6 Contributions

6

7

10

10

12

14

15

16

16

17

17

18

18

19

RR NÂ° 9499

6

Paul Bernard, Benjamin Hate, Morgane Laval

1 Introduction

Un des dÃ©ï¬s du 21e siÃ¨cle, en matiÃ¨re dâ€™Ã©ducation, est de comprendre comment lâ€™humain apprend et
rÃ©sout des problÃ¨mes, y compris des problÃ¨mes ouverts qui nÃ©cessitent des solutions dites crÃ©atives. On
parle de compÃ©tences du 21Ã¨me siÃ¨cle2, comme le prÃ©sente Margarida Romero dans la ï¬gure ci-dessous3 :

FIGURE 1 : PrÃ©sentation des compÃ©tences du 21Ã¨me siÃ¨cle selon (Lambropoulos et Romero 2015)

Pour cela, diï¬€Ã©rents modÃ¨les cognitifs sont Ã©tudiÃ©s et reliÃ©s Ã  des modÃ¨les informatiques dâ€™apprentissage
profond. Dâ€™un point de vue cognitif, les recherches se focalisent sur des modÃ¨les du comportement dâ€™un sujet
inï¬‚uencÃ© par une rÃ©compense ou dirigÃ© vers un but. En apprentissage profond, ce comportement peut Ãªtre

2 Voir https://en.wikipedia.org/wiki/21st\_century\_skills et une discussion ici
https://www.competencesdu21emesiecle.com/decouvrir/qu-est-ce-que-les-competences-du-21eme-siecle
3 Lambropoulos, N., & Romero, M. (2015). 21st Century Lifelong Learning: Individual, Team and Social skills and
competence-based methodologies. Nova Publishers.
Voir aussi pour une introduction
https://www.researchgate.net/publication/323174769\_Les\_competences\_pour\_le\_XXI\_e\_siecle la figure est reprise de
la prÃ©sentation franÃ§aise du papier en confÃ©rence.

Inria

Symboling : utiliser des structures symboliques dotÃ©es dâ€™une mÃ©trique 7

modÃ©lisÃ© par de lâ€™apprentissage par renforcement, utilisant Ã  la fois des rÃ©compenses intermÃ©diaires et des
rÃ©compenses ï¬nales pour atteindre un but. Nous allons prÃ©senter un modÃ¨le des fonctions exÃ©cutives dit
PROBe qui met en Å“uvre ces principes gÃ©nÃ©raux.

Le problÃ¨me de cette modÃ©lisation numÃ©rique est quâ€™il est diï¬ƒcile dâ€™ajouter des connaissances a priori, ou
dâ€™interprÃ©ter la sÃ©mantique des mÃ©canismes numÃ©riques. Il est diï¬ƒcile de rendre explicites les interprÃ©tations
sous-jacentes existantes dans le modÃ¨le neuronal. Bref, mÃ©langer donnÃ©es symboliques et numÃ©riques est un
problÃ¨me diï¬ƒcile. Une solution proposÃ©e et qui sera explicitÃ©e ici est dâ€™utiliser un formalisme spÃ©ciï¬que pour les
donnÃ©es, qui correspond Ã  une description symbolique mais sur lequel on peut faire des calculs numÃ©riques
correspondant aux algorithmes dont on a besoin. Nous allons dÃ©tailler ces mÃ©canismes en essayant de les
rendre accessibles au maximum.

La proposition est de considÃ©rer une structure hiÃ©rarchique semblable Ã  ce que permet de reprÃ©senter la
syntaxe JSON, qui sera ensuite interprÃ©tÃ© comme un ensemble de faits dâ€™une base de connaissance4 utilisable,
entre autres, par un raisonneur aï¬n dâ€™enrichir ces connaissances factuelles. Ici on se concentrera sur la
rÃ©solution de problÃ¨mes et on verra comment transformer cela en un problÃ¨me gÃ©omÃ©trique de gÃ©nÃ©ration de
trajectoires.

Enï¬n nous montrerons une illustration trÃ¨s concrÃ¨te de ces mÃ©canismes Ã  la fois pour valider lâ€™implÃ©mentation
logicielle et permettre de se reprÃ©senter ce qui est formalisÃ© ici.

2 RÃ©solution cognitives de problÃ¨mes

RÃ©visons briÃ¨vement comment est formalisÃ© les mÃ©canismes dits des fonctions exÃ©cutives qui sont en jeu au
lors de la rÃ©solution de problÃ¨mes. Ce modÃ¨le5 dit PROBe introduit des patterns dâ€™actions
niveau cÃ©rÃ©bral
prÃ©dÃ©ï¬nies pour une tÃ¢che spÃ©ciï¬que (Collins et Koechlin, 2012). Ces patterns sont appelÃ©s des Task-Sets (TS) et
dictent le comportement du sujet.

Chaque TS possÃ¨de son propre apprentissage par renforcement6 (RL pour Reinforcement Learning), son propre
jugement critique vis-Ã -vis dâ€™une action. Elle est sa propre loi (appelÃ©e â€œpolicyâ€) pour sÃ©lectionner une action a au
regard dâ€™un stimulus reÃ§u s par lâ€™environnement. La rÃ©compense associÃ©e Ã  une tÃ¢che sÃ©lectionnÃ©e dans un TS
est dÃ©ï¬nie par Ã  la loi de mise Ã  jour7 de (Sutton et Barto, 2018) :

oÃ¹ Q(s,a)(t) est une estimation des valeurs Ã  lâ€™instant t, Î± un rÃ©el pondÃ©rateur selon le contexte, et r(t) la
rÃ©compense reÃ§ue Ã  lâ€™instant t. Cette formule signiï¬e que la valeur dâ€™un choix dâ€™action Ã  un instant t+1 dÃ©pend
de celui fait Ã  lâ€™instant dâ€™avant pondÃ©rÃ© par sa rÃ©compense (ou pÃ©nalitÃ© !) reÃ§ue. On parle de mÃ©canisme

4 La reprÃ©sentation moderne des connaissances distingue les faits ou T-box (pour â€œterminology componentâ€) qui sont ici
reprÃ©sentÃ© hiÃ©rarchiquement des rÃ¨gles ou A-box (pour â€œassertion component) qui permettent de dÃ©duire des
consÃ©quences des faits posÃ©s https://en.wikipedia.org/wiki/Abox : on ne considÃ¨re ici que le composant T-box.
On consultera https://line.gitlabpages.inria.fr/aide-group/wjson/LValue.html pour voir comment avec une interprÃ©tation
sÃ©mantique dite â€œturtoiseâ€ on peut passer dâ€™une reprÃ©sentation hiÃ©rarchique Ã  un ensemble de triplets sÃ©mantiques
comme utilisÃ©s dans les ontologies.
5 Collins, A., & Koechlin, E. (2012). Reasoning,
decision-making. PLoS biology, 10(3), e1001293.
6 Lâ€™apprentissage par renforcement est une branche de lâ€™apprentissage, y compris avec des rÃ©seaux de neurones
profonds. Lâ€™agent apprend par lui-mÃªme, par le biais de rÃ©compenses reÃ§ues en fonction des actions quâ€™il entreprend.
Lorsque lâ€™agent commence, il ne connaÃ®t rien de son monde et doit donc lâ€™explorer pour dÃ©terminer les actions qui lui
ramÃ¨nent le plus de rÃ©compenses dans le temps.
On considÃ¨re un agent qui interagit avec son environnement. A lâ€™instant t, il reÃ§oit un stimulus s de lâ€™environnement
(issu de son interaction avec celui-ci) avec une rÃ©compense associÃ©e r. Ã€ partir de cette rÃ©ception, il va infÃ©rer des
causes et prÃ©parer une action adÃ©quate a.
7 Sutton, R. S., & Barto, A. G. (2018). Reinforcement learning: An introduction. MIT press.

learning, and creativity: frontal

lobe function and human

RR NÂ° 9499

8

Paul Bernard, Benjamin Hate, Morgane Laval

Markovien pour expliciter que ,
Markov dâ€™ordre 1).

les valeurs perÃ§ues Ã  t+1 ne dÃ©pendent que des valeurs Ã  t (processus de

Les actions sÃ©lectionnÃ©es sont choisies par la loi du jeu de TS par un ï¬ltrage softmax8 sur les valeurs de Q de la
fortme:

qui permet de calculer un maximum pondÃ©rÃ© sur plusieurs valeurs avec une sortie en forme de sigmoÃ¯de.

On peut alors estimer pour chaque TS la probabilitÃ© de recevoir la rÃ©compense r selon lâ€™action a et le stimulus s
reÃ§u :

Une autre variable ğ›Œ, appelÃ©e signal de responsabilitÃ©, mesure la conï¬ance de la personne que son TS est
adaptÃ© Ã  la situation Ã  laquelle elle est confrontÃ©e en se basant sur ses expÃ©riences passÃ©es :

On considÃ¨re maintenant un seuil minimal acceptable de ğ›Œ qui est 1/2. On appelle TS par dÃ©faut (TSd ) le TS
pour lequel cet indice de conï¬ance est supÃ©rieur Ã  Â½. Autrement dit, pour un environnement, il existe un
ensemble dâ€™actions prÃ©dÃ©ï¬nies que lâ€™agent va eï¬€ectuer par dÃ©faut sâ€™il est confrontÃ© Ã  celui-ci. Ce TSd dirige le
comportement tant que sa valeur reste au-delÃ  de Â½. Dans ce modÃ¨le, câ€™est la variable supervisant le
comportement et indiquant si un comportement est appropriÃ© ou pas.

Lorsque ce nâ€™est plus le cas, il faut changer de tÃ¢che. On peut considÃ©rer que tous les TSi non pris jusquâ€™Ã 
prÃ©sent peuvent servir de TSd. En dâ€™autres termes, si les rÃ¨gles ne sont plus les bonnes, on utilise celles que lâ€™on
a pas utilisÃ©es comme nouveau standard car elles ne sont pas encore invalidÃ©es par la rÃ©ponse extÃ©rieure. Pour
faire un autre parallÃ¨le, lorsque notre rÃ©action Ã  un stimulus est acceptable, on continue de lâ€™exÃ©cuter. Lorsquâ€™il
ne devient plus acceptable, on tente dâ€™autres actions qui ont une probabilitÃ© supÃ©rieure Ã  Â½ de lâ€™Ãªtre. Avec le
temps, un nouveau task-set standard Ã©merge et devient le nouveau mÃ©canisme habituel. Cependant ces actions
associÃ©es ne le deviennent eï¬€ectivement et ne sont stockÃ©s comme telles que lorsque le signal de
responsabilitÃ© passe au dessus de  â„  de maniÃ¨re permanente.

Ce modÃ¨le permet de crÃ©er, stocker, changer et rÃ©cupÃ©rer des jeux de tÃ¢ches qui gouvernent le comportement
en fonction des retours de lâ€™environnement et dâ€™un passif.

8 La fonction Softmax, ou fonction exponentielle normalisÃ©e est une fonction dâ€™activation rÃ©guliÃ¨rement utilisÃ©e dans
les rÃ©seaux de neurones.

Inria

Symboling : utiliser des structures symboliques dotÃ©es dâ€™une mÃ©trique 9

Les simulations de ce modÃ¨le montrent que contrairement Ã  lâ€™apprentissage par renforcement classique, les
performances augmentent et lâ€™exploration diminue lorsque des contingences extÃ©rieures dÃ©jÃ  vues reviennent,
notamment parce que lâ€™on rÃ©cupÃ¨re des tÃ¢ches apprises en consÃ©quence. Ce modÃ¨le imite bien la tendance
naturelle que lâ€™on a de rester sur des actions qui fonctionnent plutÃ´t que de tenter quelque chose qui pourrait
Ãªtre inappropriÃ©. Ce modÃ¨le apprend aussi trÃ¨s rapidement et ï¬‚exiblement des nouvelles combinaisons de
tÃ¢ches qui rivalisent avec celles dÃ©jÃ  apprises. Par contraste, dans les diï¬€Ã©rents modÃ¨les dâ€™apprentissage par
renforcement, lâ€™apprentissage de TS se fait en parallÃ¨le suivant les signaux de responsabilitÃ©. Ce mÃ©canisme en
parallÃ¨le ralentit considÃ©rablement lâ€™apprentissage de nouvelles combinaisons, surtout lorsque lâ€™espace des
task-sets est large.

NÃ©anmoins, le signal de responsabilitÃ©s dÃ©crit au-dessus ne rÃ©agit quâ€™a posteriori dâ€™une action. Câ€™est-Ã -dire que
pour quâ€™un changement d'action sâ€™opÃ¨re,
il faut recevoir subitement un retour nÃ©gatif, ce qui est assez
inconvenant dans un contexte rÃ©el ( il serait dommage de se brÃ»ler la main pour savoir quâ€™il ne faut pas mettre
la main au feu ! ).
Il faut donc un signal de responsabilitÃ© a priori qui donnerai une estimation de future acceptabilitÃ© de lâ€™action
qui va Ãªtre employÃ©e en fonction des indices perÃ§us et des expÃ©riences passÃ©es dans un contexte C similaire :

On parle ainsi dâ€™ensemble dâ€™actions contextuelles (de valeur Q(C, TSi) ). En utilisant l'infÃ©rence bayÃ©sienne (calcul
de la probabilitÃ© de conï¬ance en une cause hypothÃ©tique Ã  partir de nos connaissances antÃ©rieures et de la
donnÃ©e reÃ§ue. Ce processus est itÃ©ratif et est continuellement alimentÃ© par la conï¬rmation ou lâ€™inï¬rmation de
lâ€™hypothÃ¨se.) et en faisant la distinction entre la responsabilitÃ© ex-ante et ex-post action, on peut amÃ©liorer la
fonction signal de responsabilitÃ© :

avec Î»i le signal de responsabilitÃ© Ã  lâ€™instant t pour le task-set i, Ï€(i/j,C) la probabilitÃ© que le task-set i soit valide Ã 
lâ€™instant t+1 sachant que le task-set j Ã©tait valide Ã  lâ€™instant t et que le contexte C est celui Ã  lâ€™instant t+1. Ainsi, on
retrouve dans la formule lâ€™inï¬‚uence du passÃ© (acceptabilitÃ© de lâ€™action au temps t) et du contexte futur
(probabilitÃ© dâ€™acceptabilitÃ© au temps t+1), pondÃ©rÃ©e par le signal de responsabilitÃ©. Dans cette conï¬guration,
nous sommes toujours dans un mÃ©canisme markovien dâ€™ordre 1 oÃ¹ seul le temps t nous intÃ©resse vis-Ã -vis du
temps t+1.

Ainsi le signal de responsabilitÃ© ex-post action sert Ã  renforcer (ou diminuer) le choix et le signal ex-ante action
sert Ã  dÃ©terminer les actions par dÃ©faut associÃ©es au contexte.
Ce modÃ¨le fait aussi de la crÃ©ation, stockage, changement et rÃ©cupÃ©ration de TS pour contrÃ´ler le
comportement en fonction des indices de lâ€™environnement et du feed-back quâ€™il renvoie. Cette fonction de
contrÃ´le contextuel est une fonction exÃ©cutive dÃ©couverte dans notre cerveau au niveau du cortex prÃ©frontal
latÃ©ral postÃ©rieur.

Si on gÃ©nÃ©ralise ce modÃ¨le, on peut lâ€™associer Ã  la mÃ©moire Ã©pisodique de lâ€™hippocampe en prÃ©sentant une
notion Ã©tendue des jeux dâ€™actions, appelÃ© jeux dâ€™Ã©pisodes, possÃ©dant un pattern enregistrÃ© de jeux dâ€™actions
pour un contexte Ã©pisodique particulier. Cependant les patterns changent en fonction de lâ€™Ã©pisode donc il faut
un niveau plus haut de fonctions exÃ©cutives pour gÃ©rer les jeux dâ€™Ã©pisodes, au niveau du cortex prÃ©-frontal. Le
modÃ¨le de base proposÃ© au-dessus sur les ensembles dâ€™action (fonctionnant par a priori et feed-back) peut Ãªtre
dupliquÃ© Ã  un niveau plus Ã©levÃ© pour Ãªtre appliquÃ© aux jeux dâ€™Ã©pisodes. On suppose alors que lâ€™agent est
partiellement hypermnÃ©sique et va pouvoir retenir des sÃ©quences de prÃ©cÃ©dentes entrÃ©es quâ€™il a eu (tous les
stimulus avec leurs rÃ©compenses), on quitte le modÃ¨le Markovien utilisÃ© dans le modÃ¨le usuel dâ€™apprentissage

RR NÂ° 9499

10

Paul Bernard, Benjamin Hate, Morgane Laval

par renforcement. Un tel contrÃ´le Ã©pisodique est dâ€™ailleurs aussi une fonction exÃ©cutive dÃ©couverte dans notre
cortex prÃ©frontal latÃ©ral antÃ©rieur. Câ€™est un sujet de recherche ouvert.

FIGURE 2 : SchÃ©ma de lâ€™hippocampe et du cortex frontal. De rÃ©centes Ã©tudes ont montrÃ© quâ€™il existe un lien
entre lâ€™hippocampe (siÃ¨ge de la mÃ©moire Ã©pisodique) et le cortex prÃ©frontal (responsable de certaines
fonctions exÃ©cutives) au niveau de la rÃ©solution contextuelle de problÃ¨mes, dâ€™aprÃ¨s9 (Isingrini et Taconnat
2008).

Le formalisme considÃ©rÃ© pour notre approche a vocation Ã  sâ€™appliquer justement Ã  la modÃ©lisation des
fonctions exÃ©cutives de dÃ©cisions contextuelles dans le cadre de rÃ©solution de problÃ¨mes, et tenir compte du
fait quâ€™on reprÃ©sente des sÃ©quences de donnÃ©es multui-modales structurÃ©es.

Pour limiter lâ€™explosion de complexitÃ© qui serait liÃ©e Ã  lâ€™Ã©numÃ©ration10 de tous les Ã©tats possibles nous allons
utiliser une reprÃ©sentation de donnÃ©es structurÃ©es, munie de relations hiÃ©rarchiques, sous forme dâ€™ontologie11.
Ainsi, la reprÃ©sentation restreint le nombre de donnÃ©es explicitement Ã©crites sans pour autant empÃªcher les
informations implicites (hÃ©ritage, similaritÃ©â€¦) dâ€™enrichir les donnÃ©es initiales.

3 Lâ€™approche dite â€œsymbolingâ€ en rÃ©solution de problÃ¨mes

3.1 ModÃ©lisation hiÃ©rarchique

La structure ressemble Ã  celle dâ€™un dictionnaire (ou tuple) avec pour chaque variable un nom et une valeur. Le
type de chaque valeur est prÃ©dÃ©terminÃ© par un schÃ©ma prÃ©conÃ§u et est de plusieurs types : un Ã©tiquette, une
valeur numÃ©rique, une liste ordonnÃ©e (ou sÃ©quence), un ensemble non-ordonnÃ© ou un sous-dictionnaire,
rendant cette structure hiÃ©rarchique. Le type peut aussi Ãªtre spÃ©ciï¬Ã© de maniÃ¨re plus spÃ©ciï¬que, par exemple
une valeur littÃ©rale parmi une liste prÃ©dÃ©terminÃ©e, un nombre bornÃ© et de prÃ©cision ï¬nie ou mÃªme la valeur
â€œundeï¬nedâ€ ce qui laisse en attente pour pouvoir y remplir une valeur une fois quâ€™elle sera dÃ©ï¬nie. Une telle
structure est exempliï¬Ã©e ï¬gure 3.:

9 Isingrini, M., & Taconnat, L. (2008). MÃ©moire Ã©pisodique, fonctionnement frontal et vieillissement Episodic memory,
frontal functioning, and aging. Revue neurologique, 164, S91-S95.
10 Supposons que la reprÃ©sentation interne se fasse Ã  travers un sÃ©quence de longueur T de N variables qui prennent M
valeurs, on devrait Ã©numÃ©rer MN Ã  chaque instant soit (MN)T valeurs ! Or dans en apprentissage par renforcement on
doit thÃ©oriquement construire une table de transitions pour toutes ces valeurs (ou lâ€™approximer par un calcul numÃ©rique
trÃ¨s couteux comme un rÃ©seau de neurones profond).
11 Voir https://fr.wikipedia.org/wiki/Ontologie\_(informatique) ou https://interstices.info/ontologies-informatiques pour
une introduction pluri-disciplinaire.

Inria

Symboling : utiliser des structures symboliques dotÃ©es dâ€™une mÃ©trique 11

FIGURE 3 : Exemple de donnÃ©es structurÃ©es modÃ©lisant nos connaissances Ã  propos du concept dâ€™oiseau.
Ces concepts sont batis Ã  partir dâ€™information sensori-motrice en lien avec lâ€™objet concret. Dans notre
contexte, chaque donnÃ©e contient des informations sur la tÃ¢che mais aussi sur lâ€™apprenant. Figure
proposÃ©e par ChloÃ© Mercier.

Les valeurs peuvent Ãªtre complÃ©tÃ©es par des mÃ©ta-informations, qui ne sont pas directement utilisÃ©es par
lâ€™agent mais servant pour la spÃ©ciï¬cation ou l'interprÃ©tation. Les donnÃ©es peuvent ensuite Ãªtre
reprÃ©sentÃ©es en syntaxe12 JSON :

La structure sÃ©mantique choisie est la reprÃ©sentation13 de (McClelland & Rogers 2003) et permet
dâ€™expliciter des connaissances sÃ©mantiques par relation hiÃ©rarchique (est un) avec des capacitÃ©s (peut),
des ressources extrinsÃ¨ques (possÃ¨de) et des ressources intrinsÃ¨ques (est). On nomme ces donnÃ©es des
â€œdonnÃ©es symboliquesâ€. Les propriÃ©tÃ©s peuvent Ãªtre qualitatives et quantitatives. Une telle structure est
appelÃ©e â€œtypeâ€ ou â€œconceptâ€ tel quâ€™il est dÃ©ï¬ni14 par (Gardenfors, 2004). Pour reprendre lâ€™exemple ci-dessus,
le type â€œoiseauâ€ est un â€œvertÃ©brÃ©â€ qui peut â€œchanterâ€, â€œvolerâ€, â€œmangerâ€ (et manger dâ€™autre types !), il possÃ¨de
des â€œplumesâ€ et un â€œbecâ€ et a un â€œpoidsâ€ minimum et maximum.

12 La syntaxe utilisÃ©e est celle dite wJSON pour â€œweak JSONâ€ (voir la section idoine).
13 McClelland, J. L., & Rogers, T. T. (2003). The parallel distributed processing approach to semantic cognition. Nature
reviews neuroscience, 4(4), 310-322.
14 GÃ¤rdenfors, P. (2004) Conceptual Spaces as a Framework for Knowledge Representation. Mind and Matter 2(2):9-27.

RR NÂ° 9499

12

Paul Bernard, Benjamin Hate, Morgane Laval

Un type est Ã  la fois une rÃ©gion convexe15 et un prototype dont chacune des caractÃ©ristiques possÃ¨de une
valeur par dÃ©faut, par-dessus lesquelles on peut rÃ©Ã©crire lorsquâ€™on dÃ©ï¬nit un objet de ce type. Par exemple
pour le pingouin qui est un oiseau particulier :

Plusieurs recommandations permettent de spÃ©ciï¬er au mieux de telles connaissances :
- DÃ©composer le plus possible les caractÃ©ristiques pour que les valeurs soient atomiques;
- Organiser le plus possible les informations en arbre et sous-arbres plutÃ´t que de tout avoir au mÃªme
niveau (cf. complexitÃ©);
- Renseigner le plus possible des valeurs par dÃ©faut;
- Utiliser des noms explicites ou standardisÃ©s pour les variables.

Au delÃ ,
il est possible dâ€™Ã©voluer dans un contexte supÃ©rieur comme dÃ©ï¬nir des rÃ¨gles (de la mÃªme
maniÃ¨re que lâ€™on dÃ©ï¬nit des types) en dÃ©ï¬nissant en variables une prÃ©condition (un Ã©tat spÃ©ciï¬que en
accord avec un schÃ©ma dÃ©ï¬ni au prÃ©alable comme â€œavoir faimâ€) et une post-condition (une sÃ©quence de
modiï¬cation de lâ€™Ã©tat actuel comme â€œmangerâ€ avec toutes les sous Ã©tapes qu'elle suppose).
On peut dÃ©ï¬nir des types incomplets, comme des connaissances incomplÃ¨tes. On peut aussi dÃ©ï¬nir des
connaissances dont le niveau de vÃ©ritÃ© est approximatif, autrement dit, des croyances !

Au niveau du raisonnement ontologique, chaque tuple est un sujet reliÃ© Ã  un autre par une propriÃ©tÃ©,
permettant ainsi de faire des infÃ©rences en termes de propriÃ©tÃ©s en dÃ©duisant des relations ontologiques
dÃ©jÃ  existantes. Ces infÃ©rences permettent de dÃ©crire une connaissance, voire un comportement de
maniÃ¨re symbolique. Au niveau syntaxique16,
il est est aussi possible de faire le chemin inverse en
transformant les donnÃ©es symboliques en tuple.

3.2 Introduction dâ€™une mÃ©trique

Le point clÃ© est que nous allons introduire une distance dâ€™Ã©dition entre deux structures hiÃ©rarchiques. Si
on considÃ¨re deux structures la distance dâ€™Ã©dition17 est le nombre minimal dâ€™opÃ©rations dâ€™Ã©dition pour
transformer une structure en une autre, avec des opÃ©rations de modiï¬cation, dâ€™insertion ou de
suppression de valeurs, ou dans notre cas hiÃ©rarchique de sous-valeurs. On considÃ¨re que chaque
opÃ©ration nâ€™a pas la mÃªme importance, selon la caractÃ©ristique qui est modiï¬Ã©e dans la structure. Ainsi,

15 En gÃ©omÃ©trie, le concept de rÃ©gion convexe fait rÃ©fÃ©rence Ã  un espace oÃ¹, quelque soient deux points de cet espace, le
trajet pour les relier est toujours Ã  lâ€™intÃ©rieur de cet espace.
Dans un espace â€œtypeâ€, cela signifie que pour passer dâ€™une donnÃ©e initiale Ã  une donnÃ©e finale, chaque Ã©tape est un
objet appartenant Ã  lâ€™espace (par exemple, la trajectoire pour passer dâ€™une hirondelle Ã  un merle dans lâ€™espace â€œoiseauâ€,
chaque Ã©tape intermÃ©diaire est un spÃ©cimen du type â€œoiseauâ€).Dans un espace â€œtypeâ€, cela signifie que pour passer
dâ€™une donnÃ©e initiale Ã  une donnÃ©e finale, chaque Ã©tape est un objet appartenant Ã  lâ€™espace (par exemple, la trajectoire
pour passer dâ€™une hirondelle Ã  un merle dans lâ€™espace â€œoiseauâ€, chaque Ã©tape intermÃ©diaire est un spÃ©cimen du type
â€œoiseauâ€).
16 Voir https://line.gitlabpages.inria.fr/aide-group/wjson/turtoise.pdf pour une description dÃ©taillÃ©e.
17 Voir https://fr.wikipedia.org/wiki/Distance\_de\_Levenshtein pour une prÃ©sentation dÃ©taillÃ©e dans le cas de sÃ©quences.

Inria

Symboling : utiliser des structures symboliques dotÃ©es dâ€™une mÃ©trique 13

chaque opÃ©ration possÃ¨de un coÃ»t qui permet de pondÃ©rer la transformation, et oï¬€re donc une grande
ï¬‚exibilitÃ© dans lâ€™approche.

Au niveau de la spÃ©ciï¬cation nous allons considÃ©rer que chaque valeur a un type, donc dÃ©ï¬nir un modÃ¨le
dâ€™objet, et chaque type dÃ©ï¬nit un espace mÃ©trique sur ces valeurs, câ€™est-Ã -dire quâ€™il contient la notion de
distance entre les objets.
Pour quâ€™une distance entre deux objets symboliques soit valide, les deux doivent se trouver dans lâ€™espace
sÃ©mantique dÃ©ï¬nie par ce type.
Cependant, toutes les donnÃ©es rÃ©cupÃ©rÃ©es ne sont pas forcÃ©ment dans cet espace, on a donc aussi
besoin de dÃ©ï¬nir un projecteur18 sur cet espace. Et ce projecteur doit Ãªtre dÃ©ï¬ni lui aussi sur un type de
donnÃ©es qui englobe le type sur lequel on souhaite projeter les donnÃ©es.
Autrement dit, une rÃ©gion au sein de lâ€™espace dÃ©ï¬ni par un type est dÃ©ï¬nie par un sous-type. Et on
considÃ¨re alors quâ€™il possÃ¨de un projecteur pour passer dâ€™un point de ce type Ã  une rÃ©gion dÃ©ï¬nie par un
sous-type.
Les distances peuvent ainsi se calculer entre deux objets, soit sur les objets eux-mÃªmes sâ€™ils sont dÃ©jÃ 
sÃ©mantiquement valides, soit sur leur projection dans lâ€™espace sÃ©mantique.

On va parler dâ€™espace syntaxique pour dÃ©ï¬nir le sur-type qui permet de faire la projection et dâ€™espace
sÃ©mantique pour dÃ©ï¬nir le type sur lequel on calcule des distances. Un projecteur syntaxique permet de
projeter nâ€™importe quelle valeur dans lâ€™espace syntaxique (souvent en prenant la valeur par dÃ©faut, dâ€™oÃ¹
son utilitÃ©). Le projecteuir sÃ©mantique de trouver une valeur avec laquelle on peut calculer la distance.

FIGURE 4 : Illustration des mÃ©canismes liÃ©s Ã  un type et un sous-type. On voit quâ€™il faut que deux Ã©lÃ©ments
soient dans lâ€™espace sÃ©mantique pour que lâ€™on puisse mesurer la distance qui les sÃ©pare. Il existe ainsi
deux projecteurs pour pouvoir eï¬€ectuer une mesure de distance sur leur projection si
les objets
nâ€™appartiennent pas Ã  lâ€™espace sÃ©mantique.

Pour illustrer les choses, considÃ¨rons le type â€œentier positifâ€. Une valeur (comme â€œ10â€) est syntaxiquement
valide si, une fois convertie, câ€™est une valeur numÃ©rique (â€œ10â€ est bien convertible en 10 !) et est
sÃ©mantiquement valide si câ€™est bel et bien un entier positif (10 serait donc sÃ©mantiquement valide car il est
positif, et câ€™est un entier !). Si ce nâ€™Ã©tait pas le cas, par exemple avec la valeur -10, on le projetterait sur la
valeur la plus proche, soit 0 dans le cas des distances usuelles.

18 Un projecteur dâ€™un point sur une rÃ©gion calcule la valeur qui appartienne Ã  la rÄ™gion est de distance minmale, la plus
proche, par rapport au point. Il sâ€™avÃ¨re que au niveau applicatif on peut facilement spÃ©cifiÃ© un tel calcul pour les
donnÃ©es considÃ©rÃ©es.

RR NÂ° 9499

14

Paul Bernard, Benjamin Hate, Morgane Laval

GrÃ¢ce Ã  ces ingrÃ©dients on peut calculer la distance dâ€™Ã©dition entre deux structures typÃ©es quelconques.
En fait on contraint la distance dâ€™Ã©dition Ã  respecter le type des valeurs (câ€™est Ã  dire quâ€™une valeur ne peut
pas Ãªtre modiï¬Ã©e en nâ€™importe quelle autre valeur de nâ€™importe quel type, mais uniquement une valeur de
mÃªme type). Une telle restriction permet dâ€™assurer la cohÃ©rence des opÃ©rations dâ€™Ã©ditions, mais aussi de
permettre dâ€™utiliser les valeurs intermÃ©diaires gÃ©nÃ©rÃ©es au fur et Ã  mesure de lâ€™application des opÃ©rations
dâ€™Ã©dition. De ce fait on nâ€™obtient pas uniquement la distance entre deux structures mais le chemin Ã 
lâ€™intÃ©rieur de lâ€™espace dÃ©ï¬ni par le type qui permet de passer dâ€™une structure Ã  une autre. Mieux encore ce
chemin est une gÃ©odÃ©sique19, câ€™est Ã  dire un chemin de longueur minimale en matiÃ¨re de distance.

3.3 Calcul effectif de la mÃ©trique

Il existe des algorithmes permettant de calculer une distance dâ€™Ã©dition entre deux objets. Ceux que nous
manipulons ici sont lâ€™algorithme Hongrois et lâ€™algorithme de Levenshtein.

Lâ€™algorithme Hongrois (ou algorithme de Kuhn) sâ€™applique pour les structures non ordonnÃ©es. ConsidÃ©rons
une structure non ordonnÃ©e initiale et une deuxiÃ¨me structure non ordonnÃ©e ï¬nale. Le but de cet
algorithme est de trouver le chemin de modiï¬cations pour passer de lâ€™un Ã  lâ€™autre ayant un coÃ»t minimal
de transformation. Pour Ãªtre plus prÃ©cis, on peut imaginer que pour passer de la premiÃ¨re Ã  la deuxiÃ¨me,
il est possible de faire diï¬€Ã©rents chemins, câ€™est-Ã -dire des sÃ©quences de modiï¬cations diï¬€Ã©rentes, mais
dont les coÃ»ts dâ€™Ã©dition sont diï¬€Ã©rents.

Lâ€™algorithme de Levenshtein lui, sâ€™applique sur des structures ordonnÃ©es comme des chaÃ®nes de
caractÃ¨res ou des arbres. Le principe est de sÃ©lectionner Ã©lÃ©ment par Ã©lÃ©ment lâ€™opÃ©ration au coÃ»t minimal
pour au total passer dâ€™une structure ordonnÃ©e A Ã  B. Chaque opÃ©ration peut Ãªtre un ajout, une
il faut respecter lâ€™ordre de
suppression ou une modiï¬cation. A la diï¬€Ã©rence de l'algorithme Hongrois,
lecture de la structure. ConsidÃ©rons les listes implicitement ordonnÃ©es L = [ â€œun peuâ€, â€œbeaucoupâ€,
â€œpassionnÃ©mentâ€, â€œÃ  la folieâ€] et M = [ â€œun peuâ€, â€œbeaucoupâ€, â€œpresqueâ€, â€œÃ  la folieâ€]. Pour dÃ©terminer un
distance dâ€™Ã©dition pour passer de la liste L Ã  M selon l'algorithme de Levenshtein, il nous faut respecter
lâ€™ordre de considÃ©ration implicite des termes (modiï¬er â€œun peuâ€ puis â€œbeaucoupâ€, etcâ€¦).

Au delÃ , pour une structure arborescente la situation est plus complexe. Si on considÃ¨re nos donnÃ©es
sous forme dâ€™arbres câ€™est-Ã -dire quâ€™il existe seulement une relation ancÃªtre-descendant entre les nÅ“uds.
On montre que pour passer de lâ€™arbre A Ã  lâ€™arbre B,, si aucun ordre nâ€™Ã©tait appliquÃ© et quâ€™il Ã©tait possible de
modiï¬er les parents indÃ©pendamment des enfants et vice-versa, les possibilitÃ©s de modiï¬cations pour
passer dâ€™une structure Ã  une autre augmenteraient de maniÃ¨re exponentielle. Les combinaisons de
trajectoire seraient Ã  la fois multiples et parfois incohÃ©rentes. En eï¬€et, dans notre contexte, nous nous
intÃ©ressons Ã  la rÃ©solution de problÃ¨me par modiï¬cations atomiques de lâ€™Ã©tat du problÃ¨me. Autrement dit,
rÃ©soudre un problÃ¨me depuis une situation initiale se fait par petites Ã©tapes qui suivent un ordre logique
qui ne dÃ©truisent pas la structure logique du problÃ¨me manipulÃ©.
Pour pallier ce problÃ¨me de complexitÃ© et de logique, une solution est dâ€™utiliser des contraintes de
modiï¬cations telles que deux nÅ“uds parents-enfants ne peuvent Ãªtre Ã©changÃ©s alliÃ© Ã  des contraintes

19 Voir https://line.gitlabpages.inria.fr/aide-group/symboling/scalarfield.pdf pour une dÃ©monstration et une utilisation
pour traiter de telles donnÃ©s symboliques au niveau numÃ©rique. Assez simplement sur une gÃ©odÃ©sique entre deux
valeurs A et B les points C de la gÃ©odÃ©siques vÃ©rifient:

alors que en gÃ©nÃ©ral il nâ€™y a quâ€™une inÃ©galitÃ©, dite triangulaire.

distance(A, B) = distance(A, C) + D(C, B)

Inria

Symboling : utiliser des structures symboliques dotÃ©es dâ€™une mÃ©trique 15

dâ€™ordre20 (Ouangraoua et Ferraro, 2009). On peut aussi utiliser des arbres semi-ordonnÃ©s, câ€™est-Ã -dire que
tous les noeuds de lâ€™arbre vÃ©riï¬ent une relation semi-ordonnÃ©e (pour deux noeuds x et y, la relation x-y est
transitive et rÃ©ï¬‚exive) avec son noeud-parent ou noeud-enfant en plus de la relation ancÃªtre-descendant.
De par ces restrictions, les possibilitÃ©s de sÃ©quences de modiï¬cations diminuent. Dans cette conï¬guration,
la complexitÃ© algorithmique est de lâ€™ordre polynomial.
Lorsque nous sommes dans des cas de structure oÃ¹ un ordre est sous-jacent, les feuilles de notre arbre
sâ€™ordonnent (les nÅ“uds-enfants sâ€™ordonnent) et on peut appliquer lâ€™algorithme de Levenshtein (voir â€œI.d.
Symboling, mÃ©trisation de lâ€™espaceâ€).

Ici
la contrainte sur le typage des valeurs implique la prÃ©servation de la gÃ©nÃ©alogie (deux nÅ“uds
parents-enfants ne peuvent Ãªtre Ã©changÃ©s) et on retombe sur un mÃ©canisme trÃ¨s simple qui fait quâ€™au
niveau des tuples la complexitÃ© est linÃ©aire.

3.4 Application Ã  la rÃ©solution de problÃ¨mes

Maintenant le cadre dÃ©ï¬ni, nous pouvons passer Ã  la modÃ©lisation du problÃ¨me qui est justement
â€œcomment modÃ©lise-t-on la rÃ©solution de problÃ¨me?â€

Selon la dÃ©ï¬nition21 de (Newell et Simon, 1972), une situation de rÃ©solution de problÃ¨mes se caractÃ©rise
par un ensemble de structures symboliques (les objets de lâ€™espace en question) et un ensemble
dâ€™opÃ©rateurs sur ces structures. Ces opÃ©rateurs prennent en entrÃ©e des Ã©tats et sortent des Ã©tats. Il se
peut que les opÃ©rateurs ne sâ€™appliquent pas systÃ©matiquement sur tous les Ã©tats. En eï¬€et, ces derniers
peuvent ne pas se trouver dans le domaine de dÃ©ï¬nition des opÃ©rateurs (par exemple, il se peut que lâ€™on
ai besoin de connaÃ®tre la distance entre deux objets mais lâ€™un nâ€™est pas dans le bon espace. Par
consÃ©quent, lâ€™opÃ©ration de distance nâ€™est pas applicable dessus.).

Une sÃ©quence dâ€™opÃ©rations dÃ©ï¬nit un chemin entre les diï¬€Ã©rents Ã©tats dans lâ€™espace dâ€™Ã©tat (une opÃ©ration
permettant de passer dâ€™un Ã©tat Ã  un autre).

DÃ©ï¬nir un problÃ¨me de maniÃ¨re spatialisÃ©e comme ici consiste Ã  dÃ©ï¬nir un ensemble dâ€™Ã©tat initiaux, dâ€™Ã©tats
ï¬naux, et un ensemble de contraintes sur le chemin. RÃ©soudre un problÃ¨me signiï¬e donc ici trouver un
chemin dÃ©butant Ã  nâ€™importe quel Ã©tat initial dÃ©ï¬ni, satisfaisant les contraintes spatiales et ï¬nissant dans
nâ€™importe quel Ã©tat ï¬nal (quâ€™il soit unique ou non, partiellement dÃ©ï¬ni ou non). Dans ce mÃ©canisme de
recherche de solution par trajectoire, il faut explorer lâ€™espace aï¬n de rÃ©soudre le problÃ¨me

. FIGURE 5 : ReprÃ©sentation de la rÃ©solution de problÃ¨me par approche gÃ©omÃ©trique. Le problÃ¨me dÃ©bute
Ã  un point initial de lâ€™espace (reprÃ©sentÃ© par lâ€™Ã©toile Ã  quatre branches) et doit Ã©voluer de sorte Ã  se frayer
un chemin en respectant certaines contraintes (reprÃ©sentÃ©s ici par des obstacles en gris) jusquâ€™Ã  lâ€™espace
correspondant Ã  un but dâ€™arrivÃ©e (symbole â€œexplosionâ€ sur la ï¬gure).

20Ouangraoua, A., Ferraro, P.: A Constrained Edit Distance Algorithm Between Semiordered Trees. Theoretical
Computer Science 410(8-10), 837â€“846 (2009), publisher: Elsevier
21 Newell, A., & Simon, H. A. (1972). Human problem solving (Vol. 104, No. 9). Englewood Cliffs, NJ: Prentice-hall.

RR NÂ° 9499

16

Paul Bernard, Benjamin Hate, Morgane Laval

La spÃ©ciï¬citÃ© dans notre algorithme est que chaque point de lâ€™espace est une structure symbolique de
donnÃ©es, contenant les informations relatives Ã  lâ€™agent (lâ€™objet lui-mÃªme) et Ã  lâ€™espace dans lequel il est (sa
position relative). Pour refaire le lien avec lâ€™apprentissage et la rÃ©solution de problÃ¨me spatial, chaque
structure hiÃ©rarchisÃ©e nous informe sur lâ€™apprenant (son Ã©tat) et la direction quâ€™il entreprend dans sa
rÃ©solution (lâ€™apprentissage).

Trouver une trajectoire dans cet espace,
i.e. rÃ©soudre un problÃ¨me revient Ã  modiï¬er pas Ã  pas la
structure de la donnÃ©e depuis son Ã©tat initial jusquâ€™Ã  arriver Ã  lâ€™Ã©tat ï¬nal dÃ©sirÃ©. Lâ€™ingrÃ©dient essentiel pour
rÃ©aliser cela est de concevoir une structure qui peut Ãªtre mÃ©trisable, câ€™est-Ã -dire quâ€™on puisse dÃ©terminer
une distance. Câ€™est un critÃ¨re primordial pour, par exemple, la distance entre la donnÃ©e dâ€™entrÃ©e et son
objectif, autrement dit pouvoir quantiï¬er non seulement le chemin parcouru mais aussi celui restant. Il
faut aussi pouvoir quantiï¬er des distances intermÃ©diaires, par exemple la distance aux obstacles Ã  Ã©viter.
Ajouter bout Ã  bout les modiï¬cations permet de dÃ©terminer notre suite dâ€™Ã©tats formant la trajectoire de
rÃ©solution.
Notons que pour cette partie, on considÃ¨re que les donnÃ©es sont sÃ©mantiquement valides pour pouvoir y
appliquer une notion de distance entre elles.

4 ExpÃ©rimentation du logiciel Ã  Ã©valuer

Dans cette partie on Ã©value une implÃ©mentation de ces principes sous forme une bibliothÃ¨que logicielle22
en cours dâ€™Ã©valuation.

4.1 Utilisation de la syntaxe wJSON

Une premiÃ¨re remarque sâ€™impose vis-Ã -vis des choix de syntaxe. Aï¬n dâ€™avoir une accessibilitÃ© souple pour
le programme, un des choix Ã  Ã©tÃ© de proposer dâ€™utiliser du â€œweak JSONâ€23 plutÃ´t que du JSON classique. En
eï¬€et, ce dernier possÃ¨de une plus grande ï¬‚exibilitÃ© syntaxique, permettant Ã  une plus grande part de
population plus ou moins Ã  lâ€™aise en programmation de participer au projet ou tout du moins de le
comprendre.

22 Voir https://line.gitlabpages.inria.fr/aide-group/symboling pour une documentation dÃ©taillÃ©e, avec les guides
dâ€™installation en fonction de votre systÃ¨me dâ€™exploitation:
- Installation sous Linux et MacOS : https://line.gitlabpages.inria.fr/aide-group/aidebuild/install.html
- Installation sous Windows : https://gitlab.inria.fr/line/aide-group/aidebuild/-/blob/master/src/install\_on\_windows.md
23 Voir https://line.gitlabpages.inria.fr/aide-group/wjson pour une prÃ©sentation dÃ©taillÃ©e et lâ€™accÃ¨s au logiciel et aux
sources.

Inria

Symboling : utiliser des structures symboliques dotÃ©es dâ€™une mÃ©trique 17

FIGURE 6 : Exemple de syntaxe wJSON

On retrouve la mÃªme prÃ©sentation en dictionnaire ou â€œobjetâ€ du JSON, peut-Ãªtre un peu plus intuitive Ã 
lire. Câ€™est au niveau de lâ€™Ã©criture que la diï¬€Ã©rence se joue. La prÃ©sentation en dictionnaire avec un simple
retour Ã  la ligne, un nom de variable et ce quâ€™elle contient est une maniÃ¨re plus intuitive de construire un
objet, surtout pour une personne non initiÃ©e. Une seule prÃ©caution Ã  prendre est dâ€™ajouter un espace
aprÃ¨s les deux points.
Il nâ€™est pas non plus nÃ©cessaire de remplir tous les champs. Dans lâ€™exemple
ci-dessus, â€œimaginativeâ€ est laissÃ© seul. Pour une personne programmeuse, cela signiï¬e que la variable est
Ã  true, quant Ã  une personne non-programmeuse, cela signiï¬e simplement que Jean-Pierre est imaginatif !

4.2 DÃ©monstrations illustratives

Deux dÃ©monstrations ont Ã©tÃ© rÃ©alisÃ©es aï¬n dâ€™illustrer le traitement de la distance dâ€™Ã©dition sur des
donnÃ©es non ordonnÃ©es (algorithme hongrois) et ordonnÃ©es (algorithme de Levenshtein).

4.2.1 DÃ©monstration graphique : â€œLa tÃªte Ã  Toto vers la tÃªte Ã  Titiâ€

Dans cette partie nous nous proposons dâ€™appliquer symboling Ã  une rÃ©solution graphique (sur structure
non ordonnÃ©e). Lâ€™idÃ©e est de passer du dessin A au dessin B par une suite de modiï¬cation de structure :

FIGURE 7 : Structure SVG initial â€œTotoâ€ et ï¬nale â€œTitiâ€

Les deux dessins ont Ã©tÃ© gÃ©nÃ©rÃ©s sous format SVG, utilisÃ© notamment dans le Web pour la reprÃ©sentation
des images sous forme vectorielle. Un programme de conversion permet de passer d'une pure
reprÃ©sentation SVG Ã  une reprÃ©sentation symbolique en JSON, qui est compatible avec le format wJSON.

RR NÂ° 9499

18

Paul Bernard, Benjamin Hate, Morgane Laval

Le logiciel Ã©crit en C++, exploitant la bibliothÃ¨que symboling, convertit donne une reprÃ©sentation
symbolique, un "sens" aux Ã©lÃ©ments composants la forme JSON des visages Titi et Toto.

Cette dÃ©monstration est intÃ©grÃ©e Ã  la bibliothÃ¨que et on peut accÃ©der:
- Ã  la description au format symboling dâ€™un sous ensemble de la spÃ©ciï¬cation SVG24;
- Ã  la documentation de son utilisation logicielle25;
- et Ã  une page de dÃ©monstration26.

4.2.2 DÃ©monstration musicale : la distance entre deux musiques

Dans cette partie lâ€™idÃ©e est dâ€™appliquer le programme Symboling Ã  des partitions de musiques. Le
programme appliquÃ© Ã  notre partition Ã©crite sous forme JSON va Ãªtre modiï¬Ã©e jusquâ€™Ã  donner la partition
choisie.
Nous avons tout dâ€™abord rÃ©alisÃ© un intergiciel permettant de passer du JSON au midi et inversement. Pour
cela, nous nous appuyons sur un package npm existant et avons dÃ©veloppÃ© un moyen de lâ€™utiliser
directement depuis la console.
Cependant, la structure JSON du midi est complexe et donc diï¬ƒcile Ã  traduire avec les classes symboling,
on a donc a ce jour une preuve de concept, mais un mÃ©canisme partiel.

Cette dÃ©monstration est intÃ©grÃ©e Ã  la bibliothÃ¨que et on peut accÃ©der:
- Ã  la description au format symboling dâ€™un sous ensemble de la spÃ©ciï¬cation MIDI27;
- Ã  la documentation de son utilisation logicielle28;
- et Ã  une page de dÃ©monstration29.

5 Conclusion

Cette approche du programme Symboling Ã  des cas concrets a permis plusieurs choses: premiÃ¨rement Ã 
rÃ©aliser une centralisation des diï¬€Ã©rents concepts sur lesquels reposent le projet, puis Ã  la rÃ©alisation
dâ€™une documentation pour lâ€™installation sur diï¬€Ã©rents environnements, et enï¬n Ã  des dÃ©monstrations
visuelles et concrÃ¨tes du programme. Pour rÃ©sumer, cette Ã©tape a permis de formaliser et concrÃ©tiser la
rÃ©solution de problÃ¨me par approche gÃ©omÃ©trique grÃ¢ce Ã  la distance dâ€™Ã©dition comme lâ€™entend le
programme symboling et dâ€™Ã©valuer et valider la version logicielle initiale de lâ€™implÃ©mentation, en permettant
de remonter des corrections importantes.

Au delÃ , en reprenant le cadre initial du projet, Ã  savoir un agent dans un monde reprÃ©sentÃ© et reliÃ© par
ontologie, on pourrait appliquer ce travail Ã  lâ€™apprentissage par renforcement, donc fournir au modÃ¨le
PROBe une gÃ©nÃ©ralisation assez puissante. Plus prÃ©cisÃ©ment,
lâ€™agent dans son monde Ã©volue en
apprenant comment il doit interagir avec les Ã©lÃ©ments de son environnement en fonction de son
expÃ©rience passÃ©e avec celui-ci mais aussi des infÃ©rences quâ€™il fait vis-Ã -vis de lui. Lâ€™agent est par ailleurs,

24 https://gitlab.inria.fr/line/aide-group/symboling/-/blob/master/src/SvgType.cpp
25 https://line.gitlabpages.inria.fr/aide-group/symboling/SvgType.html
26 https://line.gitlabpages.inria.fr/aide-group/symboling/visualmorphing/index.html
27 https://gitlab.inria.fr/line/aide-group/symboling/-/blob/master/src/MidiType.cpp
28 https://line.gitlabpages.inria.fr/aide-group/symboling/MidiType.html
29 https://line.gitlabpages.inria.fr/aide-group/symboling/musicmorphing/index.html

Inria

Symboling : utiliser des structures symboliques dotÃ©es dâ€™une mÃ©trique 19

avec la notion de distance, capable de relier, voir reconnaÃ®tre un objet similaire Ã  un autre dÃ©jÃ  rencontrÃ©
par le passÃ© grÃ¢ce Ã  des caractÃ©ristiques partagÃ©es (caractÃ©ristiques sous-entendu dans lâ€™ontologie). Une
perspective Ã  ce projet pourrait Ãªtre de fusionner les deux approches. En eï¬€et, dâ€™un cÃ´tÃ© nous possÃ©dons
un programme capable de relier un Ã©tat initial Ã  un Ã©tat-objectif et de lâ€™autre un programme simulant un
agent apprenant de son environnement par exploration/rÃ©compense. On pourrait envisager la crÃ©ation
dâ€™un programme dans lequel lâ€™agent possÃ¨de un Ã©tat de dÃ©part et un Ã©tat dâ€™arrivÃ©e et quâ€™il doive passer de
lâ€™un Ã  lâ€™autre grÃ¢ce Ã  des Ã©lÃ©ments de son environnement quâ€™il dÃ©couvre et reconnaÃ®t. Par exemplet, cela
revient Ã  laisser un naufragÃ© ignorant sur une Ã®le dont lâ€™objectif est de survivre et reprendre la mer : lâ€™Ã©tat
initial peut Ãªtre â€œsans maisonâ€ et lâ€™agent doit chercher et reconnaÃ®tre le bois pour atteindre lâ€™Ã©tat ï¬nal
â€œabritÃ©â€ :)

6 Contributions

Le travail bibliograhique a Ã©tÃ© realisÃ© par Morgane Laval, et le travail dâ€™Ã©valuation du logiciel et de
conception des dÃ©monstrations par Paul Bernard pour la dÃ©monstration graphique et Benjamin Hate pour
la dÃ©monstration musicale, sachant que le travail est dans son ensemble avant tout un travail dâ€™Ã©quipe.

Ce travail a Ã©tÃ© co-encadrÃ© par Axel Palaude et ChloÃ© Mercier, tous deux en thÃ¨se dans lâ€™Ã©quipe
Mnemosyne avec lâ€™aide de Thierry ViÃ©ville.

7 RÃ©fÃ©rences

Collins, A., & Koechlin, E. (2012). Reasoning,
decision-making. PLoS biology, 10(3).

learning, and creativity: frontal

lobe function and human

Isingrini, M., & Taconnat, L. (2008). MÃ©moire Ã©pisodique, fonctionnement frontal et vieillissement Episodic
memory, frontal functioning, and aging. Revue neurologique, 164, 91-955.

GÃ¤rdenfors, P. (2004) Conceptual Spaces as a Framework for Knowledge Representation. Mind and Matter
2(2):9-27.

Lambropoulos, N., & Romero, M. (2015). 21st Century Lifelong Learning: Individual, Team and Social skills
and competence-based methodologies. Nova Publishers.

Newell, A., & Simon, H. A.
Prentice-hall.

(1972). Human problem solving (Vol. 104, No. 9). Englewood Cliï¬€s, NJ:

Ouangraoua, A., Ferraro, P.: A Constrained Edit Distance Algorithm Between Semiordered Trees.
Theoretical Computer Science 410(8-10), 837â€“846 (2009), Elsevier.

Sutton, R. S., & Barto, A. G. (2018). Reinforcement learning: An introduction. MIT press.

RR NÂ° 9499

