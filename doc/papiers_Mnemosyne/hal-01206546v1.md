Scipy Lecture Notes
Gaël Varoquaux, Emmanuelle Gouillart, Olav Vahtras, Valentin Haenel,

Nicolas P. Rougier, Ralf Gommers, Fabian Pedregosa, Zbigniew

Jędrzejewski-Szmek, Pauli Virtanen, Christophe Combelles, et al.

To cite this version:

Gaël Varoquaux, Emmanuelle Gouillart, Olav Vahtras, Valentin Haenel, Nicolas P. Rougier, et al..
Scipy Lecture Notes: One document to learn numerics, science, and data with Python. Zenodo, 2015,
￿10.5281/zenodo.31736￿. ￿hal-01206546￿

HAL Id: hal-01206546

https://inria.hal.science/hal-01206546

Submitted on 6 Oct 2015

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Distributed under a Creative Commons Attribution 4.0 International License

PythonMatplotlibSciKitsNumpySciPyIPythonIP[y]:Cython2015EDITIONEdited byGaël VaroquauxEmmanuelle GouillartOlaf VahtrasScipyLecture Noteswww.scipy-lectures.orgGaël Varoquaux • Emmanuelle Gouillart • Olav VahtrasValentin Haenel • Nicolas P. Rougier • Ralf GommersFabian Pedregosa • Zbigniew Jędrzejewski-Szmek • Pauli VirtanenChristophe Combelles • Didrik Pinte • Robert CimrmanAndré Espaze • Adrian Chauve • Christopher BurnsContents

I Getting started with Python for science

1 Scientiﬁc computing with tools and workﬂow

1.1 Why Python?
1.2
1.3 The interactive workﬂow: IPython and a text editor

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Scientiﬁc Python building blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . .

2

4
4
5
6

2 The Python language

10
First steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.1
2.2 Basic types
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.3 Control Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.4 Deﬁning functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.5 Reusing code: scripts and modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
Input and Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
2.6
2.7
Standard Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
2.8 Exception handling in Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
2.9 Object-oriented programming (OOP) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42

3 NumPy: creating and manipulating numerical data

43
3.1 The Numpy array object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
3.2 Numerical operations on arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
3.3 More elaborate arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
3.4 Advanced operations
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
Some exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
3.5

4 Matplotlib: plotting

82
4.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
4.2
Simple plot
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
Figures, Subplots, Axes and Ticks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
4.3
4.4 Other Types of Plots: examples and exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
4.5 Beyond this tutorial
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
4.6 Quick references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98

5 Scipy : high-level scientiﬁc computing

101
File input/output: scipy.io . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
5.1
Special functions: scipy.special . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
5.2
Linear algebra operations: scipy.linalg . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
5.3
Fast Fourier transforms: scipy.fftpack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
5.4
5.5 Optimization and ﬁt: scipy.optimize . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
Statistics and random numbers: scipy.stats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
5.6
Interpolation: scipy.interpolate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
5.7
5.8 Numerical integration: scipy.integrate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
Signal processing: scipy.signal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
5.9
5.10 Image processing: scipy.ndimage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120

i

5.11 Summary exercises on scientiﬁc computing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124

6 Getting help and ﬁnding documentation

II Advanced topics

137

140

7 Advanced Python Constructs

142
Iterators, generator expressions and generators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
7.1
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
7.2 Decorators
7.3 Context managers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155

8 Advanced Numpy

159
8.1
Life of ndarray . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
8.2 Universal functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
8.3
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182
8.4 Array siblings: chararray, maskedarray, matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
8.5
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
8.6 Contributing to Numpy/Scipy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188

Interoperability features

9 Debugging code

192
9.1 Avoiding bugs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
9.2 Debugging workﬂow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
9.3 Using the Python debugger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
9.4 Debugging segmentation faults using gdb . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200

10 Optimizing code

203
10.1 Optimization workﬂow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
10.2 Proﬁling Python code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
10.3 Making code go faster . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206
10.4 Writing faster numerical code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207

11 Sparse Matrices in SciPy

210
11.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210
11.2 Storage Schemes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
11.3 Linear System Solvers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
11.4 Other Interesting Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229

12 Image manipulation and processing using Numpy and Scipy

230
12.1 Opening and writing to image ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
12.2 Displaying images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
12.3 Basic manipulations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
12.4 Image ﬁltering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
12.5 Feature extraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
12.6 Measuring objects properties: ndimage.measurements . . . . . . . . . . . . . . . . . . . . . . . . 243

13 Mathematical optimization: ﬁnding minima of functions

248
13.1 Knowing your problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249
13.2 A review of the different optimizers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 251
13.3 Practical guide to optimization with scipy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258
13.4 Special case: non-linear least-squares
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
13.5 Optimization with constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261

14 Interfacing with C

263
14.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
14.2 Python-C-Api . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264
14.3 Ctypes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268
14.4 SWIG . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272
14.5 Cython . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276
14.6 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
14.7 Further Reading and References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280

ii

14.8 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280

III Packages and applications

282

15 Statistics in Python

284
15.1 Data representation and interaction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285
15.2 Hypothesis testing: comparing two groups
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289
15.3 Linear models, multiple factors, and analysis of variance . . . . . . . . . . . . . . . . . . . . . . . . 292
15.4 More visualization: seaborn for statistical exploration . . . . . . . . . . . . . . . . . . . . . . . . . . 297
15.5 Testing for interactions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299

16 Sympy : Symbolic Mathematics in Python

301
16.1 First Steps with SymPy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
16.2 Algebraic manipulations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
16.3 Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304
16.4 Equation solving . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 305
16.5 Linear Algebra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306

17 Scikit-image: image processing

308
17.1 Introduction and concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308
17.2 Input/output, data types and colorspaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310
17.3 Image preprocessing / enhancement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312
17.4 Image segmentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315
17.5 Measuring regions’ properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 318
17.6 Data visualization and interaction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 318
17.7 Feature extraction for computer vision . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320

18 Traits: building interactive dialogs

322
18.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 323
18.2 Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 323
18.3 What are Traits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324

19 3D plotting with Mayavi

340
19.1 Mlab: the scripting interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 340
19.2 Interactive work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 346
19.3 Slicing and dicing data: sources, modules and ﬁlters . . . . . . . . . . . . . . . . . . . . . . . . . . . 347
19.4 Animating the data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 349
19.5 Making interactive dialogs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350
19.6 Putting it together . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351

20 scikit-learn: machine learning in Python

353
20.1 Loading an example dataset
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 354
20.2 Classiﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355
20.3 Clustering: grouping observations together . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 357
20.4 Dimension Reduction with Principal Component Analysis . . . . . . . . . . . . . . . . . . . . . . . 359
20.5 Putting it all together: face recognition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360
20.6 Linear model: from regression to sparsity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
20.7 Model selection: choosing estimators and their parameters . . . . . . . . . . . . . . . . . . . . . . . 362

Index

363

iii

Scipy lecture notes, Edition 2015.2

Contents

1

Part I

Getting started with Python for science

2

This part of the Scipy lecture notes is a self-contained introduction to everything that is needed to use Python
for science, from the language itself, to numerical computing or plotting.

Scipy lecture notes, Edition 2015.2

3

CHAPTER 1

Scientific computing with tools and workflow

Authors: Fernando Perez, Emmanuelle Gouillart, Gaël Varoquaux, Valentin Haenel

1.1 Why Python?

1.1.1 The scientist’s needs

• Get data (simulation, experiment control),

• Manipulate and process data,

• Visualize results (to understand what we are doing!),

• Communicate results: produce ﬁgures for reports or publications, write presentations.

1.1.2 Specifications

• Rich collection of already existing bricks corresponding to classical numerical methods or basic actions:
we don’t want to re-program the plotting of a curve, a Fourier transform or a ﬁtting algorithm. Don’t
reinvent the wheel!

• Easy to learn: computer science is neither our job nor our education. We want to be able to draw a curve,

smooth a signal, do a Fourier transform in a few minutes.

• Easy communication with collaborators, students, customers, to make the code live within a lab or a
company: the code should be as readable as a book. Thus, the language should contain as few syn-
tax symbols or unneeded routines as possible that would divert the reader from the mathematical or
scientiﬁc understanding of the code.

• Efﬁcient code that executes quickly... but needless to say that a very fast code becomes useless if we
spend too much time writing it. So, we need both a quick development time and a quick execution time.

• A single environment/language for everything, if possible, to avoid learning a new software for each new

problem.

1.1.3 Existing solutions

Which solutions do scientists use to work?

Compiled languages: C, C++, Fortran, etc.

• Advantages:

– Very fast. Very optimized compilers. For heavy computations, it’s difﬁcult to outperform these

languages.

4

Scipy lecture notes, Edition 2015.2

– Some very optimized scientiﬁc libraries have been written for these languages. Example: BLAS

(vector/matrix operations)

• Drawbacks:

– Painful usage: no interactivity during development, mandatory compilation steps, verbose syntax
(&, ::, }}, ; etc.), manual memory management (tricky in C). These are difﬁcult languages for non
computer scientists.

Scripting languages: Matlab

• Advantages:

– Very rich collection of libraries with numerous algorithms, for many different domains. Fast exe-

cution because these libraries are often written in a compiled language.

– Pleasant development environment: comprehensive and well organized help, integrated editor,

etc.

– Commercial support is available.

• Drawbacks:

– Base language is quite poor and can become restrictive for advanced users.

– Not free.

Other scripting languages: Scilab, Octave, Igor, R, IDL, etc.

• Advantages:

– Open-source, free, or at least cheaper than Matlab.

– Some features can be very advanced (statistics in R, ﬁgures in Igor, etc.)

• Drawbacks:

– Fewer available algorithms than in Matlab, and the language is not more advanced.

– Some software are dedicated to one domain. Ex: Gnuplot or xmgrace to draw curves. These pro-

grams are very powerful, but they are restricted to a single type of usage, such as plotting.

What about Python?

• Advantages:

– Very rich scientiﬁc computing libraries (a bit less than Matlab, though)

– Well thought out language, allowing to write very readable and well structured code: we “code what

we think”.

– Many libraries for other tasks than scientiﬁc computing (web server management, serial port ac-

cess, etc.)

– Free and open-source software, widely spread, with a vibrant community.

• Drawbacks:

– less pleasant development environment than, for example, Matlab. (More geek-oriented).

– Not all the algorithms that can be found in more specialized software or toolboxes.

1.2 Scientific Python building blocks

Unlike Matlab, Scilab or R, Python does not come with a pre-bundled set of modules for scientiﬁc computing.
Below are the basic building blocks that can be combined to obtain a scientiﬁc computing environment:

• Python, a generic and modern computing language

1.2. Scientific Python building blocks

5

Scipy lecture notes, Edition 2015.2

– Python language: data types (string, int), ﬂow control, data collections (lists, dictionaries), pat-

terns, etc.

– Modules of the standard library.

– A large number of specialized modules or applications written in Python: web protocols, web

framework, etc. ... and scientiﬁc computing.

– Development tools (automatic testing, documentation generation)

• IPython, an advanced Python shell http://ipython.org/

• Numpy :

provides powerful numerical arrays objects, and routines to manipulate them.

http://www.numpy.org/

• Scipy :

high-level data processing routines.

Optimization,

regression,

interpolation, etc

http://www.scipy.org/

• Matplotlib : 2-D visualization, “publication-ready” plots http://matplotlib.org/

• Mayavi : 3-D visualization http://code.enthought.com/projects/mayavi/

1.3 The interactive workflow: IPython and a text editor

Interactive work to test and understand algorithms: In this section, we describe an interactive workﬂow with
IPython that is handy to explore and understand algorithms.

1.3. The interactive workflow: IPython and a text editor

6

Scipy lecture notes, Edition 2015.2

Python is a general-purpose language. As such, there is not one blessed environment to work in, and not only
one way of using it. Although this makes it harder for beginners to ﬁnd their way, it makes it possible for Python
to be used to write programs, in web servers, or embedded devices.

Reference document for this section:

IPython user manual: http://ipython.org/ipython-doc/dev/index.html

1.3.1 Command line interaction

Start ipython:

In [1]: print('Hello world')
Hello world

Getting help by using the ? operator after an object:

In [2]: print?
Type:
Base Class:
String Form:
Namespace:
Docstring:

builtin\_function\_or\_method


Python builtin

print(value, ..., sep=' ', end='\n', file=sys.stdout)

Prints the values to a stream, or to sys.stdout by default.
Optional keyword arguments:
file: a file-like object (stream); defaults to the current sys.stdout.
sep:
end:

string inserted between values, default a space.
string appended after the last value, default a newline.

1.3.2 Elaboration of the algorithm in an editor

Create a ﬁle my\_file.py in a text editor. Under EPD (Enthought Python Distribution), you can use Scite,
available from the start menu. Under Python(x,y), you can use Spyder. Under Ubuntu, if you don’t already
have your favorite editor, we would advise installing Stani’s Python editor. In the ﬁle, add the following
lines:

s = 'Hello world'
print(s)

Now, you can run it in IPython and explore the resulting variables:

In [1]: %run my\_file.py
Hello world

In [2]: s
Out[2]: 'Hello world'

In [3]: %whos
Variable
Data/Info
----------------------------
s

Type

str

Hello world

1.3. The interactive workflow: IPython and a text editor

7

Scipy lecture notes, Edition 2015.2

From a script to functions

While it is tempting to work only with scripts, that is a ﬁle full of instructions following each other, do
plan to progressively evolve the script to a set of functions:

• A script is not reusable, functions are.
• Thinking in terms of functions helps breaking the problem in small blocks.

1.3.3 IPython Tips and Tricks

The IPython user manual contains a wealth of information about using IPython, but to get you started we want
to give you a quick introduction to four useful features: history, magic functions, aliases and tab completion.

Like a UNIX shell, IPython supports command history. Type up and down to navigate previously typed com-
mands:

In [1]: x = 10

In [2]: 

In [2]: x = 10

IPython supports so called magic functions by preﬁxing a command with the % character. For example, the run
and whos functions from the previous section are magic functions. Note that, the setting automagic, which is
enabled by default, allows you to omit the preceding % sign. Thus, you can just type the magic function and it
will work.

Other useful magic functions are:

• %cd to change the current directory.

In [2]: cd /tmp
/tmp

• %timeit allows you to time the execution of short snippets using the timeit module from the standard

library:

In [3]: timeit x = 10
10000000 loops, best of 3: 39 ns per loop

• %cpaste allows you to paste code, especially code from websites which has been preﬁxed with the stan-

dard Python prompt (e.g. >>>) or with an ipython prompt, (e.g. in [3]):

In [5]: cpaste
Pasting code; enter '--' alone on the line to stop or use Ctrl-D.
:In [3]: timeit x = 10
:--
10000000 loops, best of 3: 85.9 ns per loop
In [6]: cpaste
Pasting code; enter '--' alone on the line to stop or use Ctrl-D.
:>>> timeit x = 10
:--
10000000 loops, best of 3: 86 ns per loop

• %debug allows you to enter post-mortem debugging. That is to say, if the code you try to execute, raises

an exception, using %debug will enter the debugger at the point where the exception was thrown.

In [7]: x === 10

File "", line 1

x === 10
^

SyntaxError: invalid syntax

1.3. The interactive workflow: IPython and a text editor

8

Scipy lecture notes, Edition 2015.2

In [8]: debug
> /.../IPython/core/compilerop.py (87)ast\_parse()

86
---> 87
88

and are passed to the built-in compile function."""
return compile(source, filename, symbol, self.flags | PyCF\_ONLY\_AST, 1)

ipdb>locals()
{'source': u'x === 10\n', 'symbol': 'exec', 'self':
,
'filename': ''}

IPython help

• The built-in IPython cheat-sheet is accessible via the %quickref magic function.
• A list of all available magic functions is shown when typing %magic.

Furthermore IPython ships with various aliases which emulate common UNIX command line tools such as ls
to list ﬁles, cp to copy ﬁles and rm to remove ﬁles. A list of aliases is shown when typing alias:

In [1]: alias
Total number of aliases: 16
Out[1]:
[('cat', 'cat'),
('clear', 'clear'),
('cp', 'cp -i'),
('ldir', 'ls -F -o --color %l | grep /$'),
('less', 'less'),
('lf', 'ls -F -o --color %l | grep ^-'),
('lk', 'ls -F -o --color %l | grep ^l'),
('ll', 'ls -F -o --color'),
('ls', 'ls -F --color'),
('lx', 'ls -F -o --color %l | grep ^-..x'),
('man', 'man'),
('mkdir', 'mkdir'),
('more', 'more'),
('mv', 'mv -i'),
('rm', 'rm -i'),
('rmdir', 'rmdir')]

Lastly, we would like to mention the tab completion feature, whose description we cite directly from the
IPython manual:

Tab completion, especially for attributes, is a convenient way to explore the structure of any object you’re dealing
with. Simply type object\_name. to view the object’s attributes. Besides Python objects and keywords, tab
completion also works on ﬁle and directory names.

In [1]: x = 10

In [2]: x.
x.bit\_length
x.real

x.conjugate

x.denominator

x.imag

x.numerator

In [3]: x.real.
x.real.bit\_length
x.real.conjugate

In [4]: x.real.

x.real.denominator
x.real.imag

x.real.numerator
x.real.real

1.3. The interactive workflow: IPython and a text editor

9

CHAPTER 2

The Python language

Authors: Chris Burns, Christophe Combelles, Emmanuelle Gouillart, Gaël Varoquaux

Python for scientiﬁc computing

We introduce here the Python language. Only the bare minimum necessary for getting started with
Numpy and Scipy is addressed here. To learn more about the language, consider going through
the excellent tutorial https://docs.python.org/tutorial. Dedicated books are also available, such as
http://www.diveintopython.net/.

Python is a programming language, as are C, Fortran, BASIC, PHP, etc. Some speciﬁc features of Python are as
follows:

• an interpreted (as opposed to compiled) language. Contrary to e.g. C or Fortran, one does not compile
Python code before executing it. In addition, Python can be used interactively: many Python inter-
preters are available, from which commands and scripts can be executed.

• a free software released under an open-source license: Python can be used and distributed free of

charge, even for building commercial software.

• multi-platform: Python is available for all major operating systems, Windows, Linux/Unix, MacOS X,

most likely your mobile phone OS, etc.

• a very readable language with clear non-verbose syntax
• a language for which a large variety of high-quality packages are available for various applications, from

web frameworks to scientiﬁc computing.

• a language very easy to interface with other languages, in particular C and C++.
• Some other features of the language are illustrated just below. For example, Python is an object-oriented
language, with dynamic typing (the same variable can contain objects of different types during the
course of a program).

See https://www.python.org/about/ for more information about distinguishing features of Python.

2.1 First steps

Start the Ipython shell (an enhanced interactive Python shell):

• by typing “ipython” from a Linux/Mac terminal, or from the Windows cmd shell,

10

Scipy lecture notes, Edition 2015.2

• or by starting the program from a menu, e.g. in the Python(x,y) or EPD menu if you have installed one

of these scientiﬁc-Python suites.

If you don’t have Ipython installed on your computer, other Python shells are available, such as the plain
Python shell started by typing “python” in a terminal, or the Idle interpreter. However, we advise to use the
Ipython shell because of its enhanced features, especially for interactive scientiﬁc computing.

Once you have started the interpreter, type

>>> print("Hello, world!")
Hello, world!

The message “Hello, world!” is then displayed. You just executed your ﬁrst Python instruction, congratulations!

To get yourself started, type the following stack of instructions

>>> a = 3
>>> b = 2\*a
>>> type(b)

>>> print(b)
6
>>> a\*b
18
>>> b = 'hello'
>>> type(b)

>>> b + b
'hellohello'
>>> 2\*b
'hellohello'

Two variables a and b have been deﬁned above. Note that one does not declare the type of an variable before
assigning its value. In C, conversely, one should write:

int a = 3;

In addition, the type of a variable may change, in the sense that at one point in time it can be equal to a
value of a certain type, and a second point in time, it can be equal to a value of a different type. b was ﬁrst
equal to an integer, but it became equal to a string when it was assigned the value ’hello’. Operations on
integers (b=2\*a) are coded natively in Python, and so are some operations on strings such as additions and
multiplications, which amount respectively to concatenation and repetition.

2.2 Basic types

2.2.1 Numerical types

Python supports the following numerical, scalar types:

Integer

>>> 1 + 1
2
>>> a = 4
>>> type(a)


Floats

>>> c = 2.1
>>> type(c)


2.2. Basic types

11

Scipy lecture notes, Edition 2015.2

Complex

>>> a = 1.5 + 0.5j
>>> a.real
1.5
>>> a.imag
0.5
>>> type(1. + 0j)


Booleans

>>> 3 > 4
False
>>> test = (3 > 4)
>>> test
False
>>> type(test)


A Python shell can therefore replace your pocket calculator, with the basic arithmetic operations +, -, \*, /, %
(modulo) natively implemented

>>> 7 \* 3.
21.0
>>> 2\*\*10
1024
>>> 8 % 3
2

Type conversion (casting):

>>> float(1)
1.0

2.2. Basic types

12

Scipy lecture notes, Edition 2015.2

(cid:66)

Integer division
In Python 2:

>>> 3 / 2
1

In Python 3:

>>> 3 / 2
1.5

To be safe: use ﬂoats:

>>> 3 / 2.
1.5

>>> a = 3
>>> b = 2
>>> a / b # In Python 2
1
>>> a / float(b)
1.5

Future behavior: to always get the behavior of Python3

>>> from \_\_future\_\_ import division
>>> 3 / 2
1.5
If you explicitly want integer division use //:

>>> 3.0 // 2
1.0

The behaviour of the division operator has changed in Python 3.

2.2.2 Containers

Python provides many efﬁcient types of containers, in which collections of objects can be stored.

Lists

A list is an ordered collection of objects, that may have different types. For example:

>>> l = ['red', 'blue', 'green', 'black', 'white']
>>> type(l)


Indexing: accessing individual objects contained in the list:

>>> l[2]
'green'

Counting from the end with negative indices:

>>> l[-1]
'white'
>>> l[-2]
'black'

(cid:66)

Indexing starts at 0 (as in C), not at 1 (as in Fortran or Matlab)!

Slicing: obtaining sublists of regularly-spaced elements:

2.2. Basic types

13

Scipy lecture notes, Edition 2015.2

>>> l
['red', 'blue', 'green', 'black', 'white']
>>> l[2:4]
['green', 'black']

(cid:66)

Note that l[start:stop] contains the elements with indices i such as start<= i < stop (i ranging from
start to stop-1). Therefore, l[start:stop] has (stop - start) elements.

Slicing syntax: l[start:stop:stride]

All slicing parameters are optional:

>>> l
['red', 'blue', 'green', 'black', 'white']
>>> l[3:]
['black', 'white']
>>> l[:3]
['red', 'blue', 'green']
>>> l[::2]
['red', 'green', 'white']

Lists are mutable objects and can be modiﬁed:

>>> l[0] = 'yellow'
>>> l
['yellow', 'blue', 'green', 'black', 'white']
>>> l[2:4] = ['gray', 'purple']
>>> l
['yellow', 'blue', 'gray', 'purple', 'white']

The elements of a list may have different types:

>>> l = [3, -200, 'hello']
>>> l
[3, -200, 'hello']
>>> l[1], l[2]
(-200, 'hello')
For collections of numerical data that all have the same type, it is often more efﬁcient to use the array type
provided by the numpy module. A NumPy array is a chunk of memory containing ﬁxed-sized items. With
NumPy arrays, operations on elements can be faster because elements are regularly spaced in memory and
more operations are performed through specialized C functions instead of Python loops.

Python offers a large panel of functions to modify lists, or query them. Here are a few examples; for more
details, see https://docs.python.org/tutorial/datastructures.html#more-on-lists

Add and remove elements:

>>> L = ['red', 'blue', 'green', 'black', 'white']
>>> L.append('pink')
>>> L
['red', 'blue', 'green', 'black', 'white', 'pink']
>>> L.pop() # removes and returns the last item
'pink'
>>> L
['red', 'blue', 'green', 'black', 'white']
>>> L.extend(['pink', 'purple']) # extend L, in-place
>>> L
['red', 'blue', 'green', 'black', 'white', 'pink', 'purple']
>>> L = L[:-2]
>>> L
['red', 'blue', 'green', 'black', 'white']

Reverse:

2.2. Basic types

14

Scipy lecture notes, Edition 2015.2

>>> r = L[::-1]
>>> r
['white', 'black', 'green', 'blue', 'red']
>>> r2 = list(L)
>>> r2
['red', 'blue', 'green', 'black', 'white']
>>> r2.reverse() # in-place
>>> r2
['white', 'black', 'green', 'blue', 'red']

Concatenate and repeat lists:

>>> r + L
['white', 'black', 'green', 'blue', 'red', 'red', 'blue', 'green', 'black', 'white']
>>> r \* 2
['white', 'black', 'green', 'blue', 'red', 'white', 'black', 'green', 'blue', 'red']

Sort:

>>> sorted(r) # new object
['black', 'blue', 'green', 'red', 'white']
>>> r
['white', 'black', 'green', 'blue', 'red']
>>> r.sort() # in-place
>>> r
['black', 'blue', 'green', 'red', 'white']

Methods and Object-Oriented Programming
The notation r.method() (e.g. r.append(3) and L.pop()) is our ﬁrst example of object-oriented pro-
gramming (OOP). Being a list, the object r owns the method function that is called using the notation
.. No further knowledge of OOP than understanding the notation . is necessary for going through this
tutorial.

Discovering methods:

Reminder: in Ipython: tab-completion (press tab)

In [28]: r.
r.\_\_add\_\_
r.\_\_class\_\_
r.\_\_contains\_\_
r.\_\_delattr\_\_
r.\_\_delitem\_\_
r.\_\_delslice\_\_
r.\_\_doc\_\_
r.\_\_eq\_\_
r.\_\_format\_\_
r.\_\_ge\_\_
r.\_\_getattribute\_\_
r.\_\_getitem\_\_
r.\_\_getslice\_\_
r.\_\_gt\_\_
r.\_\_hash\_\_

r.\_\_iadd\_\_
r.\_\_imul\_\_
r.\_\_init\_\_
r.\_\_iter\_\_
r.\_\_le\_\_
r.\_\_len\_\_
r.\_\_lt\_\_
r.\_\_mul\_\_
r.\_\_ne\_\_
r.\_\_new\_\_
r.\_\_reduce\_\_
r.\_\_reduce\_ex\_\_
r.\_\_repr\_\_
r.\_\_reversed\_\_
r.\_\_rmul\_\_

r.\_\_setattr\_\_
r.\_\_setitem\_\_
r.\_\_setslice\_\_
r.\_\_sizeof\_\_
r.\_\_str\_\_
r.\_\_subclasshook\_\_
r.append
r.count
r.extend
r.index
r.insert
r.pop
r.remove
r.reverse
r.sort

Strings

Different string syntaxes (simple, double or triple quotes):

2.2. Basic types

15

Scipy lecture notes, Edition 2015.2

s = 'Hello, how are you?'
s = "Hi, what's up"
s = '''Hello,

how are you'''

s = """Hi,
what's up?"""

# tripling the quotes allows the
# the string to span more than one line

In [1]: 'Hi, what's up?'
------------------------------------------------------------

File "", line 1

'Hi, what's up?'
^

SyntaxError: invalid syntax

The newline character is \n, and the tab character is \t.

Strings are collections like lists. Hence they can be indexed and sliced, using the same syntax and rules.

Indexing:

>>> a = "hello"
>>> a[0]
'h'
>>> a[1]
'e'
>>> a[-1]
'o'

(Remember that negative indices correspond to counting from the right end.)

Slicing:

>>> a = "hello, world!"
>>> a[3:6] # 3rd to 6th (excluded) elements: elements 3, 4, 5
'lo,'
>>> a[2:10:2] # Syntax: a[start:stop:step]
'lo o'
>>> a[::3] # every three characters, from beginning to end
'hl r!'

Accents
characters
https://docs.python.org/tutorial/introduction.html#unicode-strings).

special

also

and

can

be

handled

in

Unicode

strings

(see

A string is an immutable object and it is not possible to modify its contents. One may however create new
strings from the original one.

In [53]: a = "hello, world!"
In [54]: a[2] = 'z'
---------------------------------------------------------------------------
Traceback (most recent call last):

File "", line 1, in 

TypeError: 'str' object does not support item assignment

In [55]: a.replace('l', 'z', 1)
Out[55]: 'hezlo, world!'
In [56]: a.replace('l', 'z')
Out[56]: 'hezzo, worzd!'

Strings have many useful methods, such as a.replace as seen above. Remember the a. object-oriented
notation and use tab completion or help(str) to search for new methods.

See also:

Python offers advanced possibilities for manipulating strings,
looking for patterns or formatting.
The interested reader is referred to https://docs.python.org/library/stdtypes.html#string-methods and
https://docs.python.org/library/string.html#new-string-formatting

2.2. Basic types

16

Scipy lecture notes, Edition 2015.2

String formatting:

>>> 'An integer: %i ; a float: %f ; another string: %s ' % (1, 0.1, 'string')
'An integer: 1; a float: 0.100000; another string: string'

>>> i = 102
>>> filename = 'processing\_of\_dataset\_%d .txt' % i
>>> filename
'processing\_of\_dataset\_102.txt'

Dictionaries

A dictionary is basically an efﬁcient table that maps keys to values. It is an unordered container

>>> tel = {'emmanuelle': 5752, 'sebastian': 5578}
>>> tel['francis'] = 5915
>>> tel
{'sebastian': 5578, 'francis': 5915, 'emmanuelle': 5752}
>>> tel['sebastian']
5578
>>> tel.keys()
['sebastian', 'francis', 'emmanuelle']
>>> tel.values()
[5578, 5915, 5752]
>>> 'francis' in tel
True

It can be used to conveniently store and retrieve values associated with a name (a string for a date, a name,
etc.). See https://docs.python.org/tutorial/datastructures.html#dictionaries for more information.
A dictionary can have keys (resp. values) with different types:

>>> d = {'a':1, 'b':2, 3:'hello'}
>>> d
{'a': 1, 3: 'hello', 'b': 2}

More container types

Tuples

Tuples are basically immutable lists. The elements of a tuple are written between parentheses, or just separated
by commas:

>>> t = 12345, 54321, 'hello!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hello!')
>>> u = (0, 2)

Sets: unordered, unique items:

>>> s = set(('a', 'b', 'c', 'a'))
>>> s
set(['a', 'c', 'b'])
>>> s.difference(('a', 'b'))
set(['c'])

2.2. Basic types

17

Scipy lecture notes, Edition 2015.2

2.2.3 Assignment operator

Python library reference says:

Assignment statements are used to (re)bind names to values and to modify attributes or items of
mutable objects.

In short, it works as follows (simple assignment):

1. an expression on the right hand side is evaluated, the corresponding object is created/obtained
2. a name on the left hand side is assigned, or bound, to the r.h.s. object

Things to note:

• a single object can have several names bound to it:

In [1]: a = [1, 2, 3]
In [2]: b = a
In [3]: a
Out[3]: [1, 2, 3]
In [4]: b
Out[4]: [1, 2, 3]
In [5]: a is b
Out[5]: True
In [6]: b[1] = 'hi!'
In [7]: a
Out[7]: [1, 'hi!', 3]

• to change a list in place, use indexing/slices:

In [1]: a = [1, 2, 3]
In [3]: a
Out[3]: [1, 2, 3]
In [4]: a = ['a', 'b', 'c'] # Creates another object.
In [5]: a
Out[5]: ['a', 'b', 'c']
In [6]: id(a)
Out[6]: 138641676
In [7]: a[:] = [1, 2, 3] # Modifies object in place.
In [8]: a
Out[8]: [1, 2, 3]
In [9]: id(a)
Out[9]: 138641676 # Same as in Out[6], yours will differ...

• the key concept here is mutable vs. immutable

– mutable objects can be changed in place

– immutable objects cannot be modiﬁed once created

See also:

A very good and detailed explanation of the above issues can be found in David M. Beazley’s article Types and
Objects in Python.

2.3 Control Flow

Controls the order in which the code is executed.

2.3.1 if/elif/else

>>> if 2\*\*2 == 4:
...

print('Obvious!')

2.3. Control Flow

18

Scipy lecture notes, Edition 2015.2

...
Obvious!

Blocks are delimited by indentation

Type the following lines in your Python interpreter, and be careful to respect the indentation depth. The
Ipython shell automatically increases the indentation depth after a column : sign; to decrease the indentation
depth, go four spaces to the left with the Backspace key. Press the Enter key twice to leave the logical block.

>>> a = 10

>>> if a == 1:
print(1)
...
... elif a == 2:
print(2)
...
... else:
...
A lot

print('A lot')

Indentation is compulsory in scripts as well. As an exercise, re-type the previous lines with the same indenta-
tion in a script condition.py, and execute the script with run condition.py in Ipython.

2.3.2 for/range

Iterating with an index:

>>> for i in range(4):
print(i)
...
0
1
2
3

But most often, it is more readable to iterate over values:

print('Python is %s ' % word)

>>> for word in ('cool', 'powerful', 'readable'):
...
Python is cool
Python is powerful
Python is readable

2.3.3 while/break/continue

Typical C-style while loop (Mandelbrot problem):

>>> z = 1 + 1j
>>> while abs(z) < 100:
...
>>> z
(-134+352j)

z = z\*\*2 + 1

More advanced features
break out of enclosing for/while loop:

>>> z = 1 + 1j

>>> while abs(z) < 100:
if z.imag == 0:
...
break
...
z = z\*\*2 + 1
...

2.3. Control Flow

19

continue the next iteration of a loop.:

Scipy lecture notes, Edition 2015.2

if element == 0:
continue

>>> a = [1, 0, 2, 4]
>>> for element in a:
...
...
...
1.0
0.5
0.25

print(1. / element)

2.3.4 Conditional Expressions

if 

Evaluates to False:

• any number equal to zero (0, 0.0, 0+0j)

• an empty container (list, tuple, set, dictionary, ...)
• False, None

Evaluates to True:

• everything else

a == b Tests equality, with logics:

>>> 1 == 1.
True

a is b Tests identity: both sides are the same object:

>>> 1 is 1.
False

>>> a = 1
>>> b = 1
>>> a is b
True

a in b For any collection b: b contains a

>>> b = [1, 2, 3]
>>> 2 in b
True
>>> 5 in b
False

If b is a dictionary, this tests that a is a key of b.

2.3.5 Advanced iteration

Iterate over any sequence

You can iterate over any sequence (string, list, keys in a dictionary, lines in a ﬁle, ...):

>>> vowels = 'aeiouy'

>>> for i in 'powerful':
if i in vowels:
...
print(i)
...
o

2.3. Control Flow

20

Scipy lecture notes, Edition 2015.2

e
u

>>> message = "Hello how are you?"
>>> message.split() # returns a list
['Hello', 'how', 'are', 'you?']
>>> for word in message.split():
...
...
Hello
how
are
you?

print(word)

Few languages (in particular, languages for scientiﬁc computing) allow to loop over anything but inte-
gers/indices. With Python it is possible to loop exactly over the objects of interest without bothering with
indices you often don’t care about. This feature can often be used to make code more readable.

(cid:66)

Not safe to modify the sequence you are iterating over.

Keeping track of enumeration number

Common task is to iterate over a sequence while keeping track of the item number.

• Could use while loop with a counter as above. Or a for loop:

>>> words = ('cool', 'powerful', 'readable')
>>> for i in range(0, len(words)):
print((i, words[i]))
...
(0, 'cool')
(1, 'powerful')
(2, 'readable')

• But, Python provides a built-in function - enumerate - for this:

print((index, item))

>>> for index, item in enumerate(words):
...
(0, 'cool')
(1, 'powerful')
(2, 'readable')

Looping over a dictionary

Use items:

>>> d = {'a': 1, 'b':1.2, 'c':1j}

print('Key: %s has value: %s ' % (key, val))

>>> for key, val in sorted(d.items()):
...
Key: a has value: 1
Key: b has value: 1.2
Key: c has value: 1j

The ordering of a dictionary in random, thus we use sorted() which will sort on the keys.

2.3.6 List Comprehensions

>>> [i\*\*2 for i in range(4)]
[0, 1, 4, 9]

2.3. Control Flow

21

Scipy lecture notes, Edition 2015.2

Exercise

Compute the decimals of Pi using the Wallis formula:

π = 2

∞
(cid:89)

i =1

4i 2
4i 2 − 1

2.4 Defining functions

2.4.1 Function definition

In [56]: def test():

print('in test function')

....:
....:
....:

In [57]: test()
in test function

(cid:66)

Function blocks must be indented as other control-ﬂow blocks.

2.4.2 Return statement

Functions can optionally return values.

In [6]: def disk\_area(radius):

...:
...:

return 3.14 \* radius \* radius

In [8]: disk\_area(1.5)
Out[8]: 7.0649999999999995

By default, functions return None.

Note the syntax to deﬁne a function:

• the def keyword;
• is followed by the function’s name, then
• the arguments of the function are given between parentheses followed by a colon.
• the function body;
• and return object for optionally returning values.

2.4.3 Parameters

Mandatory parameters (positional arguments)

In [81]: def double\_it(x):
return x \* 2

....:
....:

In [82]: double\_it(3)
Out[82]: 6

In [83]: double\_it()
---------------------------------------------------------------------------

2.4. Defining functions

22

Scipy lecture notes, Edition 2015.2

Traceback (most recent call last):

File "", line 1, in 

TypeError: double\_it() takes exactly 1 argument (0 given)

Optional parameters (keyword or named arguments)

In [84]: def double\_it(x=2):

....:
....:

return x \* 2

In [85]: double\_it()
Out[85]: 4

In [86]: double\_it(3)
Out[86]: 6

Keyword arguments allow you to specify default values.

(cid:66)

Default values are evaluated when the function is deﬁned, not when it is called. This can be problematic when
using mutable types (e.g. dictionary or list) and modifying them in the function body, since the modiﬁcations
will be persistent across invocations of the function.
Using an immutable type in a keyword argument:

In [124]: bigx = 10

In [125]: def double\_it(x=bigx):

.....:
.....:

return x \* 2

In [126]: bigx = 1e9 # Now really big

In [128]: double\_it()
Out[128]: 20

Using an mutable type in a keyword argument (and modifying it inside the function body):

In [2]: def add\_to\_dict(args={'a': 1, 'b': 2}):
for i in args.keys():
args[i] += 1

print args

...:
...:
...:
...:

In [3]: add\_to\_dict
Out[3]: 

In [4]: add\_to\_dict()
{'a': 2, 'b': 3}

In [5]: add\_to\_dict()
{'a': 3, 'b': 4}

In [6]: add\_to\_dict()
{'a': 4, 'b': 5}

2.4. Defining functions

23

Scipy lecture notes, Edition 2015.2

More involved example implementing python’s slicing:

In [98]: def slicer(seq, start=None, stop=None, step=None):

....:
....:
....:

"""Implement basic python slicing."""
return seq[start:stop:step]

In [101]: rhyme = 'one fish, two fish, red fish, blue fish'.split()

In [102]: rhyme
Out[102]: ['one', 'fish,', 'two', 'fish,', 'red', 'fish,', 'blue', 'fish']

In [103]: slicer(rhyme)
Out[103]: ['one', 'fish,', 'two', 'fish,', 'red', 'fish,', 'blue', 'fish']

In [104]: slicer(rhyme, step=2)
Out[104]: ['one', 'two', 'red', 'blue']

In [105]: slicer(rhyme, 1, step=2)
Out[105]: ['fish,', 'fish,', 'fish,', 'fish']

In [106]: slicer(rhyme, start=1, stop=4, step=2)
Out[106]: ['fish,', 'fish,']

The order of the keyword arguments does not matter:

In [107]: slicer(rhyme, step=2, start=1, stop=4)
Out[107]: ['fish,', 'fish,']

but it is good practice to use the same ordering as the function’s deﬁnition.

Keyword arguments are a very convenient feature for deﬁning functions with a variable number of arguments,
especially when default values are to be used in most calls to the function.

2.4.4 Passing by value

Can you modify the value of a variable inside a function? Most languages (C, Java, ...) distinguish “passing by
value” and “passing by reference”. In Python, such a distinction is somewhat artiﬁcial, and it is a bit subtle
whether your variables are going to be modiﬁed or not. Fortunately, there exist clear rules.
Parameters to functions are references to objects, which are passed by value. When you pass a variable to a
function, python passes the reference to the object to which the variable refers (the value). Not the variable
itself.

If the value passed in a function is immutable, the function does not modify the caller’s variable. If the value
is mutable, the function may modify the caller’s variable in-place:

x = 23
y.append(42)
z = [99] # new reference
print(x)
print(y)
print(z)

>>> def try\_to\_modify(x, y, z):
...
...
...
...
...
...
...
>>> a = 77
>>> b = [99]
>>> c = [28]
>>> try\_to\_modify(a, b, c)
23
[99, 42]
[99]
>>> print(a)
77

# immutable variable
# mutable variable

2.4. Defining functions

24

Scipy lecture notes, Edition 2015.2

>>> print(b)
[99, 42]
>>> print(c)
[28]

Functions have a local variable table called a local namespace.
The variable x only exists within the function try\_to\_modify.

2.4.5 Global variables

Variables declared outside the function can be referenced within the function:

In [114]: x = 5

In [115]: def addx(y):

.....:
.....:

return x + y

In [116]: addx(10)
Out[116]: 15

But these “global” variables cannot be modiﬁed within the function, unless declared global in the function.

This doesn’t work:

In [117]: def setx(y):

x = y
print('x is %d ' % x)

.....:
.....:
.....:
.....:

In [118]: setx(10)
x is 10

In [120]: x
Out[120]: 5

This works:

In [121]: def setx(y):
global x
x = y
print('x is %d ' % x)

.....:
.....:
.....:
.....:
.....:

In [122]: setx(10)
x is 10

In [123]: x
Out[123]: 10

2.4.6 Variable number of parameters

Special forms of parameters:

• \*args: any number of positional arguments packed into a tuple
• \*\*kwargs: any number of keyword arguments packed into a dictionary

2.4. Defining functions

25

Scipy lecture notes, Edition 2015.2

In [35]: def variable\_args(\*args, \*\*kwargs):

....:
....:
....:

print 'args is', args
print 'kwargs is', kwargs

In [36]: variable\_args('one', 'two', x=1, y=2, z=3)
args is ('one', 'two')
kwargs is {'y': 2, 'x': 1, 'z': 3}

2.4.7 Docstrings

Documentation about what the function does and its parameters. General convention:

In [67]: def funcname(params):

....:
....:
....:
....:
....:
....:
....:

"""Concise one-line sentence describing the function.

Extended summary which can contain multiple paragraphs.
"""
# function body
pass

In [68]: funcname?
Type:
Base Class:
String Form:
Namespace:
File:
Definition:
Docstring:

function
type 'function'>

Interactive

funcname(params)

Concise one-line sentence describing the function.

Extended summary which can contain multiple paragraphs.

Docstring guidelines
For the sake of standardization, the Docstring Conventions webpage documents the semantics and conven-
tions associated with Python docstrings.
Also, the Numpy and Scipy modules have deﬁned a precise standard for documenting scientiﬁc func-
tions, that you may want to follow for your own functions, with a Parameters section, an Examples
See http://projects.scipy.org/numpy/wiki/CodingStyleGuidelines#docstring-standard and
section, etc.
http://projects.scipy.org/numpy/browser/trunk/doc/example.py#L37

2.4.8 Functions are objects

Functions are ﬁrst-class objects, which means they can be:

• assigned to a variable

• an item in a list (or any collection)

• passed as an argument to another function.

In [38]: va = variable\_args

In [39]: va('three', x=1, y=2)
args is ('three',)
kwargs is {'y': 2, 'x': 1}

2.4. Defining functions

26

Scipy lecture notes, Edition 2015.2

2.4.9 Methods

Methods are functions attached to objects. You’ve seen these in our examples on lists, dictionaries, strings,
etc...

2.4.10 Exercises

Exercise: Fibonacci sequence
Write a function that displays the n ﬁrst terms of the Fibonacci sequence, deﬁned by:

• u\_0 = 1; u\_1 = 1
• u\_(n+2) = u\_(n+1) + u\_n

Exercise: Quicksort

Implement the quicksort algorithm, as deﬁned by wikipedia

function quicksort(array)

var list less, greater
if length(array) < 2
return array

select and remove a pivot value pivot from array
for each x in array

if x < pivot + 1 then append x to less
else append x to greater

return concatenate(quicksort(less), pivot, quicksort(greater))

2.5 Reusing code: scripts and modules

For now, we have typed all instructions in the interpreter. For longer sets of instructions we need to change
track and write the code in text ﬁles (using a text editor), that we will call either scripts or modules. Use your fa-
vorite text editor (provided it offers syntax highlighting for Python), or the editor that comes with the Scientiﬁc
Python Suite you may be using (e.g., Scite with Python(x,y)).

2.5.1 Scripts

Let us ﬁrst write a script, that is a ﬁle with a sequence of instructions that are executed each time the script is
called. Instructions may be e.g. copied-and-pasted from the interpreter (but take care to respect indentation
rules!).
The extension for Python ﬁles is .py. Write or copy-and-paste the following lines in a ﬁle called test.py

message = "Hello how are you?"
for word in message.split():

print word

Let us now execute the script interactively, that is inside the Ipython interpreter. This is maybe the most com-
mon use of scripts in scientiﬁc computing.

in Ipython, the syntax to execute a script is %run script.py. For example,

In [1]: %run test.py
Hello
how
are

2.5. Reusing code: scripts and modules

27

Scipy lecture notes, Edition 2015.2

you?

In [2]: message
Out[2]: 'Hello how are you?'

The script has been executed. Moreover the variables deﬁned in the script (such as message) are now available
inside the interpreter’s namespace.

Other interpreters also offer the possibility to execute scripts (e.g., execfile in the plain Python interpreter,
etc.).

It is also possible In order to execute this script as a standalone program, by executing the script inside a shell
terminal (Linux/Mac console or cmd Windows console). For example, if we are in the same directory as the
test.py ﬁle, we can execute this in a console:

$ python test.py
Hello
how
are
you?

Standalone scripts may also take command-line arguments
In file.py:

import sys
print sys.argv

$ python file.py test arguments
['file.py', 'test', 'arguments']

(cid:66)

Don’t implement option parsing yourself. Use modules such as optparse, argparse or docopt.

2.5.2 Importing objects from modules

In [1]: import os

In [2]: os
Out[2]: 

In [3]: os.listdir('.')
Out[3]:
['conf.py',

'basic\_types.rst',
'control\_flow.rst',
'functions.rst',
'python\_language.rst',
'reusing.rst',
'file\_io.rst',
'exceptions.rst',
'workflow.rst',
'index.rst']

And also:

In [4]: from os import listdir

Importing shorthands:

In [5]: import numpy as np

2.5. Reusing code: scripts and modules

28

Scipy lecture notes, Edition 2015.2

(cid:66)

from os import \*

This is called the star import and please, Use it with caution

• Makes the code harder to read and understand: where do symbols come from?
• Makes it impossible to guess the functionality by the context and the name (hint: os.name is the name

of the OS), and to proﬁt usefully from tab completion.

• Restricts the variable names you can use: os.name might override name, or vise-versa.
• Creates possible name clashes between modules.
• Makes the code impossible to statically check for undeﬁned symbols.

Modules are thus a good way to organize code in a hierarchical way. Actually, all the scientiﬁc computing tools
we are going to use are modules:

>>> import numpy as np # data arrays
>>> np.linspace(0, 10, 6)
array([
4.,
>>> import scipy # scientific computing

0.,

2.,

6.,

8., 10.])

In Python(x,y), Ipython(x,y) executes the following imports at startup:

>>> import numpy
>>> import numpy as np
>>> from pylab import \*
>>> import scipy

and it is not necessary to re-import these modules.

2.5.3 Creating modules

If we want to write larger and better organized programs (compared to simple scripts), where some objects
are deﬁned, (variables, functions, classes) and that we want to reuse several times, we have to create our own
modules.
Let us create a module demo contained in the ﬁle demo.py:

"A demo module."

def print\_b():
"Prints b."
print 'b'

def print\_a():
"Prints a."
print 'a'

c = 2
d = 2

In this ﬁle, we deﬁned two functions print\_a and print\_b. Suppose we want to call the print\_a function
from the interpreter. We could execute the ﬁle as a script, but since we just want to have access to the function
print\_a, we are rather going to import it as a module. The syntax is as follows.

In [1]: import demo

In [2]: demo.print\_a()
a

In [3]: demo.print\_b()
b

2.5. Reusing code: scripts and modules

29

Scipy lecture notes, Edition 2015.2

Importing the module gives access to its objects, using the module.object syntax. Don’t forget to put the
module’s name before the object’s name, otherwise Python won’t recognize the instruction.

Introspection

module

In [4]: demo?
Type:
Base Class: 
String Form:
Namespace:
File:
Docstring:

Interactive



/home/varoquau/Projects/Python\_talks/scipy\_2009\_tutorial/source/demo.py

A demo module.

In [5]: who
demo

In [6]: whos
Data/Info
Variable
------------------------------
demo

module

Type



In [7]: dir(demo)
Out[7]:
['\_\_builtins\_\_',
'\_\_doc\_\_',
'\_\_file\_\_',
'\_\_name\_\_',
'\_\_package\_\_',
'c',
'd',
'print\_a',
'print\_b']

In [8]: demo.
demo.\_\_builtins\_\_
demo.\_\_class\_\_
demo.\_\_delattr\_\_
demo.\_\_dict\_\_
demo.\_\_doc\_\_
demo.\_\_file\_\_
demo.\_\_format\_\_
demo.\_\_getattribute\_\_
demo.\_\_hash\_\_

demo.\_\_init\_\_
demo.\_\_name\_\_
demo.\_\_new\_\_
demo.\_\_package\_\_
demo.\_\_reduce\_\_
demo.\_\_reduce\_ex\_\_
demo.\_\_repr\_\_
demo.\_\_setattr\_\_
demo.\_\_sizeof\_\_

demo.\_\_str\_\_
demo.\_\_subclasshook\_\_
demo.c
demo.d
demo.print\_a
demo.print\_b
demo.py
demo.pyc

Importing objects from modules into the main namespace

In [9]: from demo import print\_a, print\_b

Type

In [10]: whos
Variable
Data/Info
--------------------------------
demo
print\_a
print\_b

module
function
function





In [11]: print\_a()
a

2.5. Reusing code: scripts and modules

30

Scipy lecture notes, Edition 2015.2

(cid:66)

Module caching

Modules are cached: if you modify demo.py and re-import it in the old session, you will get the old
one.

Solution:

In [10]: reload(demo)

2.5.4 ‘\_\_main\_\_’ and module loading

Sometimes we want code to be executed when a module is run directly, but not when it is imported by another
module. if \_\_name\_\_ == ’\_\_main\_\_’ allows us to check whether the module is being run directly.

File demo2.py:

def print\_b():
"Prints b."
print 'b'

def print\_a():
"Prints a."
print 'a'

# print\_b() runs on import
print\_b()

if \_\_name\_\_ == '\_\_main\_\_':

# print\_a() is only executed when the module is run directly.
print\_a()

Importing it:

In [11]: import demo2
b

In [12]: import demo2

Running it:

In [13]: %run demo2
b
a

2.5.5 Scripts or modules? How to organize your code

Rule of thumb

• Sets of instructions that are called several times should be written inside functions for better code

reusability.

• Functions (or other bits of code) that are called from several scripts should be written inside a module,
so that only the module is imported in the different scripts (do not copy-and-paste your functions in the
different scripts!).

How modules are found and imported

When the import mymodule statement is executed, the module mymodule is searched in a given list of direc-
tories. This list includes a list of installation-dependent default path (e.g., /usr/lib/python) as well as the
list of directories speciﬁed by the environment variable PYTHONPATH.
The list of directories searched by Python is given by the sys.path variable

2.5. Reusing code: scripts and modules

31

Scipy lecture notes, Edition 2015.2

In [1]: import sys

In [2]: sys.path
Out[2]:
['',

'/home/varoquau/.local/bin',
'/usr/lib/python2.7',
'/home/varoquau/.local/lib/python2.7/site-packages',
'/usr/lib/python2.7/dist-packages',
'/usr/local/lib/python2.7/dist-packages',
...]

Modules must be located in the search path, therefore you can:

• write

your own modules within directories already deﬁned in the

search path (e.g.
You may use symbolic links (on Linux) to

$HOME/.local/lib/python2.7/dist-packages).
keep the code somewhere else.

• modify the environment variable PYTHONPATH to include the directories containing the user-deﬁned

modules.

On Linux/Unix, add the following line to a ﬁle read by the shell at startup (e.g. /etc/proﬁle, .proﬁle)

export PYTHONPATH=$PYTHONPATH:/home/emma/user\_defined\_modules

On Windows, http://support.microsoft.com/kb/310519 explains how to handle environment variables.

• or modify the sys.path variable itself within a Python script.

import sys
new\_path = '/home/emma/user\_defined\_modules'
if new\_path not in sys.path:
sys.path.append(new\_path)

This method is not very robust, however, because it makes the code less portable (user-dependent path) and
because you have to add the directory to your sys.path each time you want to import from a module in this
directory.

See also:

See https://docs.python.org/tutorial/modules.html for more information about modules.

2.5.6 Packages

A directory that contains many modules is called a package. A package is a module with submodules (which
can have submodules themselves, etc.). A special ﬁle called \_\_init\_\_.py (which may be empty) tells Python
that the directory is a Python package, from which modules can be imported.

$ ls
cluster/
\_\_config\_\_.py@
\_\_config\_\_.pyc
constants/
fftpack/
\_\_init\_\_.py@
\_\_init\_\_.pyc
INSTALL.txt@
integrate/
interpolate/
$ cd ndimage
$ ls
doccer.py@
doccer.pyc
setupscons.py@

io/
LATEST.txt@
lib/
linalg/
linsolve/
maxentropy/
misc/
ndimage/
odr/
optimize/

README.txt@
setup.py@
setup.pyc
setupscons.py@
setupscons.pyc
signal/
sparse/
spatial/
special/
stats/

stsci/
\_\_svn\_version\_\_.py@
\_\_svn\_version\_\_.pyc
THANKS.txt@
TOCHANGE.txt@
version.py@
version.pyc
weave/

fourier.pyc
info.py@

interpolation.py@
interpolation.pyc

morphology.pyc
\_nd\_image.so

setup.pyc

2.5. Reusing code: scripts and modules

32

filters.py@
setupscons.pyc
filters.pyc
fourier.py@

info.pyc

\_\_init\_\_.py@
\_\_init\_\_.pyc

Scipy lecture notes, Edition 2015.2

measurements.py@

\_ni\_support.py@

measurements.pyc
morphology.py@

\_ni\_support.pyc
setup.py@

tests/

From Ipython:

In [1]: import scipy

In [2]: scipy.\_\_file\_\_
Out[2]: '/usr/lib/python2.6/dist-packages/scipy/\_\_init\_\_.pyc'

In [3]: import scipy.version

In [4]: scipy.version.version
Out[4]: '0.7.0'

In [5]: import scipy.ndimage.morphology

In [6]: from scipy.ndimage import morphology

In [17]: morphology.binary\_dilation?
Type:
Base Class:
String Form:
Namespace:
File:
Definition:
iterations=1, mask=None, output=None, border\_value=0, origin=0,
brute\_force=False)
Docstring:

function


Interactive
/usr/lib/python2.6/dist-packages/scipy/ndimage/morphology.py
morphology.binary\_dilation(input, structure=None,

Multi-dimensional binary dilation with the given structure.

An output array can optionally be provided. The origin parameter
controls the placement of the filter. If no structuring element is
provided an element is generated with a squared connectivity equal
to one. The dilation operation is repeated iterations times.
iterations is less than 1, the dilation is repeated until the
result does not change anymore.
elements with a true value at the corresponding mask element are
modified at each iteration.

If a mask is given, only those

If

2.5.7 Good practices

• Use meaningful object names

• Indentation: no choice!

Indenting is compulsory in Python! Every command block following a colon bears an additional indentation
level with respect to the previous line with a colon. One must therefore indent after def f(): or while:.
At the end of such logical blocks, one decreases the indentation depth (and re-increases it if a new block is
entered, etc.)
Strict respect of indentation is the price to pay for getting rid of { or ; characters that delineate logical blocks
in other languages. Improper indentation leads to errors such as
------------------------------------------------------------
IndentationError: unexpected indent (test.py, line 2)

All this indentation business can be a bit confusing in the beginning. However, with the clear indentation, and
in the absence of extra characters, the resulting code is very nice to read compared to other languages.

• Indentation depth: Inside your text editor, you may choose to indent with any positive number of spaces
(1, 2, 3, 4, ...). However, it is considered good practice to indent with 4 spaces. You may conﬁgure your

2.5. Reusing code: scripts and modules

33

Scipy lecture notes, Edition 2015.2

editor to map the Tab key to a 4-space indentation. In Python(x,y), the editor is already conﬁgured this
way.

• Style guidelines

Long lines: you should not write very long lines that span over more than (e.g.) 80 characters. Long lines
can be broken with the \ character

>>> long\_line = "Here is a very very long line \
... that we break in two parts."

Spaces

Write well-spaced code: put whitespaces after commas, around arithmetic operators, etc.:

>>> a = 1 # yes
>>> a=1 # too cramped

A certain number of rules for writing “beautiful” code (and more importantly using the same conven-
tions as anybody else!) are given in the Style Guide for Python Code.

Quick read

If you want to do a ﬁrst quick pass through the Scipy lectures to learn the ecosystem, you can directly
skip to the next chapter: NumPy: creating and manipulating numerical data.
The remainder of this chapter is not necessary to follow the rest of the intro part. But be sure to come
back and ﬁnish this chapter later.

2.6 Input and Output

To be exhaustive, here are some information about input and output in Python. Since we will use the Numpy
methods to read and write ﬁles, you may skip this chapter at ﬁrst reading.

We write or read strings to/from ﬁles (other types must be converted to strings). To write in a ﬁle:

>>> f = open('workfile', 'w') # opens the workfile file
>>> type(f)

>>> f.write('This is a test \nand another test')
>>> f.close()

To read from a ﬁle

In [1]: f = open('workfile', 'r')

In [2]: s = f.read()

In [3]: print(s)
This is a test
and another test

In [4]: f.close()

See also:

For more details: https://docs.python.org/tutorial/inputoutput.html

2.6.

Input and Output

34

Scipy lecture notes, Edition 2015.2

2.6.1 Iterating over a file

In [6]: f = open('workfile', 'r')

In [7]: for line in f:
print line

...:
...:

This is a test

and another test

In [8]: f.close()

File modes

• Read-only: r
• Write-only: w

– Note: Create a new ﬁle or overwrite existing ﬁle.

• Append a ﬁle: a
• Read and Write: r+
• Binary mode: b

– Note: Use for binary ﬁles, especially on Windows.

2.7 Standard Library

Reference document for this section:

• The Python Standard Library documentation: https://docs.python.org/library/index.html
• Python Essential Reference, David Beazley, Addison-Wesley Professional

2.7.1 os module: operating system functionality

“A portable way of using operating system dependent functionality.”

Directory and file manipulation

Current directory:

In [17]: os.getcwd()
Out[17]: '/Users/cburns/src/scipy2009/scipy\_2009\_tutorial/source'

List a directory:

In [31]: os.listdir(os.curdir)
Out[31]:
['.index.rst.swo',

'.python\_language.rst.swp',
'.view\_array.py.swp',
'\_static',
'\_templates',
'basic\_types.rst',
'conf.py',
'control\_flow.rst',

2.7. Standard Library

35

Scipy lecture notes, Edition 2015.2

'debugging.rst',
...

Make a directory:

In [32]: os.mkdir('junkdir')

In [33]: 'junkdir' in os.listdir(os.curdir)
Out[33]: True

Rename the directory:

In [36]: os.rename('junkdir', 'foodir')

In [37]: 'junkdir' in os.listdir(os.curdir)
Out[37]: False

In [38]: 'foodir' in os.listdir(os.curdir)
Out[38]: True

In [41]: os.rmdir('foodir')

In [42]: 'foodir' in os.listdir(os.curdir)
Out[42]: False

Delete a ﬁle:

In [44]: fp = open('junk.txt', 'w')

In [45]: fp.close()

In [46]: 'junk.txt' in os.listdir(os.curdir)
Out[46]: True

In [47]: os.remove('junk.txt')

In [48]: 'junk.txt' in os.listdir(os.curdir)
Out[48]: False

os.path: path manipulations

os.path provides common operations on pathnames.

In [70]: fp = open('junk.txt', 'w')

In [71]: fp.close()

In [72]: a = os.path.abspath('junk.txt')

In [73]: a
Out[73]: '/Users/cburns/src/scipy2009/scipy\_2009\_tutorial/source/junk.txt'

In [74]: os.path.split(a)
Out[74]: ('/Users/cburns/src/scipy2009/scipy\_2009\_tutorial/source',

'junk.txt')

In [78]: os.path.dirname(a)
Out[78]: '/Users/cburns/src/scipy2009/scipy\_2009\_tutorial/source'

In [79]: os.path.basename(a)
Out[79]: 'junk.txt'

In [80]: os.path.splitext(os.path.basename(a))

2.7. Standard Library

36

Scipy lecture notes, Edition 2015.2

Out[80]: ('junk', '.txt')

In [84]: os.path.exists('junk.txt')
Out[84]: True

In [86]: os.path.isfile('junk.txt')
Out[86]: True

In [87]: os.path.isdir('junk.txt')
Out[87]: False

In [88]: os.path.expanduser('~/local')
Out[88]: '/Users/cburns/local'

In [92]: os.path.join(os.path.expanduser('~'), 'local', 'bin')
Out[92]: '/Users/cburns/local/bin'

Running an external command

In [8]: os.system('ls')
basic\_types.rst
control\_flow.rst
demo2.py

demo.py
exceptions.rst
first\_steps.rst

functions.rst
io.rst
oop.rst

python\_language.rst
python-logo.png
reusing\_code.rst

standard\_library.rst

Alternative to os.system
A noteworthy alternative to os.system is the sh module. Which provides much more convenient ways to
obtain the output, error stream and exit code of the external command.

In [20]: import sh
In [20]: com = sh.ls()

In [21]: print com
basic\_types.rst
control\_flow.rst
demo2.py
demo.py

exceptions.rst
first\_steps.rst
functions.rst
io.rst

oop.rst
python\_language.rst
python-logo.png
reusing\_code.rst

standard\_library.rst

In [22]: print com.exit\_code
0
In [23]: type(com)
Out[23]: sh.RunningCommand

Walking a directory

os.path.walk generates a list of ﬁlenames in a directory tree.

In [10]: for dirpath, dirnames, filenames in os.walk(os.curdir):

for fp in filenames:

print os.path.abspath(fp)

....:
....:
....:
....:

/Users/cburns/src/scipy2009/scipy\_2009\_tutorial/source/.index.rst.swo
/Users/cburns/src/scipy2009/scipy\_2009\_tutorial/source/.view\_array.py.swp
/Users/cburns/src/scipy2009/scipy\_2009\_tutorial/source/basic\_types.rst
/Users/cburns/src/scipy2009/scipy\_2009\_tutorial/source/conf.py
/Users/cburns/src/scipy2009/scipy\_2009\_tutorial/source/control\_flow.rst
...

2.7. Standard Library

37

Scipy lecture notes, Edition 2015.2

Environment variables:

In [9]: import os

In [11]: os.environ.keys()
Out[11]:
['\_',

'FSLDIR',
'TERM\_PROGRAM\_VERSION',
'FSLREMOTECALL',
'USER',
'HOME',
'PATH',
'PS1',
'SHELL',
'EDITOR',
'WORKON\_HOME',
'PYTHONPATH',
...

In [12]: os.environ['PYTHONPATH']
Out[12]: '.:/Users/cburns/src/utils:/Users/cburns/src/nitools:
/Users/cburns/local/lib/python2.5/site-packages/:
/usr/local/lib/python2.5/site-packages/:
/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5'

In [16]: os.getenv('PYTHONPATH')
Out[16]: '.:/Users/cburns/src/utils:/Users/cburns/src/nitools:
/Users/cburns/local/lib/python2.5/site-packages/:
/usr/local/lib/python2.5/site-packages/:
/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5'

2.7.2 shutil: high-level file operations

The shutil provides useful ﬁle operations:

• shutil.rmtree: Recursively delete a directory tree.
• shutil.move: Recursively move a ﬁle or directory to another location.
• shutil.copy: Copy ﬁles or directories.

2.7.3 glob: Pattern matching on files

The glob module provides convenient ﬁle pattern matching.
Find all ﬁles ending in .txt:

In [18]: import glob

In [19]: glob.glob('\*.txt')
Out[19]: ['holy\_grail.txt', 'junk.txt', 'newfile.txt']

2.7.4 sys module: system-specific information

System-speciﬁc information related to the Python interpreter.

• Which version of python are you running and where is it installed:

2.7. Standard Library

38

Scipy lecture notes, Edition 2015.2

In [117]: sys.platform
Out[117]: 'darwin'

In [118]: sys.version
Out[118]: '2.5.2 (r252:60911, Feb 22 2008, 07:57:53) \n
[GCC 4.0.1 (Apple Computer, Inc. build 5363)]'

In [119]: sys.prefix
Out[119]: '/Library/Frameworks/Python.framework/Versions/2.5'

• List of command line arguments passed to a Python script:

In [100]: sys.argv
Out[100]: ['/Users/cburns/local/bin/ipython']

sys.path is a list of strings that speciﬁes the search path for modules. Initialized from PYTHONPATH:

In [121]: sys.path
Out[121]:
['',

'/Users/cburns/local/bin',
'/Users/cburns/local/lib/python2.5/site-packages/grin-1.1-py2.5.egg',
'/Users/cburns/local/lib/python2.5/site-packages/argparse-0.8.0-py2.5.egg',
'/Users/cburns/local/lib/python2.5/site-packages/urwid-0.9.7.1-py2.5.egg',
'/Users/cburns/local/lib/python2.5/site-packages/yolk-0.4.1-py2.5.egg',
'/Users/cburns/local/lib/python2.5/site-packages/virtualenv-1.2-py2.5.egg',
...

2.7.5 pickle: easy persistence

Useful to store arbitrary objects to a ﬁle. Not safe or fast!

In [1]: import pickle

In [2]: l = [1, None, 'Stan']

In [3]: pickle.dump(l, file('test.pkl', 'w'))

In [4]: pickle.load(file('test.pkl'))
Out[4]: [1, None, 'Stan']

Exercise
Write a program to search your PYTHONPATH for the module site.py.

path\_site

2.8 Exception handling in Python

It is likely that you have raised Exceptions if you have typed all the previous commands of the tutorial. For
example, you may have raised an exception if you entered a command with a typo.

Exceptions are raised by different kinds of errors arising when executing Python code. In your own code, you
may also catch errors, or deﬁne custom error types. You may want to look at the descriptions of the the built-in
Exceptions when looking for the right exception type.

2.8. Exception handling in Python

39

Scipy lecture notes, Edition 2015.2

2.8.1 Exceptions

Exceptions are raised by errors in Python:

In [1]: 1/0
---------------------------------------------------------------------------
ZeroDivisionError: integer division or modulo by zero

In [2]: 1 + 'e'
---------------------------------------------------------------------------
TypeError: unsupported operand type(s) for +: 'int' and 'str'

In [3]: d = {1:1, 2:2}

In [4]: d[3]
---------------------------------------------------------------------------
KeyError: 3

In [5]: l = [1, 2, 3]

In [6]: l[4]
---------------------------------------------------------------------------
IndexError: list index out of range

In [7]: l.foobar
---------------------------------------------------------------------------
AttributeError: 'list' object has no attribute 'foobar'

As you can see, there are different types of exceptions for different errors.

2.8.2 Catching exceptions

try/except

In [10]: while True:

....:
....:
....:
....:
....:
....:

try:

x = int(raw\_input('Please enter a number: '))
break

except ValueError:

print('That was no valid number.

Try again...')

Please enter a number: a
That was no valid number.
Please enter a number: 1

Try again...

In [9]: x
Out[9]: 1

try/finally

In [10]: try:
....:
....: finally:
....:
....:
....:

x = int(raw\_input('Please enter a number: '))

print('Thank you for your input')

Please enter a number: a
Thank you for your input
---------------------------------------------------------------------------
ValueError: invalid literal for int() with base 10: 'a'

2.8. Exception handling in Python

40

Scipy lecture notes, Edition 2015.2

Important for resource management (e.g. closing a ﬁle)

Easier to ask for forgiveness than for permission

In [11]: def print\_sorted(collection):

try:

collection.sort()
except AttributeError:

pass

print(collection)

....:
....:
....:
....:
....:
....:
....:

In [12]: print\_sorted([1, 3, 2])
[1, 2, 3]

In [13]: print\_sorted(set((1, 3, 2)))
set([1, 2, 3])

In [14]: print\_sorted('132')
132

2.8.3 Raising exceptions

• Capturing and reraising an exception:

In [15]: def filter\_name(name):

....:
....:
....:
....:
....:
....:
....:
....:
....:

try:

name = name.encode('ascii')

except UnicodeError, e:
if name == 'Gaël':

print('OK, Gaël')

else:

raise e

return name

In [16]: filter\_name('Gaël')
OK, Gaël
Out[16]: 'Ga\xc3\xabl'

In [17]: filter\_name('Stéfan')
---------------------------------------------------------------------------
UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position 2: ordinal not in range(128)

• Exceptions to pass messages between parts of the code:

In [17]: def achilles\_arrow(x):

....:
....:
....:
....:
....:

if abs(x - 1) < 1e-3:

raise StopIteration

x = 1 - (1-x)/2.
return x

In [18]: x = 0

In [19]: while True:

....:
....:
....:
....:

try:

x = achilles\_arrow(x)

except StopIteration:

break

2.8. Exception handling in Python

41

Scipy lecture notes, Edition 2015.2

....:
....:

In [20]: x
Out[20]: 0.9990234375

Use exceptions to notify certain conditions are met (e.g. StopIteration) or not (e.g. custom error raising)

2.9 Object-oriented programming (OOP)

Python supports object-oriented programming (OOP). The goals of OOP are:

• to organize the code, and

• to re-use code in similar contexts.

Here is a small example: we create a Student class, which is an object gathering several custom functions
(methods) and variables (attributes), we will be able to use:

def \_\_init\_\_(self, name):
self.name = name
def set\_age(self, age):
self.age = age

>>> class Student(object):
...
...
...
...
...
...
...
>>> anna = Student('anna')
>>> anna.set\_age(21)
>>> anna.set\_major('physics')

def set\_major(self, major):
self.major = major

In the previous example, the Student class has \_\_init\_\_, set\_age and set\_major methods.
Its at-
tributes are name, age and major. We can call these methods and attributes with the following notation:
classinstance.method or classinstance.attribute. The \_\_init\_\_ constructor is a special method we
call with: MyClass(init parameters if any).

Now, suppose we want to create a new class MasterStudent with the same methods and attributes as the pre-
vious one, but with an additional internship attribute. We won’t copy the previous class, but inherit from
it:

internship = 'mandatory, from March to June'

>>> class MasterStudent(Student):
...
...
>>> james = MasterStudent('james')
>>> james.internship
'mandatory, from March to June'
>>> james.set\_age(23)
>>> james.age
23

The MasterStudent class inherited from the Student attributes and methods.

Thanks to classes and object-oriented programming, we can organize code with different classes correspond-
ing to different objects we encounter (an Experiment class, an Image class, a Flow class, etc.), with their own
methods and attributes. Then we can use inheritance to consider variations around a base class and re-use
code. Ex : from a Flow base class, we can create derived StokesFlow, TurbulentFlow, PotentialFlow, etc.

2.9. Object-oriented programming (OOP)

42

CHAPTER 3

NumPy: creating and manipulating numerical data

Authors: Emmanuelle Gouillart, Didrik Pinte, Gaël Varoquaux, and Pauli Virtanen

This chapter gives an overview of Numpy, the core tool for performant numerical computing with Python.

3.1 The Numpy array object

Section contents

• What are Numpy and Numpy arrays?
• Creating arrays
• Basic data types
• Basic visualization
• Indexing and slicing
• Copies and views
• Fancy indexing

3.1.1 What are Numpy and Numpy arrays?

Numpy arrays

Python objects

• high-level number objects: integers, ﬂoating point

• containers: lists (costless insertion and append), dictionaries (fast lookup)

Numpy provides

• extension package to Python for multi-dimensional arrays

• closer to hardware (efﬁciency)

• designed for scientiﬁc computation (convenience)

• Also known as array oriented computing

43

Scipy lecture notes, Edition 2015.2

>>> import numpy as np
>>> a = np.array([0, 1, 2, 3])
>>> a
array([0, 1, 2, 3])

For example, An array containing:

• values of an experiment/simulation at discrete time steps
• signal recorded by a measurement device, e.g. sound wave
• pixels of an image, grey-level or colour
• 3-D data measured at different X-Y-Z positions, e.g. MRI scan
• ...

Why it is useful: Memory-efﬁcient container that provides fast numerical operations.

In [1]: L = range(1000)

In [2]: %timeit [i\*\*2 for i in L]
1000 loops, best of 3: 403 us per loop

In [3]: a = np.arange(1000)

In [4]: %timeit a\*\*2
100000 loops, best of 3: 12.7 us per loop

Numpy Reference documentation

• On the web: http://docs.scipy.org/

• Interactive help:

In [5]: np.array?
String Form:
Docstring:
array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0, ...

• Looking for something:

>>> np.lookfor('create array')
Search results for 'create array'
---------------------------------
numpy.array

Create an array.

numpy.memmap

Create a memory-map to an array stored in a \*binary\* file on disk.

In [6]: np.con\*?
np.concatenate
np.conj
np.conjugate
np.convolve

Import conventions

The recommended convention to import numpy is:

>>> import numpy as np

3.1. The Numpy array object

44

Scipy lecture notes, Edition 2015.2

3.1.2 Creating arrays

Manual construction of arrays

• 1-D:

>>> a = np.array([0, 1, 2, 3])
>>> a
array([0, 1, 2, 3])
>>> a.ndim
1
>>> a.shape
(4,)
>>> len(a)
4

• 2-D, 3-D, ...:

>>> b = np.array([[0, 1, 2], [3, 4, 5]])
>>> b
array([[0, 1, 2],

[3, 4, 5]])

# 2 x 3 array

>>> b.ndim
2
>>> b.shape
(2, 3)
>>> len(b)
2

# returns the size of the first dimension

>>> c = np.array([[[1], [2]], [[3], [4]]])
>>> c
array([[[1],

[2]],

[[3],

[4]]])

>>> c.shape
(2, 2, 1)

Exercise: Simple arrays

• Create a simple two dimensional array. First, redo the examples from above. And then create your
own: how about odd numbers counting backwards on the ﬁrst row, and even numbers on the
second?

• Use the functions len(), numpy.shape() on these arrays. How do they relate to each other? And

to the ndim attribute of the arrays?

Functions for creating arrays

In practice, we rarely enter items one by one...

• Evenly spaced:

(!)

>>> a = np.arange(10) # 0 .. n-1
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> b = np.arange(1, 9, 2) # start, end (exclusive), step
>>> b
array([1, 3, 5, 7])

3.1. The Numpy array object

45

• or by number of points:

Scipy lecture notes, Edition 2015.2

# start, end, num-points

>>> c = np.linspace(0, 1, 6)
>>> c
array([ 0. ,
0.4,
1. ])
>>> d = np.linspace(0, 1, 5, endpoint=False)
>>> d
array([ 0. ,

0.8])

0.8,

0.6,

0.4,

0.2,

0.6,

0.2,

• Common arrays:

>>> a = np.ones((3, 3)) # reminder: (3, 3) is a tuple
>>> a
array([[ 1.,
[ 1.,
[ 1.,

1.,
1.,
1.,

1.],
1.],
1.]])
>>> b = np.zeros((2, 2))
>>> b
array([[ 0.,
[ 0.,
>>> c = np.eye(3)
>>> c
array([[ 1.,
[ 0.,
[ 0.,

0.],
0.],
1.]])

0.],
0.]])

0.,
1.,
0.,

>>> d = np.diag(np.array([1, 2, 3, 4]))
>>> d
array([[1, 0, 0, 0],
[0, 2, 0, 0],
[0, 0, 3, 0],
[0, 0, 0, 4]])

• np.random: random numbers (Mersenne Twister PRNG):

>>> a = np.random.rand(4)
>>> a
array([ 0.95799151,

# uniform in [0, 1]

0.14222247,

0.08777354,

0.51887998])

>>> b = np.random.randn(4)
>>> b
array([ 0.37544699, -0.11425369, -0.47616538,

# Gaussian

1.79664113])

>>> np.random.seed(1234)

# Setting the random seed

Exercise: Creating arrays using functions

• Experiment with arange, linspace, ones, zeros, eye and diag.
• Create different kinds of arrays with random numbers.
• Try setting the seed before creating an array with random values.
• Look at the function np.empty. What does it do? When might this be useful?

3.1.3 Basic data types

You may have noticed that, in some instances, array elements are displayed with a trailing dot (e.g. 2. vs 2).
This is due to a difference in the data-type used:

>>> a = np.array([1, 2, 3])
>>> a.dtype
dtype('int64')

>>> b = np.array([1., 2., 3.])

3.1. The Numpy array object

46

Scipy lecture notes, Edition 2015.2

>>> b.dtype
dtype('float64')

Different data-types allow us to store data more compactly in memory, but most of the time we simply work
with ﬂoating point numbers. Note that, in the example above, NumPy auto-detects the data-type from the
input.

You can explicitly specify which data-type you want:

>>> c = np.array([1, 2, 3], dtype=float)
>>> c.dtype
dtype('float64')

The default data type is ﬂoating point:

>>> a = np.ones((3, 3))
>>> a.dtype
dtype('float64')

There are also other types:

Complex

>>> d = np.array([1+2j, 3+4j, 5+6\*1j])
>>> d.dtype
dtype('complex128')

Bool

>>> e = np.array([True, False, False, True])
>>> e.dtype
dtype('bool')

Strings

>>> f = np.array(['Bonjour', 'Hello', 'Hallo',])
>>> f.dtype
dtype('S7')

# <--- strings containing max. 7 letters

Much more

• int32
• int64
• uint32
• uint64

3.1.4 Basic visualization

Now that we have our ﬁrst data arrays, we are going to visualize them.

Start by launching IPython:

$ ipython

Or the notebook:

$ ipython notebook

Once IPython has started, enable interactive plots:

3.1. The Numpy array object

47

Scipy lecture notes, Edition 2015.2

>>> %matplotlib

Or, from the notebook, enable plots in the notebook:

>>> %matplotlib inline

The inline is important for the notebook, so that plots are displayed in the notebook and not in a new window.

Matplotlib is a 2D plotting package. We can import its functions as below:

>>> import matplotlib.pyplot as plt # the tidy way

And then use (note that you have to use show explicitly if you have not enabled interactive plots with
%matplotlib):

>>> plt.plot(x, y)
>>> plt.show()

# line plot
# <-- shows the plot (not needed with interactive plots)

Or, if you have enabled interactive plots with %matplotlib:

>>> plot(x, y)

# line plot

• 1D plotting:

>>> x = np.linspace(0, 3, 20)
>>> y = np.linspace(0, 9, 20)
>>> plt.plot(x, y)
[]
>>> plt.plot(x, y, 'o') # dot plot
[]

# line plot

• 2D arrays (such as images):

3.1. The Numpy array object

48

0.00.51.01.52.02.53.00123456789Scipy lecture notes, Edition 2015.2

>>> image = np.random.rand(30, 30)
>>> plt.imshow(image, cmap=plt.cm.hot)
>>> plt.colorbar()


See also:

More in the: matplotlib chapter

Exercise: Simple visualizations

• Plot some simple arrays: a cosine as a function of time and a 2D matrix.
• Try using the gray colormap on the 2D matrix.

3.1.5 Indexing and slicing

The items of an array can be accessed and assigned to the same way as other Python sequences (e.g. lists):

>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> a[0], a[2], a[-1]
(0, 2, 9)

(cid:66)

Indices begin at 0, like other Python sequences (and C/C++). In contrast, in Fortran or Matlab, indices begin
at 1.

The usual python idiom for reversing a sequence is supported:

3.1. The Numpy array object

49

051015202505101520250.00.10.20.30.40.50.60.70.80.9Scipy lecture notes, Edition 2015.2

>>> a[::-1]
array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])

For multidimensional arrays, indexes are tuples of integers:

>>> a = np.diag(np.arange(3))
>>> a
array([[0, 0, 0],
[0, 1, 0],
[0, 0, 2]])

>>> a[1, 1]
1
>>> a[2, 1] = 10 # third line, second column
>>> a
0,
array([[ 0,
[ 0,
1,
[ 0, 10,

0],
0],
2]])

>>> a[1]
array([0, 1, 0])

• In 2D, the ﬁrst dimension corresponds to rows, the second to columns.
• for multidimensional a, a[0] is interpreted by taking all elements in the unspeciﬁed dimensions.

Slicing: Arrays, like other Python sequences can also be sliced:

>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> a[2:9:3] # [start:end:step]
array([2, 5, 8])

Note that the last index is not included! :

>>> a[:4]
array([0, 1, 2, 3])

All three slice components are not required: by default, start is 0, end is the last and step is 1:

>>> a[1:3]
array([1, 2])
>>> a[::2]
array([0, 2, 4, 6, 8])
>>> a[3:]
array([3, 4, 5, 6, 7, 8, 9])

A small illustrated summary of Numpy indexing and slicing...

3.1. The Numpy array object

50

Scipy lecture notes, Edition 2015.2

You can also combine assignment and slicing:

>>> a = np.arange(10)
>>> a[5:] = 10
>>> a
array([ 0,
>>> b = np.arange(5)
>>> a[5:] = b[::-1]
>>> a
array([0, 1, 2, 3, 4, 4, 3, 2, 1, 0])

1,

2,

3,

4, 10, 10, 10, 10, 10])

Exercise: Indexing and slicing

• Try the different ﬂavours of slicing, using start, end and step: starting from a linspace, try to

obtain odd numbers counting backwards, and even numbers counting forwards.

• Reproduce the slices in the diagram above. You may use the following expression to create the

array:

>>> np.arange(6) + np.arange(0, 51, 10)[:, np.newaxis]
4,
array([[ 0,

2,

3,

1,

5],
[10, 11, 12, 13, 14, 15],
[20, 21, 22, 23, 24, 25],
[30, 31, 32, 33, 34, 35],
[40, 41, 42, 43, 44, 45],
[50, 51, 52, 53, 54, 55]])

3.1. The Numpy array object

51

Scipy lecture notes, Edition 2015.2

Exercise: Array creation

Create the following arrays (with correct data types):

[[1, 1, 1, 1],
[1, 1, 1, 1],
[1, 1, 1, 2],
[1, 6, 1, 1]]

[[0., 0., 0., 0., 0.],
[2., 0., 0., 0., 0.],
[0., 3., 0., 0., 0.],
[0., 0., 4., 0., 0.],
[0., 0., 0., 5., 0.],
[0., 0., 0., 0., 6.]]

Par on course: 3 statements for each
Hint: Individual array elements can be accessed similarly to a list, e.g. a[1] or a[1, 2].
Hint: Examine the docstring for diag.

Exercise: Tiling for array creation
Skim through the documentation for np.tile, and use this function to construct the array:

[[4, 3, 4, 3, 4, 3],
[2, 1, 2, 1, 2, 1],
[4, 3, 4, 3, 4, 3],
[2, 1, 2, 1, 2, 1]]

3.1.6 Copies and views

A slicing operation creates a view on the original array, which is just a way of accessing array data. Thus the
original array is not copied in memory. You can use np.may\_share\_memory() to check if two arrays share the
same memory block. Note however, that this uses heuristics and may give you false positives.

When modifying the view, the original array is modiﬁed as well:

>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> b = a[::2]
>>> b
array([0, 2, 4, 6, 8])
>>> np.may\_share\_memory(a, b)
True
>>> b[0] = 12
>>> b
array([12,
>>> a
array([12,

# (!)

8])

6,

1,

5,

4,

4,

2,

3,

6,

2,

7, 8,

9])

>>> a = np.arange(10)
>>> c = a[::2].copy()
>>> c[0] = 12
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

# force a copy

>>> np.may\_share\_memory(a, c)
False

3.1. The Numpy array object

52

Scipy lecture notes, Edition 2015.2

This behavior can be surprising at ﬁrst sight... but it allows to save both memory and time.

Worked example: Prime number sieve

Compute prime numbers in 0–99, with a sieve

• Construct a shape (100,) boolean array is\_prime, ﬁlled with True in the beginning:

>>> is\_prime = np.ones((100,), dtype=bool)

• Cross out 0 and 1 which are not primes:

>>> is\_prime[:2] = 0

• For each integer j starting from 2, cross out its higher multiples:

>>> N\_max = int(np.sqrt(len(is\_prime)))
>>> for j in range(2, N\_max):
...

is\_prime[2\*j::j] = False

• Skim through help(np.nonzero), and print the prime numbers
• Follow-up:

– Move the above code into a script ﬁle named prime\_sieve.py
– Run it to check it works
– Use the optimization suggested in the sieve of Eratosthenes:
1. Skip j which are already known to not be primes
2. The ﬁrst number to cross out is j 2

3.1.7 Fancy indexing

Numpy arrays can be indexed with slices, but also with boolean or integer arrays (masks). This method is
called fancy indexing. It creates copies not views.

Using boolean masks

>>> np.random.seed(3)
>>> a = np.random.random\_integers(0, 20, 15)
>>> a
array([10,
>>> (a % 3 == 0)
array([False,
True,

True, False,
True, False,

0, 19, 10, 11,

9, 10,

3,

8,

6,

0, 20, 12,

7, 14])

True, False, False, False,
True, False, False], dtype=bool)

True, False,

3.1. The Numpy array object

53

Scipy lecture notes, Edition 2015.2

a[a%3==0]

# extract a sub-array with the mask

>>> mask = (a % 3 == 0)
>>> extract\_from\_a = a[mask] # or,
>>> extract\_from\_a
9,
array([ 3,

0, 12])

0,

6,

Indexing with a mask can be very useful to assign a new value to a sub-array:

>>> a[a % 3 == 0] = -1
>>> a
array([10, -1,

8, -1, 19, 10, 11, -1, 10, -1, -1, 20, -1,

7, 14])

Indexing with an array of integers

>>> a = np.arange(0, 100, 10)
>>> a
array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])

Indexing can be done with an array of integers, where the same index is repeated several time:

>>> a[[2, 3, 2, 4, 2]] # note: [2, 3, 2, 4, 2] is a Python list
array([20, 30, 20, 40, 20])

New values can be assigned with this kind of indexing:

>>> a[[9, 7]] = -100
>>> a
array([

10,

0,

20,

30,

40,

50,

60, -100,

80, -100])

When a new array is created by indexing with an array of integers, the new array has the same shape than the
array of integers:

>>> a = np.arange(10)
>>> idx = np.array([[3, 4], [9, 7]])
>>> idx.shape
(2, 2)
>>> a[idx]
array([[3, 4],

[9, 7]])

The image below illustrates various fancy indexing applications

3.1. The Numpy array object

54

Scipy lecture notes, Edition 2015.2

Exercise: Fancy indexing

• Again, reproduce the fancy indexing shown in the diagram above.
• Use fancy indexing on the left and array creation on the right to assign values into an array, for

instance by setting parts of the array in the diagram above to zero.

3.2 Numerical operations on arrays

Section contents

• Elementwise operations
• Basic reductions
• Broadcasting
• Array shape manipulation
• Sorting data
• Summary

3.2.1 Elementwise operations

Basic operations

With scalars:

>>> a = np.array([1, 2, 3, 4])
>>> a + 1
array([2, 3, 4, 5])
>>> 2\*\*a
array([ 2,

8, 16])

4,

All arithmetic operates elementwise:

>>> b = np.ones(4) + 1
>>> a - b
array([-1.,
>>> a \* b
array([ 2.,

4.,

0.,

1.,

6.,

2.])

8.])

>>> j = np.arange(5)
>>> 2\*\*(j + 1) - j
array([ 2,

3,

6, 13, 28])

These operations are of course much faster than if you did them in pure python:

>>> a = np.arange(10000)
>>> %timeit a + 1
10000 loops, best of 3: 24.3 us per loop
>>> l = range(10000)
>>> %timeit [i+1 for i in l]
1000 loops, best of 3: 861 us per loop

3.2. Numerical operations on arrays

55

(cid:66)

Array multiplication is not matrix multiplication:

Scipy lecture notes, Edition 2015.2

>>> c = np.ones((3, 3))
>>> c \* c
array([[ 1., 1.,
1.,
1.,

1.],
1.],
1.]])

[ 1.,
[ 1.,

# NOT matrix multiplication!

Matrix multiplication:

>>> c.dot(c)
array([[ 3., 3.,
3.,
3.,

[ 3.,
[ 3.,

3.],
3.],
3.]])

Exercise: Elementwise operations

• Try simple arithmetic elementwise operations: add even elements with odd elements
• Time them against their pure python counterparts using %timeit.
• Generate:

– [2\*\*0, 2\*\*1, 2\*\*2, 2\*\*3, 2\*\*4]
– a\_j = 2^(3\*j) - j

Other operations

Comparisons:

>>> a = np.array([1, 2, 3, 4])
>>> b = np.array([4, 2, 2, 4])
>>> a == b
array([False,
>>> a > b
array([False, False,

True, False,

True], dtype=bool)

True, False], dtype=bool)

Array-wise comparisons:

>>> a = np.array([1, 2, 3, 4])
>>> b = np.array([4, 2, 2, 4])
>>> c = np.array([1, 2, 3, 4])
>>> np.array\_equal(a, b)
False
>>> np.array\_equal(a, c)
True

Logical operations:

>>> a = np.array([1, 1, 0, 0], dtype=bool)
>>> b = np.array([1, 0, 1, 0], dtype=bool)
>>> np.logical\_or(a, b)
array([ True,
>>> np.logical\_and(a, b)
array([ True, False, False, False], dtype=bool)

True, False], dtype=bool)

True,

Transcendental functions:

>>> a = np.arange(5)
>>> np.sin(a)
array([ 0.
>>> np.log(a)
array([
>>> np.exp(a)
array([

-inf,

1.

,

,

0.84147098,

0.90929743,

0.14112001, -0.7568025 ])

0.

,

0.69314718,

1.09861229,

1.38629436])

2.71828183,

7.3890561 ,

20.08553692,

54.59815003])

3.2. Numerical operations on arrays

56

Scipy lecture notes, Edition 2015.2

Shape mismatches

>>> a = np.arange(4)
>>> a + np.array([1, 2])
Traceback (most recent call last):

File "", line 1, in 

ValueError: operands could not be broadcast together with shapes (4) (2)
Traceback (most recent call last):

File "", line 1, in 

ValueError: operands could not be broadcast together with shapes (4) (2)

Broadcasting? We’ll return to that later.

Transposition:

>>> a = np.triu(np.ones((3, 3)), 1)
>>> a
array([[ 0., 1.,
0.,
0.,

1.],
1.],
0.]])

[ 0.,
[ 0.,

# see help(np.triu)

>>> a.T
array([[ 0., 0.,
0.,
1.,

[ 1.,
[ 1.,

0.],
0.],
0.]])

(cid:66)

The transposition is a view
As a results, the following code is wrong and will not make a matrix symmetric:

>>> a += a.T

Linear algebra
The sub-module numpy.linalg implements basic linear algebra, such as solving linear systems, singular
value decomposition, etc. However, it is not guaranteed to be compiled using efﬁcient routines, and thus
we recommend the use of scipy.linalg, as detailed in section Linear algebra operations: scipy.linalg

Exercise other operations

• Look at the help for np.allclose. When might this be useful?
• Look at the help for np.triu and np.tril.

3.2.2 Basic reductions

Computing sums

>>> x = np.array([1, 2, 3, 4])
>>> np.sum(x)
10
>>> x.sum()
10

3.2. Numerical operations on arrays

57

Scipy lecture notes, Edition 2015.2

Sum by rows and by columns:

>>> x = np.array([[1, 1], [2, 2]])
>>> x
array([[1, 1],

[2, 2]])

# columns (first dimension)

>>> x.sum(axis=0)
array([3, 3])
>>> x[:, 0].sum(), x[:, 1].sum()
(3, 3)
>>> x.sum(axis=1)
array([2, 4])
>>> x[0, :].sum(), x[1, :].sum()
(2, 4)

# rows (second dimension)

Same idea in higher dimensions:

>>> x = np.random.rand(2, 2, 2)
>>> x.sum(axis=2)[0, 1]
1.14764...
>>> x[0, 1, :].sum()
1.14764...

Other reductions

— works the same way (and take axis=)

Extrema:

>>> x = np.array([1, 3, 2])
>>> x.min()
1
>>> x.max()
3

>>> x.argmin() # index of minimum
0
>>> x.argmax() # index of maximum
1

Logical operations:

>>> np.all([True, True, False])
False
>>> np.any([True, True, False])
True

3.2. Numerical operations on arrays

58

Scipy lecture notes, Edition 2015.2

Can be used for array comparisons:

>>> a = np.zeros((100, 100))
>>> np.any(a != 0)
False
>>> np.all(a == a)
True

>>> a = np.array([1, 2, 3, 2])
>>> b = np.array([2, 2, 3, 2])
>>> c = np.array([6, 4, 4, 5])
>>> ((a <= b) & (b <= c)).all()
True

Statistics:

>>> x = np.array([1, 2, 3, 1])
>>> y = np.array([[1, 2, 3], [5, 6, 1]])
>>> x.mean()
1.75
>>> np.median(x)
1.5
>>> np.median(y, axis=-1) # last axis
array([ 2.,

5.])

>>> x.std()
0.82915619758884995

# full population standard dev.

... and many more (best to learn as you go).

Exercise: Reductions

• Given there is a sum, what other function might you expect to see?
• What is the difference between sum and cumsum?

3.2. Numerical operations on arrays

59

Scipy lecture notes, Edition 2015.2

Worked Example: data statistics
Data in populations.txt describes the populations of hares and lynxes (and carrots) in northern
Canada during 20 years.
You can view the data in an editor, or alternatively in IPython (both shell and notebook):

In [1]: !cat data/populations.txt

First, load the data into a Numpy array:

>>> data = np.loadtxt('data/populations.txt')
>>> year, hares, lynxes, carrots = data.T # trick: columns to variables

Then plot it:

>>> from matplotlib import pyplot as plt
>>> plt.axes([0.2, 0.1, 0.5, 0.8])
>>> plt.plot(year, hares, year, lynxes, year, carrots)
>>> plt.legend(('Hare', 'Lynx', 'Carrot'), loc=(1.05, 0.5))

The mean populations over time:

>>> populations = data[:, 1:]
>>> populations.mean(axis=0)
array([ 34080.95238095,

20166.66666667,

The sample standard deviations:

42400.

])

>>> populations.std(axis=0)
array([ 20897.90645809,

16254.59153691,

3322.50622558])

Which species has the highest population each year?:

>>> np.argmax(populations, axis=1)
array([2, 2, 0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 2, 2, 2, 2, 2])

3.2. Numerical operations on arrays

60

1900190519101915192001000020000300004000050000600007000080000HareLynxCarrotScipy lecture notes, Edition 2015.2

Worked Example: diffusion using a random walk algorithm

Let us consider a simple 1D random walk process: at each time step a walker jumps right or left with
equal probability.
We are interested in ﬁnding the typical distance from the origin of a random walker after t left or right
jumps? We are going to simulate many “walkers” to ﬁnd this law, and we are going to do so using array
computing tricks: we are going to create a 2D array with the “stories” (each walker has a story) in one
direction, and the time in the other:

>>> n\_stories = 1000 # number of walkers
>>> t\_max = 200

# time during which we follow the walker

We randomly choose all the steps 1 or -1 of the walk:

>>> t = np.arange(t\_max)
>>> steps = 2 \* np.random.random\_integers(0, 1, (n\_stories, t\_max)) - 1
>>> np.unique(steps) # Verification: all steps are 1 or -1
array([-1, 1])

We build the walks by summing steps along the time:

>>> positions = np.cumsum(steps, axis=1) # axis = 1: dimension of time
>>> sq\_distance = positions\*\*2

We get the mean in the axis of the stories:

>>> mean\_sq\_distance = np.mean(sq\_distance, axis=0)

Plot the results:

>>> plt.figure(figsize=(4, 3))

>>> plt.plot(t, np.sqrt(mean\_sq\_distance), 'g.', t, np.sqrt(t), 'y-')
[, ]
>>> plt.xlabel(r"$t$")

>>> plt.ylabel(r"$\sqrt{\langle (\delta x)^2 \rangle}$")


3.2. Numerical operations on arrays

61

We ﬁnd a well-known result in physics: the RMS distance grows as the square root of the time!

050100150200t0246810121416q›(δx)2ﬁScipy lecture notes, Edition 2015.2

3.2.3 Broadcasting

• Basic operations on numpy arrays (addition, etc.) are elementwise

• This works on arrays of the same size.

Nevertheless, It’s also possible to do operations on arrays of different
sizes if Numpy can transform these arrays so that they all have
the same size: this conversion is called broadcasting.

The image below gives an example of broadcasting:

Let’s verify:

>>> a = np.tile(np.arange(0, 40, 10), (3, 1)).T
>>> a
array([[ 0,

0],
0,
[10, 10, 10],
[20, 20, 20],
[30, 30, 30]])
>>> b = np.array([0, 1, 2])
>>> a + b
array([[ 0,

1,
2],
[10, 11, 12],
[20, 21, 22],
[30, 31, 32]])

We have already used broadcasting without knowing it!:

>>> a = np.ones((4, 5))
>>> a[0] = 2
>>> a
array([[ 2., 2.,
1.,

2.,
1.,

[ 1.,

2.,
1.,

2.],
1.],

# we assign an array of dimension 0 to an array of dimension 1

3.2. Numerical operations on arrays

62

Scipy lecture notes, Edition 2015.2

[ 1.,
[ 1.,

1.,
1.,

1.,
1.,

1.,
1.,

1.],
1.]])

An useful trick:

# adds a new axis -> 2D array

>>> a = np.arange(0, 40, 10)
>>> a.shape
(4,)
>>> a = a[:, np.newaxis]
>>> a.shape
(4, 1)
>>> a
array([[ 0],
[10],
[20],
[30]])

>>> a + b
array([[ 0,

1,
2],
[10, 11, 12],
[20, 21, 22],
[30, 31, 32]])

Broadcasting seems a bit magical, but it is actually quite natural to use it when we want to solve a problem
whose output data is an array with more dimensions than input data.

Worked Example: Broadcasting

Let’s construct an array of distances (in miles) between cities of Route 66: Chicago, Springﬁeld, Saint-
Louis, Tulsa, Oklahoma City, Amarillo, Santa Fe, Albuquerque, Flagstaff and Los Angeles.

1913, 2448])

>>> mileposts = np.array([0, 198, 303, 736, 871, 1175, 1475, 1544,
...
>>> distance\_array = np.abs(mileposts - mileposts[:, np.newaxis])
>>> distance\_array
198,
array([[
0,
105,
538,
673,
977,

871, 1175, 1475, 1544, 1913, 2448],
303,
0,
977, 1277, 1346, 1715, 2250],
673,
105,
[ 198,
872, 1172, 1241, 1610, 2145],
568,
0,
[ 303,
808, 1177, 1712],
439,
135,
433,
[ 736,
673, 1042, 1577],
304,
0,
568,
[ 871,
738, 1273],
369,
0,
304,
[1175,
872,
973],
438,
69,
300,
604,
[1475, 1277, 1172,
904],
369,
0,
[1544, 1346, 1241,
369,
673,
535],
0,
369,
[1913, 1715, 1610, 1177, 1042, 738,
535,
904,
[2448, 2250, 2145, 1712, 1577, 1273,

736,
538,
433,
0,
135,
439,
739,
808,

739,
604,
300,
0,
69,
438,
973,

0]])

A lot of grid-based or network-based problems can also use broadcasting. For instance, if we want to compute
the distance from the origin of points on a 10x10 grid, we can do

3.2. Numerical operations on arrays

63

>>> x, y = np.arange(5), np.arange(5)[:, np.newaxis]
>>> distance = np.sqrt(x \*\* 2 + y \*\* 2)
>>> distance
array([[ 0.
[ 1.
[ 2.
[ 3.
[ 4.

2.
,
2.23606798,
2.82842712,
3.60555128,
4.47213595,

1.
,
1.41421356,
2.23606798,
3.16227766,
4.12310563,

,
,
,
,
,

3.
,
3.16227766,
3.60555128,
4.24264069,
,
5.

Scipy lecture notes, Edition 2015.2

4.
],
4.12310563],
4.47213595],
5.
],
5.65685425]])

Or in color:

>>> plt.pcolor(distance)
>>> plt.colorbar()

Remark : the numpy.ogrid function allows to directly create vectors x and y of the previous example, with two
“signiﬁcant dimensions”:

>>> x, y = np.ogrid[0:5, 0:5]
>>> x, y
(array([[0],

[1],
[2],
[3],
[4]]), array([[0, 1, 2, 3, 4]]))

>>> x.shape, y.shape
((5, 1), (1, 5))
>>> distance = np.sqrt(x \*\* 2 + y \*\* 2)

3.2. Numerical operations on arrays

64

0123450123450.00.61.21.82.43.03.64.24.85.4So, np.ogrid is very useful as soon as we have to handle computations on a grid. On the other hand, np.mgrid
directly provides matrices full of indices for cases where we can’t (or don’t want to) beneﬁt from broadcasting:

Scipy lecture notes, Edition 2015.2

>>> x, y = np.mgrid[0:4, 0:4]
>>> x
array([[0, 0, 0, 0],
[1, 1, 1, 1],
[2, 2, 2, 2],
[3, 3, 3, 3]])

>>> y
array([[0, 1, 2, 3],
[0, 1, 2, 3],
[0, 1, 2, 3],
[0, 1, 2, 3]])

3.2.4 Array shape manipulation

Flattening

>>> a = np.array([[1, 2, 3], [4, 5, 6]])
>>> a.ravel()
array([1, 2, 3, 4, 5, 6])
>>> a.T
array([[1, 4],
[2, 5],
[3, 6]])
>>> a.T.ravel()
array([1, 4, 2, 5, 3, 6])

Higher dimensions: last dimensions ravel out “ﬁrst”.

Reshaping

The inverse operation to ﬂattening:

>>> a.shape
(2, 3)
>>> b = a.ravel()
>>> b = b.reshape((2, 3))
>>> b
array([[1, 2, 3],

[4, 5, 6]])

Or,

>>> a.reshape((2, -1))
array([[1, 2, 3],

[4, 5, 6]])

# unspecified (-1) value is inferred

(cid:66) ndarray.reshape may return a view (cf help(np.reshape))), or copy

3.2. Numerical operations on arrays

65

Scipy lecture notes, Edition 2015.2

>>> b[0, 0] = 99
>>> a
array([[99,
[ 4,

2,
5,

3],
6]])

Beware: reshape may also return a copy!:

>>> a = np.zeros((3, 2))
>>> b = a.T.reshape(3\*2)
>>> b[0] = 9
>>> a
array([[ 0., 0.],
0.],
[ 0.,
0.]])
[ 0.,

To understand this you need to learn more about the memory layout of a numpy array.

Adding a dimension

Indexing with the np.newaxis object allows us to add an axis to an array (you have seen this already above in
the broadcasting section):

>>> z = np.array([1, 2, 3])
>>> z
array([1, 2, 3])

>>> z[:, np.newaxis]
array([[1],
[2],
[3]])

>>> z[np.newaxis, :]
array([[1, 2, 3]])

Dimension shuffling

>>> a = np.arange(4\*3\*2).reshape(4, 3, 2)
>>> a.shape
(4, 3, 2)
>>> a[0, 2, 1]
5
>>> b = a.transpose(1, 2, 0)
>>> b.shape
(3, 2, 4)
>>> b[2, 1, 0]
5

Also creates a view:

>>> b[2, 1, 0] = -1
>>> a[0, 2, 1]
-1

Resizing

Size of an array can be changed with ndarray.resize:

>>> a = np.arange(4)
>>> a.resize((8,))
>>> a
array([0, 1, 2, 3, 0, 0, 0, 0])

3.2. Numerical operations on arrays

66

Scipy lecture notes, Edition 2015.2

However, it must not be referred to somewhere else:

>>> b = a
>>> a.resize((4,))
Traceback (most recent call last):

File "", line 1, in 

ValueError: cannot resize an array that has been referenced or is
referencing another array in this way.
Traceback (most recent call last):

Use the resize function

File "", line 1, in 

ValueError: cannot resize an array that has been referenced or is

Exercise: Shape manipulations

• Look at the docstring for reshape, especially the notes section which has some more information

about copies and views.

• Use flatten as an alternative to ravel. What is the difference? (Hint: check which one returns a

view and which a copy)

• Experiment with transpose for dimension shufﬂing.

3.2.5 Sorting data

Sorting along an axis:

>>> a = np.array([[4, 3, 5], [1, 2, 1]])
>>> b = np.sort(a, axis=1)
>>> b
array([[3, 4, 5],

[1, 1, 2]])

Sorts each row separately!

In-place sort:

>>> a.sort(axis=1)
>>> a
array([[3, 4, 5],

[1, 1, 2]])

Sorting with fancy indexing:

>>> a = np.array([4, 3, 1, 2])
>>> j = np.argsort(a)
>>> j
array([2, 3, 1, 0])
>>> a[j]
array([1, 2, 3, 4])

Finding minima and maxima:

>>> a = np.array([4, 3, 1, 2])
>>> j\_max = np.argmax(a)
>>> j\_min = np.argmin(a)
>>> j\_max, j\_min
(0, 2)

3.2. Numerical operations on arrays

67

Scipy lecture notes, Edition 2015.2

Exercise: Sorting

• Try both in-place and out-of-place sorting.
• Try creating arrays with different dtypes and sorting them.
• Use all or array\_equal to check the results.
• Look at np.random.shuffle for a way to create sortable input quicker.
• Combine ravel, sort and reshape.
• Look at the axis keyword for sort and rewrite the previous exercise.

3.2.6 Summary

What do you need to know to get started?

• Know how to create arrays : array, arange, ones, zeros.
• Know the shape of the array with array.shape, then use slicing to obtain different views of the array:

array[::2], etc. Adjust the shape of the array using reshape or ﬂatten it with ravel.

• Obtain a subset of the elements of an array and/or modify their values with masks

>>> a[a < 0] = 0

• Know miscellaneous operations on arrays, such as ﬁnding the mean or max (array.max(),
array.mean()). No need to retain everything, but have the reﬂex to search in the documentation (on-
line docs, help(), lookfor())!!

• For advanced use: master the indexing with arrays of integers, as well as broadcasting. Know more

Numpy functions to handle various array operations.

Quick read

If you want to do a ﬁrst quick pass through the Scipy lectures to learn the ecosystem, you can directly
skip to the next chapter: Matplotlib: plotting.
The remainder of this chapter is not necessary to follow the rest of the intro part. But be sure to come
back and ﬁnish this chapter, as well as to do some more exercices.

3.3 More elaborate arrays

Section contents

• More data types
• Structured data types
• maskedarray: dealing with (propagation of) missing data

3.3.1 More data types

Casting

“Bigger” type wins in mixed-type operations:

>>> np.array([1, 2, 3]) + 1.5
array([ 2.5, 3.5,

4.5])

Assignment never changes the type!

3.3. More elaborate arrays

68

Scipy lecture notes, Edition 2015.2

>>> a = np.array([1, 2, 3])
>>> a.dtype
dtype('int64')
>>> a[0] = 1.9
>>> a
array([1, 2, 3])

# <-- float is truncated to integer

Forced casts:

>>> a = np.array([1.7, 1.2, 1.6])
>>> b = a.astype(int)
>>> b
array([1, 1, 1])

# <-- truncates to integer

Rounding:

>>> a = np.array([1.2, 1.5, 1.6, 2.5, 3.5, 4.5])
>>> b = np.around(a)
>>> b
array([ 1.,
4.,
>>> c = np.around(a).astype(int)
>>> c
array([1, 2, 2, 2, 4, 4])

# still floating-point

4.])

2.,

2.,

2.,

Different data type sizes

Integers (signed):

int8
int16
int32
int64

8 bits
16 bits
32 bits (same as int on 32-bit platform)
64 bits (same as int on 64-bit platform)

>>> np.array([1], dtype=int).dtype
dtype('int64')
>>> np.iinfo(np.int32).max, 2\*\*31 - 1
(2147483647, 2147483647)

Unsigned integers:

uint8
uint16
uint32
uint64

8 bits
16 bits
32 bits
64 bits

>>> np.iinfo(np.uint32).max, 2\*\*32 - 1
(4294967295, 4294967295)

Long integers

Python 2 has a speciﬁc type for ‘long’ integers, that cannot overﬂow, represented with an ‘L’ at the end.
In Python 3, all integers are long, and thus cannot overﬂow.

>>> np.iinfo(np.int64).max, 2\*\*63 - 1
(9223372036854775807, 9223372036854775807L)

Floating-point numbers:

3.3. More elaborate arrays

69

Scipy lecture notes, Edition 2015.2

float16
float32
float64
float96
float128

16 bits
32 bits
64 bits (same as float)
96 bits, platform-dependent (same as np.longdouble)
128 bits, platform-dependent (same as np.longdouble)

>>> np.finfo(np.float32).eps
1.1920929e-07
>>> np.finfo(np.float64).eps
2.2204460492503131e-16

>>> np.float32(1e-8) + np.float32(1) == 1
True
>>> np.float64(1e-8) + np.float64(1) == 1
False

Complex ﬂoating-point numbers:

complex64
complex128
complex192
complex256

two 32-bit ﬂoats
two 64-bit ﬂoats
two 96-bit ﬂoats, platform-dependent
two 128-bit ﬂoats, platform-dependent

Smaller data types

If you don’t know you need special data types, then you probably don’t.
Comparison on using float32 instead of float64:

• Half the size in memory and on disk
• Half the memory bandwidth required (may be a bit faster in some operations)

In [1]: a = np.zeros((1e6,), dtype=np.float64)

In [2]: b = np.zeros((1e6,), dtype=np.float32)

In [3]: %timeit a\*a
1000 loops, best of 3: 1.78 ms per loop

In [4]: %timeit b\*b
1000 loops, best of 3: 1.07 ms per loop

• But: bigger rounding errors — sometimes in surprising places (i.e., don’t use them unless you really

need them)

3.3.2 Structured data types

sensor\_code
position
value

(4-character string)
(ﬂoat)
(ﬂoat)

>>> samples = np.zeros((6,), dtype=[('sensor\_code', 'S4'),
...
>>> samples.ndim
1
>>> samples.shape
(6,)
>>> samples.dtype.names
('sensor\_code', 'position', 'value')

('position', float), ('value', float)])

>>> samples[:] = [('ALFA',
...
>>> samples

0.13),
('ALFA', 1.5, 0.37), ('ALFA', 3, 0.11), ('TAU', 1.2, 0.13)]

1, 0.37), ('BETA', 1, 0.11), ('TAU', 1,

3.3. More elaborate arrays

70

Scipy lecture notes, Edition 2015.2

array([('ALFA', 1.0, 0.37), ('BETA', 1.0, 0.11), ('TAU', 1.0, 0.13),

('ALFA', 1.5, 0.37), ('ALFA', 3.0, 0.11), ('TAU', 1.2, 0.13)],

dtype=[('sensor\_code', 'S4'), ('position', '>> samples['sensor\_code']
array(['ALFA', 'BETA', 'TAU', 'ALFA', 'ALFA', 'TAU'],

dtype='|S4')

>>> samples['value']
array([ 0.37,
0.11,
>>> samples[0]
('ALFA', 1.0, 0.37)

0.13,

0.37,

0.11,

0.13])

>>> samples[0]['sensor\_code'] = 'TAU'
>>> samples[0]
('TAU', 1.0, 0.37)

Multiple ﬁelds at once:

>>> samples[['position', 'value']]
array([(1.0, 0.37), (1.0, 0.11), (1.0, 0.13), (1.5, 0.37), (3.0, 0.11),

(1.2, 0.13)],

dtype=[('position', '>> samples[samples['sensor\_code'] == 'ALFA']
array([('ALFA', 1.5, 0.37), ('ALFA', 3.0, 0.11)],

dtype=[('sensor\_code', 'S4'), ('position', '>> x = np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1])
>>> x
masked\_array(data = [1 -- 3 --],

mask = [False

True False

True],

fill\_value = 999999)

>>> y = np.ma.array([1, 2, 3, 4], mask=[0, 1, 1, 1])
>>> x + y
masked\_array(data = [2 -- -- --],

mask = [False

True

True

True],

fill\_value = 999999)

• Masking versions of common functions:

>>> np.ma.sqrt([1, -1, 2, -2])
masked\_array(data = [1.0 -- 1.41421356237... --],

mask = [False
fill\_value = 1e+20)

True False

True],

There are other useful array siblings

While it is off topic in a chapter on numpy, let’s take a moment to recall good coding practice, which really do
pay off in the long run:

3.3. More elaborate arrays

71

Scipy lecture notes, Edition 2015.2

Good practices

• Explicit variable names (no need of a comment to explain what is in the variable)
• Style: spaces after commas, around =, etc.

A certain number of rules for writing “beautiful” code (and, more importantly, using the same con-
ventions as everybody else!) are given in the Style Guide for Python Code and the Docstring Con-
ventions page (to manage help strings).

• Except some rare cases, variable names and comments in English.

3.4 Advanced operations

Section contents

• Polynomials
• Loading data ﬁles

3.4.1 Polynomials

Numpy also contains polynomials in different bases:

For example, 3x2 + 2x − 1:

>>> p = np.poly1d([3, 2, -1])
>>> p(0)
-1
>>> p.roots
array([-1.
>>> p.order
2

,

0.33333333])

>>> x = np.linspace(0, 1, 20)
>>> y = np.cos(x) + 0.3\*np.random.rand(20)
>>> p = np.poly1d(np.polyfit(x, y, 3))

>>> t = np.linspace(0, 1, 200)
>>> plt.plot(x, y, 'o', t, p(t), '-')
[, ]

3.4. Advanced operations

72

Scipy lecture notes, Edition 2015.2

See http://docs.scipy.org/doc/numpy/reference/routines.polynomials.poly1d.html for more.

More polynomials (with more bases)

Numpy also has a more sophisticated polynomial interface, which supports e.g. the Chebyshev basis.

3x2 + 2x − 1:

>>> p = np.polynomial.Polynomial([-1, 2, 3]) # coefs in different order!
>>> p(0)
-1.0
>>> p.roots()
array([-1.
>>> p.degree() # In general polynomials do not always expose 'order'
2

0.33333333])

,

Example using polynomials in Chebyshev basis, for polynomials in range [-1, 1]:

>>> x = np.linspace(-1, 1, 2000)
>>> y = np.cos(x) + 0.3\*np.random.rand(2000)
>>> p = np.polynomial.Chebyshev.fit(x, y, 90)

>>> t = np.linspace(-1, 1, 200)
>>> plt.plot(x, y, 'r.')
[]
>>> plt.plot(t, p(t), 'k-', lw=3)
[]

3.4. Advanced operations

73

0.00.20.40.60.81.00.60.70.80.91.01.11.21.3Scipy lecture notes, Edition 2015.2

The Chebyshev polynomials have some advantages in interpolation.

3.4.2 Loading data files

Text files

Example: populations.txt:
carrot
# year hare
48300
30e3
1900
48200
47.2e3 6.1e3
1901
70.2e3 9.8e3
1902
41500
77.4e3 35.2e3 38200
1903

lynx
4e3

>>> data = np.loadtxt('data/populations.txt')
>>> data
array([[
[
[

48300.],
48200.],
41500.],

30000.,
47200.,
70200.,

1900.,
1901.,
1902.,

4000.,
6100.,
9800.,

...

>>> np.savetxt('pop2.txt', data)
>>> data2 = np.loadtxt('pop2.txt')

If you have a complicated text ﬁle, what you can try are:

• np.genfromtxt
• Using Python’s I/O functions and e.g. regexps for parsing (Python is quite well suited for this)

3.4. Advanced operations

74

1.00.50.00.51.00.50.60.70.80.91.01.11.21.3Scipy lecture notes, Edition 2015.2

Reminder: Navigating the ﬁlesystem with IPython

# show current directory

In [1]: pwd
'/home/user/stuff/2011-numpy-tutorial'
In [2]: cd ex
'/home/user/stuff/2011-numpy-tutorial/ex'
In [3]: ls
populations.txt

species.txt

Images

Using Matplotlib:

>>> img = plt.imread('data/elephant.png')
>>> img.shape, img.dtype
((200, 300, 3), dtype('float32'))
>>> plt.imshow(img)

>>> plt.savefig('plot.png')

>>> plt.imsave('red\_elephant', img[:,:,0], cmap=plt.cm.gray)

This saved only one channel (of RGB):

>>> plt.imshow(plt.imread('red\_elephant.png'))


Other libraries:

>>> from scipy.misc import imsave
>>> imsave('tiny\_elephant.png', img[::6,::6])
>>> plt.imshow(plt.imread('tiny\_elephant.png'), interpolation='nearest')


3.4. Advanced operations

75

Scipy lecture notes, Edition 2015.2

Numpy’s own format

Numpy has its own binary format, not portable but with efﬁcient I/O:

>>> data = np.ones((3, 3))
>>> np.save('pop.npy', data)
>>> data3 = np.load('pop.npy')

Well-known (& more obscure) file formats

• HDF5: h5py, PyTables
• NetCDF: scipy.io.netcdf\_file, netcdf4-python, ...
• Matlab: scipy.io.loadmat, scipy.io.savemat
• MatrixMarket: scipy.io.mmread, scipy.io.mmwrite
• IDL: scipy.io.readsav

... if somebody uses it, there’s probably also a Python library for it.

Exercise: Text data ﬁles
Write a Python script that loads data from populations.txt:: and drop the last column and the ﬁrst 5
rows. Save the smaller dataset to pop2.txt.

3.4. Advanced operations

76

010203040051015202530Scipy lecture notes, Edition 2015.2

Numpy internals

If you are interested in the Numpy internals, there is a good discussion in Advanced Numpy.

3.5 Some exercises

3.5.1 Array manipulations

1. Form the 2-D array (without typing it in explicitly):

[[1,

6, 11],
[2, 7, 12],
[3, 8, 13],
[4, 9, 14],
[5, 10, 15]]

and generate a new array containing its 2nd and 4th rows.

2. Divide each column of the array:

>>> import numpy as np
>>> a = np.arange(25).reshape(5, 5)

elementwise with the array b = np.array([1., 5, 10, 15, 20]). (Hint: np.newaxis).

3. Harder one: Generate a 10 x 3 array of random numbers (in range [0,1]). For each row, pick the number

closest to 0.5.

• Use abs and argsort to ﬁnd the column j closest for each row.
• Use fancy indexing to extract the numbers. (Hint: a[i,j] – the array i must contain the row num-

bers corresponding to stuff in j.)

3.5.2 Picture manipulation: Framing Lena

Let’s do some manipulations on numpy arrays by starting with the famous
image of Lena
(http://www.cs.cmu.edu/~chuck/lennapg/). scipy provides a 2D array of this image with the scipy.lena
function:

>>> from scipy import misc
>>> lena = misc.lena()

Note: In older versions of scipy, you will ﬁnd lena under scipy.lena()

Here are a few images we will be able to obtain with our manipulations: use different colormaps, crop the
image, change some parts of the image.

• Let’s use the imshow function of pylab to display the image.

3.5. Some exercises

77

Scipy lecture notes, Edition 2015.2

>>> import pylab as plt
>>> lena = misc.lena()
>>> plt.imshow(lena)


• Lena is then displayed in false colors. A colormap must be speciﬁed for her to be displayed in grey.

>>> plt.imshow(lena, cmap=plt.cm.gray)


• Create an array of the image with a narrower centering [for example,] remove 30 pixels from all the

borders of the image. To check the result, display this new array with imshow.

>>> crop\_lena = lena[30:-30,30:-30]

• We will now frame Lena’s face with a black locket. For this, we need to create a mask corresponding to
the pixels we want to be black. The mask is deﬁned by this condition (y-256)\*\*2 + (x-256)\*\*2

>>> y, x = np.ogrid[0:512,0:512] # x and y indices of pixels
>>> y.shape, x.shape
((512, 1), (1, 512))
>>> centerx, centery = (256, 256) # center of the image
>>> mask = ((y - centery)\*\*2 + (x - centerx)\*\*2) > 230\*\*2 # circle

then we assign the value 0 to the pixels of the image corresponding to the mask. The syntax is
extremely simple and intuitive:

>>> lena[mask] = 0
>>> plt.imshow(lena)


• Follow-up: copy all instructions of this exercise in a script called lena\_locket.py then execute this

script in IPython with %run lena\_locket.py.

Change the circle to an ellipsoid.

3.5.3 Data statistics

The data in populations.txt describes the populations of hares and lynxes (and carrots) in northern Canada
during 20 years:

>>> data = np.loadtxt('data/populations.txt')
>>> year, hares, lynxes, carrots = data.T # trick: columns to variables

>>> import matplotlib.pyplot as plt
>>> plt.axes([0.2, 0.1, 0.5, 0.8])

>>> plt.plot(year, hares, year, lynxes, year, carrots)
[, ...]
>>> plt.legend(('Hare', 'Lynx', 'Carrot'), loc=(1.05, 0.5))


3.5. Some exercises

78

Scipy lecture notes, Edition 2015.2

Computes and print, based on the data in populations.txt...

1. The mean and std of the populations of each species for the years in the period.

2. Which year each species had the largest population.

3. Which species has the largest population for each year.

np.array([’H’, ’L’, ’C’]))

(Hint: argsort & fancy indexing of

4. Which years any of the populations is above 50000. (Hint: comparisons and np.any)
5. The top 2 years for each species when they had the lowest populations. (Hint: argsort, fancy indexing)
6. Compare (plot) the change in hare population (see help(np.gradient)) and the number of lynxes.

Check correlation (see help(np.corrcoef)).

... all without for-loops.
Solution: Python source file

3.5.4 Crude integral approximations

Write a function f(a, b, c) that returns ab − c. Form a 24x12x6 array containing its values in parameter
ranges [0,1] x [0,1] x [0,1].

Approximate the 3-d integral

(cid:90) 1

(cid:90) 1

(cid:90) 1

0

0

0

(ab − c)d a d b d c

over this volume with the mean. The exact result is: ln 2 − 1
2
(Hints: use elementwise operations and broadcasting. You can make np.ogrid give a number of points in
given range with np.ogrid[0:1:20j].)

≈ 0.1931 . . . — what is your relative error?

3.5. Some exercises

79

1900190519101915192001000020000300004000050000600007000080000HareLynxCarrotScipy lecture notes, Edition 2015.2

Reminder Python functions:

def f(a, b, c):

return some\_result

Solution: Python source file

3.5.5 Mandelbrot set

Write a script that computes the Mandelbrot fractal. The Mandelbrot iteration:

N\_max = 50
some\_threshold = 50

c = x + 1j\*y

for j in xrange(N\_max):

z = z\*\*2 + c

Point (x, y) belongs to the Mandelbrot set if |c| < some\_threshold.

Do this computation by:

1. Construct a grid of c = x + 1j\*y values in range [-2, 1] x [-1.5, 1.5]

2. Do the iteration

3. Form the 2-d boolean mask indicating which points are in the set

4. Save the result to an image with:

>>> import matplotlib.pyplot as plt
>>> plt.imshow(mask.T, extent=[-2, 1, -1.5, 1.5])


3.5. Some exercises

80

2.01.51.00.50.00.51.01.51.00.50.00.51.01.5Scipy lecture notes, Edition 2015.2

>>> plt.gray()
>>> plt.savefig('mandelbrot.png')

Solution: Python source file

3.5.6 Markov chain

Markov chain transition matrix P, and probability distribution on the states p:

1. 0 <= P[i,j] <= 1: probability to go from state i to state j

2. Transition rule: pnew = P T pol d
3. all(sum(P, axis=1) == 1), p.sum() == 1: normalization

Write a script that works with 5 states, and:

• Constructs a random matrix, and normalizes each row so that it is a transition matrix.
• Starts from a random (normalized) probability distribution p and takes 50 steps => p\_50
• Computes the stationary distribution: the eigenvector of P.T with eigenvalue 1 (numerically: closest to

1) => p\_stationary

Remember to normalize the eigenvector — I didn’t...

• Checks if p\_50 and p\_stationary are equal to tolerance 1e-5

Toolbox: np.random.rand, .dot(), np.linalg.eig, reductions, abs(), argmin, comparisons, all,
np.linalg.norm, etc.
Solution: Python source file

3.5. Some exercises

81

CHAPTER 4

Matplotlib: plotting

Thanks

Many thanks to Bill Wing and Christoph Deil for review and corrections.

Authors: Nicolas Rougier, Mike Müller, Gaël Varoquaux

Chapter contents

• Introduction
• Simple plot
• Figures, Subplots, Axes and Ticks
• Other Types of Plots: examples and exercises
• Beyond this tutorial
• Quick references

4.1 Introduction

Matplotlib is probably the single most used Python package for 2D-graphics. It provides both a very quick
way to visualize data from Python and publication-quality ﬁgures in many formats. We are going to explore
matplotlib in interactive mode covering most common cases.

4.1.1 IPython and the matplotlib mode

IPython is an enhanced interactive Python shell that has lots of interesting features including named inputs
and outputs, access to shell commands, improved debugging and many more. It is central to the scientiﬁc-
computing workﬂow in Python for its use in combination with Matplotlib:
For interactive matplotlib sessions with Matlab/Mathematica-like functionality, we use IPython with it’s spe-
cial Matplotlib mode that enables non-blocking plotting.

IPython console When using the IPython console, we start it with the command line argument

--matplotlib (-pylab in very old versions).

IPython notebook In the IPython notebook, we insert, at the beginning of the notebook the fol-

lowing magic:

%matplotlib inline

82

Scipy lecture notes, Edition 2015.2

4.1.2 pyplot

pyplot provides a procedural interface to the matplotlib object-oriented plotting library. It is modeled closely
after Matlab™. Therefore, the majority of plotting commands in pyplot have Matlab™ analogs with similar
arguments. Important commands are explained with interactive examples.

from matplotlitb import pyplot as plt

4.2 Simple plot

In this section, we want to draw the cosine and sine functions on the same plot. Starting from the default
settings, we’ll enrich the ﬁgure step by step to make it nicer.
First step is to get the data for the sine and cosine functions:

import numpy as np

X = np.linspace(-np.pi, np.pi, 256, endpoint=True)
C, S = np.cos(X), np.sin(X)

X is now a numpy array with 256 values ranging from -π to +π (included). C is the cosine (256 values) and S is
the sine (256 values).

To run the example, you can type them in an IPython interactive session:

$ ipython --pylab

This brings us to the IPython prompt:

IPython 0.13 -- An enhanced Interactive Python.
?
%magic
help
object? -> Details about 'object'. ?object also works, ?? prints more.

-> Introduction to IPython's features.
-> Information about IPython's 'magic' % functions.
-> Python's own help system.

Welcome to pylab, a matplotlib-based Python environment.
For more information, type 'help(pylab)'.

You can also download each of the examples and run it using regular python, but you will loose interactive
data manipulation:

$ python exercice\_1.py

You can get source for each step by clicking on the corresponding ﬁgure.

4.2.1 Plotting with default settings

Documentation

• plot tutorial
• plot() command

4.2. Simple plot

83

Scipy lecture notes, Edition 2015.2

Matplotlib comes with a set of default settings that allow customizing all kinds of properties. You can control
the defaults of almost every property in matplotlib: ﬁgure size and dpi, line width, color and style, axes, axis
and grid properties, text and font properties and so on.

import numpy as np
import matplotlib.pyplot as plt

X = np.linspace(-np.pi, np.pi, 256, endpoint=True)
C, S = np.cos(X), np.sin(X)

plt.plot(X, C)
plt.plot(X, S)

plt.show()

4.2.2 Instantiating defaults

Documentation

• Customizing matplotlib

In the script below, we’ve instantiated (and commented) all the ﬁgure settings that inﬂuence the appearance
of the plot.

The settings have been explicitly set to their default values, but now you can interactively play with the values
to explore their affect (see Line properties and Line styles below).

import numpy as np
import matplotlib.pyplot as plt

# Create a figure of size 8x6 inches, 80 dots per inch
plt.figure(figsize=(8, 6), dpi=80)

# Create a new subplot from a grid of 1x1
plt.subplot(1, 1, 1)

X = np.linspace(-np.pi, np.pi, 256, endpoint=True)
C, S = np.cos(X), np.sin(X)

# Plot cosine with a blue continuous line of width 1 (pixels)
plt.plot(X, C, color="blue", linewidth=1.0, linestyle="-")

# Plot sine with a green continuous line of width 1 (pixels)
plt.plot(X, S, color="green", linewidth=1.0, linestyle="-")

# Set x limits
plt.xlim(-4.0, 4.0)

# Set x ticks
plt.xticks(np.linspace(-4, 4, 9, endpoint=True))

# Set y limits
plt.ylim(-1.0, 1.0)

4.2. Simple plot

84

Scipy lecture notes, Edition 2015.2

# Set y ticks
plt.yticks(np.linspace(-1, 1, 5, endpoint=True))

# Save figure using 72 dots per inch
# plt.savefig("exercice\_2.png", dpi=72)

# Show result on screen
plt.show()

4.2.3 Changing colors and line widths

Documentation

• Controlling line properties
• Line API

First step, we want to have the cosine in blue and the sine in red and a slighty thicker line for both of them.
We’ll also slightly alter the ﬁgure size to make it more horizontal.
...
plt.figure(figsize=(10, 6), dpi=80)
plt.plot(X, C, color="blue", linewidth=2.5, linestyle="-")
plt.plot(X, S, color="red",
linewidth=2.5, linestyle="-")
...

4.2.4 Setting limits

Documentation

• xlim() command
• ylim() command

Current limits of the ﬁgure are a bit too tight and we want to make some space in order to clearly see all data
points.
...
plt.xlim(X.min() \* 1.1, X.max() \* 1.1)
plt.ylim(C.min() \* 1.1, C.max() \* 1.1)
...

4.2. Simple plot

85

4.2.5 Setting ticks

Scipy lecture notes, Edition 2015.2

Documentation

• xticks() command
• yticks() command
• Tick container
• Tick locating and formatting

Current ticks are not ideal because they do not show the interesting values (+/-π,+/-π/2) for sine and cosine.
We’ll change them such that they show only these values.
...
plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi])
plt.yticks([-1, 0, +1])
...

4.2.6 Setting tick labels

Documentation

• Working with text
• xticks() command
• yticks() command
• set\_xticklabels()
• set\_yticklabels()

Ticks are now properly placed but their label is not very explicit. We could guess that 3.142 is π but it would
be better to make it explicit. When we set tick values, we can also provide a corresponding label in the second
argument list. Note that we’ll use latex to allow for nice rendering of the label.
...
plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi],

[r'$-\pi$', r'$-\pi/2$', r'$0$', r'$+\pi/2$', r'$+\pi$'])

plt.yticks([-1, 0, +1],

[r'$-1$', r'$0$', r'$+1$'])

...

4.2. Simple plot

86

4.2.7 Moving spines

Scipy lecture notes, Edition 2015.2

Documentation
• Spines
• Axis container
• Transformations tutorial

Spines are the lines connecting the axis tick marks and noting the boundaries of the data area. They can be
placed at arbitrary positions and until now, they were on the border of the axis. We’ll change that since we
want to have them in the middle. Since there are four of them (top/bottom/left/right), we’ll discard the top
and right by setting their color to none and we’ll move the bottom and left ones to coordinate 0 in data space
coordinates.
...
ax = plt.gca() # gca stands for 'get current axis'
ax.spines['right'].set\_color('none')
ax.spines['top'].set\_color('none')
ax.xaxis.set\_ticks\_position('bottom')
ax.spines['bottom'].set\_position(('data',0))
ax.yaxis.set\_ticks\_position('left')
ax.spines['left'].set\_position(('data',0))
...

4.2.8 Adding a legend

Documentation

• Legend guide
• legend() command
• Legend API

Let’s add a legend in the upper left corner. This only requires adding the keyword argument label (that will be
used in the legend box) to the plot commands.
...
plt.plot(X, C, color="blue", linewidth=2.5, linestyle="-", label="cosine")
plt.plot(X, S, color="red",

linewidth=2.5, linestyle="-", label="sine")

plt.legend(loc='upper left')
...

4.2. Simple plot

87

4.2.9 Annotate some points

Scipy lecture notes, Edition 2015.2

Documentation

• Annotating axis
• annotate() command

Let’s annotate some interesting points using the annotate command. We chose the 2π/3 value and we want to
annotate both the sine and the cosine. We’ll ﬁrst draw a marker on the curve as well as a straight dotted line.
Then, we’ll use the annotate command to display some text with an arrow.
...

t = 2 \* np.pi / 3
plt.plot([t, t], [0, np.cos(t)], color='blue', linewidth=2.5, linestyle="--")
plt.scatter([t, ], [np.cos(t), ], 50, color='blue')

plt.annotate(r'$sin(\frac{2\pi}{3})=\frac{\sqrt{3}}{2}$',

xy=(t, np.sin(t)), xycoords='data',
xytext=(+10, +30), textcoords='offset points', fontsize=16,
arrowprops=dict(arrowstyle="->", connectionstyle="arc3,rad=.2"))

plt.plot([t, t],[0, np.sin(t)], color='red', linewidth=2.5, linestyle="--")
plt.scatter([t, ],[np.sin(t), ], 50, color='red')

plt.annotate(r'$cos(\frac{2\pi}{3})=-\frac{1}{2}$',

xy=(t, np.cos(t)), xycoords='data',
xytext=(-90, -50), textcoords='offset points', fontsize=16,
arrowprops=dict(arrowstyle="->", connectionstyle="arc3,rad=.2"))

...

4.2.10 Devil is in the details

Documentation
• Artists
• BBox

The tick labels are now hardly visible because of the blue and red lines. We can make them bigger and we can
also adjust their properties such that they’ll be rendered on a semi-transparent white background. This will
allow us to see both the data and the labels.
...
for label in ax.get\_xticklabels() + ax.get\_yticklabels():

label.set\_fontsize(16)
label.set\_bbox(dict(facecolor='white', edgecolor='None', alpha=0.65))

...

4.2. Simple plot

88

Scipy lecture notes, Edition 2015.2

4.3 Figures, Subplots, Axes and Ticks

A “ﬁgure” in matplotlib means the whole window in the user interface. Within this ﬁgure there can be “sub-
plots”.

So far we have used implicit ﬁgure and axes creation. This is handy for fast plots. We can have more control
over the display using ﬁgure, subplot, and axes explicitly. While subplot positions the plots in a regular grid,
axes allows free placement within the ﬁgure. Both can be useful depending on your intention. We’ve already
worked with ﬁgures and subplots without explicitly calling them. When we call plot, matplotlib calls gca() to
get the current axes and gca in turn calls gcf() to get the current ﬁgure. If there is none it calls figure() to
make one, strictly speaking, to make a subplot(111). Let’s look at the details.

4.3.1 Figures

A ﬁgure is the windows in the GUI that has “Figure #” as title. Figures are numbered starting from 1 as opposed
to the normal Python way starting from 0. This is clearly MATLAB-style. There are several parameters that
determine what the ﬁgure looks like:

Argument
num
figsize
dpi
facecolor
edgecolor
frameon

Default
1
figure.figsize
figure.dpi
figure.facecolor
figure.edgecolor
True

Description
number of ﬁgure
ﬁgure size in in inches (width, height)
resolution in dots per inch
color of the drawing background
color of edge around the drawing background
draw ﬁgure frame or not

The defaults can be speciﬁed in the resource ﬁle and will be used most of the time. Only the number of the
ﬁgure is frequently changed.
As with other objects, you can set ﬁgure properties also setp or with the set\_something methods.
When you work with the GUI you can close a ﬁgure by clicking on the x in the upper right corner. But you can
close a ﬁgure programmatically by calling close. Depending on the argument it closes (1) the current ﬁgure
(no argument), (2) a speciﬁc ﬁgure (ﬁgure number or ﬁgure instance as argument), or (3) all ﬁgures ("all" as
argument).

plt.close(1)

# Closes figure 1

4.3.2 Subplots

With subplot you can arrange plots in a regular grid. You need to specify the number of rows and columns and
the number of the plot. Note that the gridspec command is a more powerful alternative.

4.3.3 Axes

Axes are very similar
ure.

So if we want

to subplots but allow placement of plots at any location in the ﬁg-
inside a bigger one we do so with axes.

to put a smaller plot

4.3. Figures, Subplots, Axes and Ticks

89

Scipy lecture notes, Edition 2015.2

4.3.4 Ticks

Well formatted ticks are an important part of publishing-ready ﬁgures. Matplotlib provides a totally conﬁg-
urable system for ticks. There are tick locators to specify where ticks should appear and tick formatters to
give ticks the appearance you want. Major and minor ticks can be located and formatted independently from
each other. Per default minor ticks are not shown, i.e. there is only an empty list for them because it is as
NullLocator (see below).

Tick Locators

Tick locators control the positions of the ticks. They are set as follows:

ax = plt.gca()
ax.xaxis.set\_major\_locator(eval(locator))

There are several locators for different kind of requirements:
All of these locators derive from the base class matplotlib.ticker.Locator. You can make your own lo-
cator deriving from it. Handling dates as ticks can be especially tricky. Therefore, matplotlib provides special
locators in matplotlib.dates.

4.4 Other Types of Plots: examples and exercises

4.4. Other Types of Plots: examples and exercises

90

4.4.1 Regular Plots

Scipy lecture notes, Edition 2015.2

Starting from the code below, try to reproduce the graphic on the right taking care of ﬁlled areas:

You need to use the ﬁll\_between command.

n = 256
X = np.linspace(-np.pi, np.pi, n, endpoint=True)
Y = np.sin(2 \* X)

plt.plot(X, Y + 1, color='blue', alpha=1.00)
plt.plot(X, Y - 1, color='blue', alpha=1.00)

Click on the ﬁgure for solution.

4.4.2 Scatter Plots

Starting from the code below, try to reproduce the graphic on the right taking care of marker size, color and
transparency.

Color is given by angle of (X,Y).

n = 1024
X = np.random.normal(0,1,n)
Y = np.random.normal(0,1,n)

plt.scatter(X,Y)

Click on ﬁgure for solution.

4.4. Other Types of Plots: examples and exercises

91

4.4.3 Bar Plots

Scipy lecture notes, Edition 2015.2

Starting from the code below, try to reproduce the graphic on the right by adding labels for red bars.

You need to take care of text alignment.

n = 12
X = np.arange(n)
Y1 = (1 - X / float(n)) \* np.random.uniform(0.5, 1.0, n)
Y2 = (1 - X / float(n)) \* np.random.uniform(0.5, 1.0, n)

plt.bar(X, +Y1, facecolor='#9999ff', edgecolor='white')
plt.bar(X, -Y2, facecolor='#ff9999', edgecolor='white')

for x, y in zip(X, Y1):

plt.text(x + 0.4, y + 0.05, '%.2f ' % y, ha='center', va='bottom')

plt.ylim(-1.25, +1.25)

Click on ﬁgure for solution.

4.4.4 Contour Plots

Starting from the code below, try to reproduce the graphic on the right taking care of the colormap (see Col-
ormaps below).

You need to use the clabel command.

def f(x, y):

return (1 - x / 2 + x \*\* 5 + y \*\* 3) \* np.exp(-x \*\* 2 -y \*\* 2)

n = 256
x = np.linspace(-3, 3, n)
y = np.linspace(-3, 3, n)
X, Y = np.meshgrid(x, y)

plt.contourf(X, Y, f(X, Y), 8, alpha=.75, cmap='jet')
C = plt.contour(X, Y, f(X, Y), 8, colors='black', linewidth=.5)

Click on ﬁgure for solution.

4.4. Other Types of Plots: examples and exercises

92

4.4.5 Imshow

Scipy lecture notes, Edition 2015.2

You need to take care of the origin of the image in the imshow command and use a colorbar

Starting from the code below, try to reproduce the graphic on the right taking care of colormap, image inter-
polation and origin.

def f(x, y):

return (1 - x / 2 + x \*\* 5 + y \*\* 3) \* np.exp(-x \*\* 2 - y \*\* 2)

n = 10
x = np.linspace(-3, 3, 4 \* n)
y = np.linspace(-3, 3, 3 \* n)
X, Y = np.meshgrid(x, y)
plt.imshow(f(X, Y))

Click on the ﬁgure for the solution.

4.4.6 Pie Charts

Starting from the code below, try to reproduce the graphic on the right taking care of colors and slices size.

You need to modify Z.

Z = np.random.uniform(0, 1, 20)
plt.pie(Z)

Click on the ﬁgure for the solution.

4.4. Other Types of Plots: examples and exercises

93

4.4.7 Quiver Plots

Scipy lecture notes, Edition 2015.2

Starting from the code above, try to reproduce the graphic on the right taking care of colors and orientations.

You need to draw arrows twice.

n = 8
X, Y = np.mgrid[0:n, 0:n]
plt.quiver(X, Y)

Click on ﬁgure for solution.

4.4.8 Grids

taking care of line styles.

axes = plt.gca()
axes.set\_xlim(0, 4)
axes.set\_ylim(0, 3)
axes.set\_xticklabels([])
axes.set\_yticklabels([])

Click on ﬁgure for solution.

4.4.9 Multi Plots

Starting from the code below, try to reproduce the graphic on the right

Starting from the code below, try to reproduce the graphic on the right.

You can use several subplots with different partition.

4.4. Other Types of Plots: examples and exercises

94

Scipy lecture notes, Edition 2015.2

plt.subplot(2, 2, 1)
plt.subplot(2, 2, 3)
plt.subplot(2, 2, 4)

Click on ﬁgure for solution.

4.4.10 Polar Axis

You only need to modify the axes line

Starting from the code below, try to reproduce the graphic on the right.

plt.axes([0, 0, 1, 1])

N = 20
theta = np.arange(0., 2 \* np.pi, 2 \* np.pi / N)
radii = 10 \* np.random.rand(N)
width = np.pi / 4 \* np.random.rand(N)
bars = plt.bar(theta, radii, width=width, bottom=0.0)

for r, bar in zip(radii, bars):

bar.set\_facecolor(cm.jet(r / 10.))
bar.set\_alpha(0.5)

Click on ﬁgure for solution.

4.4.11 3D Plots

Starting from the code below, try to reproduce the graphic on the right.

from mpl\_toolkits.mplot3d import Axes3D

You need to use contourf

fig = plt.figure()
ax = Axes3D(fig)
X = np.arange(-4, 4, 0.25)
Y = np.arange(-4, 4, 0.25)
X, Y = np.meshgrid(X, Y)
R = np.sqrt(X\*\*2 + Y\*\*2)
Z = np.sin(R)

4.4. Other Types of Plots: examples and exercises

95

Scipy lecture notes, Edition 2015.2

ax.plot\_surface(X, Y, Z, rstride=1, cstride=1, cmap='hot')

Click on ﬁgure for solution.

See also:

3D plotting with Mayavi

4.4.12 Text

Have a look at the matplotlib logo.

Try to do the same from scratch !

Click on ﬁgure for solution.

Quick read

If you want to do a ﬁrst quick pass through the Scipy lectures to learn the ecosystem, you can directly
skip to the next chapter: Scipy : high-level scientiﬁc computing.
The remainder of this chapter is not necessary to follow the rest of the intro part. But be sure to come
back and ﬁnish this chapter later.

4.5 Beyond this tutorial

Matplotlib beneﬁts from extensive documentation as well as a large community of users and developers. Here
are some links of interest:

4.5.1 Tutorials

• Pyplot tutorial
• Introduction
• Controlling line properties
• Working with multiple ﬁgures and axes
• Working with text
• Image tutorial
• Startup commands
• Importing image data into Numpy arrays
• Plotting numpy arrays as images
• Text tutorial
• Text introduction
• Basic text commands
• Text properties and layout
• Writing mathematical expressions
• Text rendering With LaTeX

4.5. Beyond this tutorial

96

Scipy lecture notes, Edition 2015.2

• Annotating text
• Artist tutorial
• Introduction
• Customizing your objects
• Object containers
• Figure container
• Axes container
• Axis containers
• Tick containers
• Path tutorial
• Introduction
• Bézier example
• Compound paths
• Transforms tutorial
• Introduction
• Data coordinates
• Axes coordinates
• Blended transformations
• Using offset transforms to create a shadow effect
• The transformation pipeline

4.5.2 Matplotlib documentation

• User guide

• FAQ

– Installation

– Usage

– How-To

– Troubleshooting

– Environment Variables

• Screenshots

4.5.3 Code documentation

The code is well documented and you can quickly access a speciﬁc command from within a python session:

>>> import matplotlib.pyplot as plt
>>> help(plt.plot)
Help on function plot in module matplotlib.pyplot:

plot(\*args, \*\*kwargs)

Plot lines and/or markers to the
:class:`~matplotlib.axes.Axes`.
argument, allowing for multiple \*x\*, \*y\* pairs with an
optional format string.
legal::

\*args\* is a variable length

For example, each of the following is

plot(x, y)
plot(x, y, 'bo')
plot(y)
plot(y, 'r+')

# plot x and y using default line style and color
# plot x and y using blue circle markers
# plot y using x as index array 0..N-1
# ditto, but with red plusses

If \*x\* and/or \*y\* is 2-dimensional, then the corresponding columns
will be plotted.

...

4.5. Beyond this tutorial

97

Scipy lecture notes, Edition 2015.2

4.5.4 Galleries

The matplotlib gallery is also incredibly useful when you search how to render a given graphic. Each example
comes with its source.

4.5.5 Mailing lists

Finally, there is a user mailing list where you can ask for help and a developers mailing list that is more techni-
cal.

4.6 Quick references

Here is a set of tables that show main properties and styles.

4.6.1 Line properties

Property

alpha (or a)

antialiased

Description

Appearance

alpha transparency on 0-1
scale

True or False - use antialised
rendering

color (or c)

matplotlib color arg

linestyle (or ls)

see Line properties

linewidth (or lw)

ﬂoat, the line width in points

solid\_capstyle

Cap style for solid lines

solid\_joinstyle

Join style for solid lines

dash\_capstyle

Cap style for dashes

dash\_joinstyle

Join style for dashes

marker

see Markers

markeredgewidth
(mew)

line width around the marker
symbol

markeredgecolor
(mec)

markerfacecolor
(mfc)

edge color if a marker is used

face color if a marker is used

markersize (ms)

size of the marker in points

4.6. Quick references

98

4.6.2 Line styles

Scipy lecture notes, Edition 2015.2

4.6.3 Markers

4.6.4 Colormaps

All colormaps can be reversed by appending \_r. For instance, gray\_r is the reverse of gray.

If you want to know more about colormaps, checks Documenting the matplotlib colormaps.

4.6. Quick references

99

Scipy lecture notes, Edition 2015.2

4.6. Quick references

100

CHAPTER 5

Scipy : high-level scientific computing

Authors: Adrien Chauve, Andre Espaze, Emmanuelle Gouillart, Gaël Varoquaux, Ralf Gommers

Scipy
The scipy package contains various toolboxes dedicated to common issues in scientiﬁc computing. Its
different submodules correspond to different applications, such as interpolation, integration, optimiza-
tion, image processing, statistics, special functions, etc.
scipy can be compared to other standard scientiﬁc-computing libraries, such as the GSL (GNU Scientiﬁc
Library for C and C++), or Matlab’s toolboxes. scipy is the core package for scientiﬁc routines in Python;
it is meant to operate efﬁciently on numpy arrays, so that numpy and scipy work hand in hand.
Before implementing a routine, it is worth checking if the desired data processing is not already imple-
mented in Scipy. As non-professional programmers, scientists often tend to re-invent the wheel, which
leads to buggy, non-optimal, difﬁcult-to-share and unmaintainable code. By contrast, Scipy‘s routines
are optimized and tested, and should therefore be used when possible.

Chapters contents

• File input/output: scipy.io
• Special functions: scipy.special
• Linear algebra operations: scipy.linalg
• Fast Fourier transforms: scipy.fftpack
• Optimization and ﬁt: scipy.optimize
• Statistics and random numbers: scipy.stats
• Interpolation: scipy.interpolate
• Numerical integration: scipy.integrate
• Signal processing: scipy.signal
• Image processing: scipy.ndimage
• Summary exercises on scientiﬁc computing

(cid:66)

This tutorial is far from an introduction to numerical computing. As enumerating the different submodules
and functions in scipy would be very boring, we concentrate instead on a few examples to give a general idea
of how to use scipy for scientiﬁc computing.

scipy is composed of task-speciﬁc sub-modules:

101

Scipy lecture notes, Edition 2015.2

scipy.cluster
scipy.constants
scipy.fftpack
scipy.integrate
scipy.interpolate
scipy.io
scipy.linalg
scipy.ndimage
scipy.odr
scipy.optimize
scipy.signal
scipy.sparse
scipy.spatial
scipy.special
scipy.stats

Vector quantization / Kmeans
Physical and mathematical constants
Fourier transform
Integration routines
Interpolation
Data input and output
Linear algebra routines
n-dimensional image package
Orthogonal distance regression
Optimization
Signal processing
Sparse matrices
Spatial data structures and algorithms
Any special mathematical functions
Statistics

They all depend on numpy, but are mostly independent of each other. The standard way of importing Numpy
and these Scipy modules is:

>>> import numpy as np
>>> from scipy import stats
The main scipy namespace mostly contains functions that are really numpy functions (try scipy.cos is
np.cos). Those are exposed for historical reasons only; there’s usually no reason to use import scipy in your
code.

# same for other sub-modules

5.1 File input/output: scipy.io

• Loading and saving matlab ﬁles:

>>> from scipy import io as spio
>>> a = np.ones((3, 3))
>>> spio.savemat('file.mat', {'a': a}) # savemat expects a dictionary
>>> data = spio.loadmat('file.mat', struct\_as\_record=True)
>>> data['a']
array([[ 1.,
[ 1.,
[ 1.,

1.],
1.],
1.]])

1.,
1.,
1.,

• Reading images:

>>> from scipy import misc
>>> misc.imread('fname.png')
array(...)
>>> # Matplotlib also has a similar function
>>> import matplotlib.pyplot as plt
>>> plt.imread('fname.png')
array(...)

See also:

• Load text ﬁles: numpy.loadtxt()/numpy.savetxt()
• Clever loading of text/csv ﬁles: numpy.genfromtxt()/numpy.recfromcsv()
• Fast and efﬁcient, but numpy-speciﬁc, binary format: numpy.save()/numpy.load()

5.1. File input/output: scipy.io

102

Scipy lecture notes, Edition 2015.2

5.2 Special functions: scipy.special

Special functions are transcendental functions. The docstring of the scipy.special module is well-written,
so we won’t list all functions here. Frequently used ones are:

• Bessel function, such as scipy.special.jn() (nth integer order Bessel function)
• Elliptic function (scipy.special.ellipj() for the Jacobian elliptic function, ...)
• Gamma function: scipy.special.gamma(), also note scipy.special.gammaln() which will give the

log of Gamma to a higher numerical precision.

• Erf, the area under a Gaussian curve: scipy.special.erf()

5.3 Linear algebra operations: scipy.linalg

The scipy.linalg module provides standard linear algebra operations, relying on an underlying efﬁcient
implementation (BLAS, LAPACK).

• The scipy.linalg.det() function computes the determinant of a square matrix:

>>> from scipy import linalg
>>> arr = np.array([[1, 2],
[3, 4]])
...
>>> linalg.det(arr)
-2.0
>>> arr = np.array([[3, 2],
[6, 4]])
...
>>> linalg.det(arr)
0.0
>>> linalg.det(np.ones((3, 4)))
Traceback (most recent call last):
...
ValueError: expected square matrix
Traceback (most recent call last):
...
ValueError: expected square matrix

• The scipy.linalg.inv() function computes the inverse of a square matrix:

>>> arr = np.array([[1, 2],
[3, 4]])
...
>>> iarr = linalg.inv(arr)
>>> iarr
array([[-2. ,

1. ],

[ 1.5, -0.5]])

>>> np.allclose(np.dot(arr, iarr), np.eye(2))
True

Finally computing the inverse of a singular matrix (its determinant is zero) will raise LinAlgError:

>>> arr = np.array([[3, 2],
[6, 4]])
...
>>> linalg.inv(arr)
Traceback (most recent call last):
...
...LinAlgError: singular matrix
Traceback (most recent call last):
...
...LinAlgError: singular matrix

• More advanced operations are available, for example singular-value decomposition (SVD):

5.2. Special functions: scipy.special

103

Scipy lecture notes, Edition 2015.2

>>> arr = np.arange(9).reshape((3, 3)) + np.diag([1, 0, 1])
>>> uarr, spec, vharr = linalg.svd(arr)

The resulting array spectrum is:

>>> spec
array([ 14.88982544,

0.45294236,

0.29654967])

The original matrix can be re-composed by matrix multiplication of the outputs of svd with np.dot:

>>> sarr = np.diag(spec)
>>> svd\_mat = uarr.dot(sarr).dot(vharr)
>>> np.allclose(svd\_mat, arr)
True

SVD is commonly used in statistics and signal processing. Many other standard decompositions (QR,
LU, Cholesky, Schur), as well as solvers for linear systems, are available in scipy.linalg.

5.4 Fast Fourier transforms: scipy.fftpack

The scipy.fftpack module allows to compute fast Fourier transforms. As an illustration, a (noisy) input
signal may look like:

>>> time\_step = 0.02
>>> period = 5.
>>> time\_vec = np.arange(0, 20, time\_step)
>>> sig = np.sin(2 \* np.pi / period \* time\_vec) + \
...

0.5 \* np.random.randn(time\_vec.size)

The observer doesn’t know the signal frequency, only the sampling time step of the signal sig. The
The
signal is supposed to come from a real function so the Fourier transform will be symmetric.
scipy.fftpack.fftfreq() function will generate the sampling frequencies and scipy.fftpack.fft() will
compute the fast Fourier transform:

>>> from scipy import fftpack
>>> sample\_freq = fftpack.fftfreq(sig.size, d=time\_step)
>>> sig\_fft = fftpack.fft(sig)

Because the resulting power is symmetric, only the positive part of the spectrum needs to be used for ﬁnding
the frequency:

>>> pidxs = np.where(sample\_freq > 0)
>>> freqs = sample\_freq[pidxs]
>>> power = np.abs(sig\_fft)[pidxs]

5.4. Fast Fourier transforms: scipy.fftpack

104

Scipy lecture notes, Edition 2015.2

The signal frequency can be found by:

>>> freq = freqs[power.argmax()]
>>> np.allclose(freq, 1./period) # check that correct freq is found
True

Now the high-frequency noise will be removed from the Fourier transformed signal:

>>> sig\_fft[np.abs(sample\_freq) > freq] = 0

The resulting ﬁltered signal can be computed by the scipy.fftpack.ifft() function:

>>> main\_sig = fftpack.ifft(sig\_fft)

The result can be viewed with:

>>> import pylab as plt
>>> plt.figure()

>>> plt.plot(time\_vec, sig)
[]
>>> plt.plot(time\_vec, main\_sig, linewidth=3)
[]
>>> plt.xlabel('Time [s]')

>>> plt.ylabel('Amplitude')


5.4. Fast Fourier transforms: scipy.fftpack

105

0510152025Frequency [Hz]0100200300400500600plower0.050.100.150.200.250.300.350.400.45Peak frequencyScipy lecture notes, Edition 2015.2

numpy.fft
Numpy also has an implementation of FFT (numpy.fft). However, in general the scipy one should be
preferred, as it uses more efﬁcient underlying implementations.

5.4. Fast Fourier transforms: scipy.fftpack

106

05101520Time [s]3210123AmplitudeScipy lecture notes, Edition 2015.2

Worked example: Crude periodicity ﬁnding

5.4. Fast Fourier transforms: scipy.fftpack

107

19001905191019151920Year01020304050607080Population number (·103)harelynxcarrot05101520Period050100150200250300Power (·103)Scipy lecture notes, Edition 2015.2

Worked example: Gaussian image blur

Convolution:

(cid:90)

f1(t ) =

(cid:48)

d t

K (t − t

(cid:48)

) f0(t

(cid:48)

)

˜f1(ω) = ˜K (ω) ˜f0(ω)

5.4. Fast Fourier transforms: scipy.fftpack

108

050100150200250050100150Scipy lecture notes, Edition 2015.2

Exercise: Denoise moon landing image

1. Examine the provided image moonlanding.png, which is heavily contaminated with periodic

noise. In this exercise, we aim to clean up the noise using the Fast Fourier Transform.

2. Load the image using pylab.imread().
3. Find and use the 2-D FFT function in scipy.fftpack, and plot the spectrum (Fourier transform

of) the image. Do you have any trouble visualising the spectrum? If so, why?

4. The spectrum consists of high and low frequency components. The noise is contained in the high-

frequency part of the spectrum, so set some of those components to zero (use array slicing).

5. Apply the inverse Fourier transform to see the resulting image.

5.5 Optimization and fit: scipy.optimize

Optimization is the problem of ﬁnding a numerical solution to a minimization or equality.
The scipy.optimize module provides useful algorithms for function minimization (scalar or multi-
dimensional), curve ﬁtting and root ﬁnding.

>>> from scipy import optimize

Finding the minimum of a scalar function

Let’s deﬁne the following function:

>>> def f(x):
...

return x\*\*2 + 10\*np.sin(x)

and plot it:

>>> x = np.arange(-10, 10, 0.1)
>>> plt.plot(x, f(x))
>>> plt.show()

5.5. Optimization and fit: scipy.optimize

109

Scipy lecture notes, Edition 2015.2

This function has a global minimum around -1.3 and a local minimum around 3.8.

The general and efﬁcient way to ﬁnd a minimum for this function is to conduct a gradient descent starting
from a given initial point. The BFGS algorithm is a good way of doing this:

>>> optimize.fmin\_bfgs(f, 0)
Optimization terminated successfully.

Current function value: -7.945823
Iterations: 5
Function evaluations: 24
Gradient evaluations: 8

array([-1.30644003])

A possible issue with this approach is that, if the function has local minima the algorithm may ﬁnd these local
minima instead of the global minimum depending on the initial point:

>>> optimize.fmin\_bfgs(f, 3, disp=0)
array([ 3.83746663])

If we don’t know the neighborhood of the global minimum to choose the initial point, we need to resort to
costlier global optimization. To ﬁnd the global minimum, we use scipy.optimize.basinhopping() (which
combines a local optimizer with stochastic sampling of starting points for the local optimizer):

New in version 0.12.0: basinhopping was added in version 0.12.0 of Scipy

>>> optimize.basinhopping(f, 0)

nfev: 1725

minimization\_failures: 0

fun: -7.9458233756152845

x: array([-1.30644001])

message: ['requested number of basinhopping iterations completed successfully']

njev: 575
nit: 100

5.5. Optimization and fit: scipy.optimize

110

105051020020406080100120Scipy lecture notes, Edition 2015.2

Another available (but much less efﬁcient) global optimizer is scipy.optimize.brute() (brute force opti-
mization on a grid). More efﬁcient algorithms for different classes of global optimization problems exist, but
this is out of the scope of scipy. Some useful packages for global optimization are OpenOpt, IPOPT, PyGMO
and PyEvolve.

scipy used to contain the routine anneal, it has been deprecated since SciPy 0.14.0 and removed in SciPy
0.16.0.

To ﬁnd the
local minimum,
scipy.optimize.fminbound():

let’s

constraint

the

variable

to the

interval (0, 10) using

>>> xmin\_local = optimize.fminbound(f, 0, 10)
>>> xmin\_local
3.8374671...

Finding minima of function is discussed in more details in the advanced chapter: Mathematical optimization:
ﬁnding minima of functions.

Finding the roots of a scalar function

To ﬁnd a root,
scipy.optimize.fsolve():

i.e.

a point where f(x) = 0, of the function f above we can use for example

>>> root = optimize.fsolve(f, 1) # our initial guess is 1
>>> root
array([ 0.])

Note that only one root is found. Inspecting the plot of f reveals that there is a second root around -2.5. We
ﬁnd the exact value of it by adjusting our initial guess:

>>> root2 = optimize.fsolve(f, -2.5)
>>> root2
array([-2.47948183])

Curve ﬁtting
Suppose we have data sampled from f with some noise:

>>> xdata = np.linspace(-10, 10, num=20)
>>> ydata = f(xdata) + np.random.randn(xdata.size)

Now if we know the functional form of the function from which the samples were drawn (x^2 + sin(x) in
this case) but not the amplitudes of the terms, we can ﬁnd those by least squares curve ﬁtting. First we have to
deﬁne the function to ﬁt:

>>> def f2(x, a, b):
...

return a\*x\*\*2 + b\*np.sin(x)

Then we can use scipy.optimize.curve\_fit() to ﬁnd a and b:

>>> guess = [2, 2]
>>> params, params\_covariance = optimize.curve\_fit(f2, xdata, ydata, guess)
>>> params
array([

10.17808313])

0.99667386,

Now we have found the minima and roots of f and used curve ﬁtting on it, we put all those resuls together in a
single plot:

5.5. Optimization and fit: scipy.optimize

111

Scipy lecture notes, Edition 2015.2

In Scipy >= 0.11 uniﬁed interfaces to all minimization and root ﬁnding algorithms are available:
scipy.optimize.minimize(), scipy.optimize.minimize\_scalar() and scipy.optimize.root().
They allow comparing various algorithms easily through the method keyword.

You can ﬁnd algorithms with the same functionalities for multi-dimensional problems in scipy.optimize.

Exercise: Curve ﬁtting of temperature data

The temperature extremes in Alaska for each month, starting in January, are given by (in
degrees Celcius):

17,

18
max:
min: -62, -59, -56, -46, -32, -18, -9, -13, -25, -46, -52, -58

38, 37,

37,

19,

33,

19,

21,

28,

23,

31,

1. Plot these temperature extremes.
2. Deﬁne a function that can describe min and max temperatures. Hint: this function has

to have a period of 1 year. Hint: include a time offset.

3. Fit this function to the data with scipy.optimize.curve\_fit().
4. Plot the result. Is the ﬁt reasonable? If not, why?
5. Is the time offset for min and max temperatures the same within the ﬁt accuracy?

5.5. Optimization and fit: scipy.optimize

112

1050510x20020406080100120f(x)f(x)Curve fit resultMinimaRootsScipy lecture notes, Edition 2015.2

Exercise: 2-D minimization

The six-hump camelback function

f (x, y) = (4 − 2.1x2 +

x4
3

)x2 + x y + (4y 2 − 4)y 2

has multiple global and local minima. Find the global minima of this function.
Hints:

• Variables can be restricted to -2 < x < 2 and -1 < y < 1.
• Use numpy.meshgrid() and pylab.imshow() to ﬁnd visually the regions.
• Use scipy.optimize.fmin\_bfgs() or another multi-dimensional minimizer.

How many global minima are there, and what is the function value at those points? What
happens for an initial guess of (x, y) = (0, 0)?

See the summary exercise on Non linear least squares curve ﬁtting: application to point extraction in topo-
graphical lidar data for another, more advanced example.

5.6 Statistics and random numbers: scipy.stats

The module scipy.stats contains statistical tools and probabilistic descriptions of random processes. Ran-
dom number generators for various random process can be found in numpy.random.

5.6.1 Histogram and probability density function

Given observations of a random process, their histogram is an estimator of the random process’s PDF (proba-
bility density function):

5.6. Statistics and random numbers: scipy.stats

113

x2.01.51.00.50.00.51.01.52.0y1.00.50.00.51.0f(x, y)210123456Six-hump Camelback functionScipy lecture notes, Edition 2015.2

>>> a = np.random.normal(size=1000)
>>> bins = np.arange(-4, 5)
>>> bins
array([-4, -3, -2, -1,
1,
>>> histogram = np.histogram(a, bins=bins, normed=True)[0]
>>> bins = 0.5\*(bins[1:] + bins[:-1])
>>> bins
array([-3.5, -2.5, -1.5, -0.5,
>>> from scipy import stats
>>> b = stats.norm.pdf(bins) # norm is a distribution

3.5])

1.5,

0.5,

2.5,

4])

0,

3,

2,

>>> plt.plot(bins, histogram)
[]
>>> plt.plot(bins, b)
[]

If we know that the random process belongs to a given family of random processes, such as normal processes,
we can do a maximum-likelihood ﬁt of the observations to estimate the parameters of the underlying distri-
bution. Here we ﬁt a normal process to the observed data:

>>> loc, std = stats.norm.fit(a)
>>> loc
0.0314345570...
>>> std
0.9778613090...

Exercise: Probability distributions

Generate 1000 random variates from a gamma distribution with a shape parameter of 1, then plot a
histogram from those samples. Can you plot the pdf on top (it should match)?
Extra: the distributions have a number of useful methods. Explore them by reading the docstring or by
using IPython tab completion. Can you ﬁnd the shape parameter of 1 back by using the fit method on
your random variates?

5.6.2 Percentiles

The median is the value with half of the observations below, and half above:

5.6. Statistics and random numbers: scipy.stats

114

64202460.000.050.100.150.200.250.300.350.40Scipy lecture notes, Edition 2015.2

>>> np.median(a)
0.04041769593...

It is also called the percentile 50, because 50% of the observation are below it:

>>> stats.scoreatpercentile(a, 50)
0.0404176959...

Similarly, we can calculate the percentile 90:

>>> stats.scoreatpercentile(a, 90)
1.3185699120...

The percentile is an estimator of the CDF: cumulative distribution function.

5.6.3 Statistical tests

A statistical test is a decision indicator. For instance, if we have two sets of observations, that we assume are
generated from Gaussian processes, we can use a T-test to decide whether the two sets of observations are
signiﬁcantly different:

>>> a = np.random.normal(0, 1, size=100)
>>> b = np.random.normal(1, 1, size=10)
>>> stats.ttest\_ind(a, b)
(array(-3.177574054...), 0.0019370639...)

The resulting output is composed of:

• The T statistic value: it is a number the sign of which is proportional to the difference between the two

random processes and the magnitude is related to the signiﬁcance of this difference.

• the p value: the probability of both processes being identical. If it is close to 1, the two process are almost
certainly identical. The closer it is to zero, the more likely it is that the processes have different means.

See also:

The chapter on statistics introduces much more elaborate tools for statistical testing and statistical data load-
ing and visualization outside of scipy.

5.7 Interpolation: scipy.interpolate

The scipy.interpolate is useful for ﬁtting a function from experimental data and thus evaluating points
where no measure exists. The module is based on the FITPACK Fortran subroutines from the netlib project.

By imagining experimental data close to a sine function:

>>> measured\_time = np.linspace(0, 1, 10)
>>> noise = (np.random.random(10)\*2 - 1) \* 1e-1
>>> measures = np.sin(2 \* np.pi \* measured\_time) + noise

The scipy.interpolate.interp1d class can build a linear interpolation function:

>>> from scipy.interpolate import interp1d
>>> linear\_interp = interp1d(measured\_time, measures)

Then the scipy.interpolate.linear\_interp instance needs to be evaluated at the time of interest:

>>> computed\_time = np.linspace(0, 1, 50)
>>> linear\_results = linear\_interp(computed\_time)

A cubic interpolation can also be selected by providing the kind optional keyword argument:

5.7.

Interpolation: scipy.interpolate

115

Scipy lecture notes, Edition 2015.2

>>> cubic\_interp = interp1d(measured\_time, measures, kind='cubic')
>>> cubic\_results = cubic\_interp(computed\_time)

The results are now gathered on the following Matplotlib ﬁgure:

scipy.interpolate.interp2d is similar to scipy.interpolate.interp1d, but for 2-D arrays. Note that
for the interp family, the computed time must stay within the measured time range. See the summary exercise
on Maximum wind speed prediction at the Sprogø station for a more advance spline interpolation example.

5.8 Numerical integration: scipy.integrate

The most generic integration routine is scipy.integrate.quad():

>>> from scipy.integrate import quad
>>> res, err = quad(np.sin, 0, np.pi/2)
>>> np.allclose(res, 1)
True
>>> np.allclose(err, 1 - res)
True

Others integration schemes are available with fixed\_quad, quadrature, romberg.
scipy.integrate also features routines for integrating Ordinary Differential Equations (ODE). In particular,
scipy.integrate.odeint() is a general-purpose integrator using LSODA (Livermore Solver for Ordinary
Differential equations with Automatic method switching for stiff and non-stiff problems), see the ODEPACK
Fortran library for more details.
odeint solves ﬁrst-order ODE systems of the form:

dy/dt = rhs(y1, y2, .., t0,...)

5.8. Numerical integration: scipy.integrate

116

0.00.20.40.60.81.01.51.00.50.00.51.0measureslinear interpcubic interpScipy lecture notes, Edition 2015.2

As an introduction, let us solve the ODE dy/dt = -2y between t = 0..4, with the initial condition y(t=0)
= 1. First the function computing the derivative of the position needs to be deﬁned:

>>> def calc\_derivative(ypos, time, counter\_arr):
...
...
...

counter\_arr += 1
return -2 \* ypos

An extra argument counter\_arr has been added to illustrate that the function may be called several times for
a single time step, until solver convergence. The counter array is deﬁned as:

>>> counter = np.zeros((1,), dtype=np.uint16)

The trajectory will now be computed:

>>> from scipy.integrate import odeint
>>> time\_vec = np.linspace(0, 4, 40)
>>> yvec, info = odeint(calc\_derivative, 1, time\_vec,
...

args=(counter,), full\_output=True)

Thus the derivative function has been called more than 40 times (which was the number of time steps):

>>> counter
array([129], dtype=uint16)

and the cumulative number of iterations for each of the 10 ﬁrst time steps can be obtained by:

>>> info['nfe'][:10]
array([31, 35, 43, 49, 53, 57, 59, 63, 65, 69], dtype=int32)

Note that the solver requires more iterations for the ﬁrst time step. The solution yvec for the trajectory can
now be plotted:

Another example with scipy.integrate.odeint() will be a damped spring-mass oscillator (2nd order os-
cillator). The position of a mass attached to a spring obeys the 2nd order ODE y’’ + 2 eps wo y’ + wo^2
y = 0 with wo^2 = k/m with k the spring constant, m the mass and eps=c/(2 m wo) with c the damping
coefﬁcient. For this example, we choose the parameters as:

>>> mass = 0.5 # kg
>>> kspring = 4
>>> cviscous = 0.4

# N/m

# N s/m

so the system will be underdamped, because:

5.8. Numerical integration: scipy.integrate

117

0.00.51.01.52.02.53.03.54.0Time [s]0.00.20.40.60.81.0y position [m]Scipy lecture notes, Edition 2015.2

>>> eps = cviscous / (2 \* mass \* np.sqrt(kspring/mass))
>>> eps < 1
True

For the scipy.integrate.odeint() solver the 2nd order equation needs to be transformed in a system of
two ﬁrst-order equations for the vector Y=(y, y’). It will be convenient to deﬁne nu = 2 eps \* wo = c /
m and om = wo^2 = k/m:

>>> nu\_coef = cviscous / mass
>>> om\_coef = kspring / mass

Thus the function will calculate the velocity and acceleration by:

return (yvec[1], -nuc \* yvec[1] - omc \* yvec[0])

>>> def calc\_deri(yvec, time, nuc, omc):
...
...
>>> time\_vec = np.linspace(0, 10, 100)
>>> yarr = odeint(calc\_deri, (1, 0), time\_vec, args=(nu\_coef, om\_coef))

The ﬁnal position and velocity are shown on the following Matplotlib ﬁgure:

There is no Partial Differential Equations (PDE) solver in Scipy. Some Python packages for solving PDE’s are
available, such as ﬁpy or SfePy.

5.9 Signal processing: scipy.signal

>>> from scipy import signal

• scipy.signal.detrend(): remove linear trend from signal:

>>> t = np.linspace(0, 5, 100)
>>> x = t + np.random.normal(size=100)

>>> plt.plot(t, x, linewidth=3)
[]
>>> plt.plot(t, signal.detrend(x), linewidth=3)
[]

5.9. Signal processing: scipy.signal

118

02468102.52.01.51.00.50.00.51.01.5yy'Scipy lecture notes, Edition 2015.2

• scipy.signal.resample(): resample a signal to n points using FFT.

>>> t = np.linspace(0, 5, 100)
>>> x = np.sin(t)

>>> plt.plot(t, x, linewidth=3)
[]
>>> plt.plot(t[::2], signal.resample(x, 50), 'ko')
[]

Notice how on the side of the window the resampling is less accurate and has a rippling effect.

• scipy.signal has many window functions: scipy.signal.hamming(), scipy.signal.bartlett(),

scipy.signal.blackman()...

• scipy.signal

has

ﬁltering

(median

ﬁlter

scipy.signal.medfilt(),

scipy.signal.wiener()), but we will discuss this in the image section.

5.9. Signal processing: scipy.signal

Wiener

119

01234542024680123451.51.00.50.00.51.01.5Scipy lecture notes, Edition 2015.2

5.10 Image processing: scipy.ndimage

The submodule dedicated to image processing in scipy is scipy.ndimage.

>>> from scipy import ndimage

Image processing routines may be sorted according to the category of processing they perform.

5.10.1 Geometrical transformations on images

Changing orientation, resolution, ..

>>> from scipy import misc
>>> lena = misc.lena()
>>> shifted\_lena = ndimage.shift(lena, (50, 50))
>>> shifted\_lena2 = ndimage.shift(lena, (50, 50), mode='nearest')
>>> rotated\_lena = ndimage.rotate(lena, 30)
>>> cropped\_lena = lena[50:-50, 50:-50]
>>> zoomed\_lena = ndimage.zoom(lena, 2)
>>> zoomed\_lena.shape
(1024, 1024)

>>> plt.subplot(151)


>>> plt.imshow(shifted\_lena, cmap=plt.cm.gray)


>>> plt.axis('off')
(-0.5, 511.5, 511.5, -0.5)

>>> # etc.

5.10.2 Image filtering

>>> from scipy import misc
>>> lena = misc.lena()
>>> import numpy as np
>>> noisy\_lena = np.copy(lena).astype(np.float)
>>> noisy\_lena += lena.std() \* 0.5 \* np.random.standard\_normal(lena.shape)
>>> blurred\_lena = ndimage.gaussian\_filter(noisy\_lena, sigma=3)
>>> median\_lena = ndimage.median\_filter(blurred\_lena, size=5)
>>> from scipy import signal
>>> wiener\_lena = signal.wiener(blurred\_lena, (5, 5))

Many other ﬁlters in scipy.ndimage.filters and scipy.signal can be applied to images.

Exercise

Compare histograms for the different ﬁltered images.

5.10.

Image processing: scipy.ndimage

120

Scipy lecture notes, Edition 2015.2

5.10.3 Mathematical morphology

Mathematical morphology is a mathematical theory that stems from set theory. It characterizes and trans-
forms geometrical structures. Binary (black and white) images, in particular, can be transformed using this
theory: the sets to be transformed are the sets of neighboring non-zero-valued pixels. The theory was also
extended to gray-valued images.

Elementary mathematical-morphology operations use a structuring element in order to modify other geomet-
rical structures.

Let us ﬁrst generate a structuring element

>>> el = ndimage.generate\_binary\_structure(2, 1)
>>> el
array([[False, True, False],

[...True, True, True],
[False, True, False]], dtype=bool)

>>> el.astype(np.int)
array([[0, 1, 0],
[1, 1, 1],
[0, 1, 0]])

• Erosion

>>> a = np.zeros((7, 7), dtype=np.int)
>>> a[1:6, 2:5] = 1
>>> a
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])

>>> ndimage.binary\_erosion(a).astype(a.dtype)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 1, 0, 0, 0],

5.10.

Image processing: scipy.ndimage

121

Scipy lecture notes, Edition 2015.2

[0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])

>>> #Erosion removes objects smaller than the structure
>>> ndimage.binary\_erosion(a, structure=np.ones((5,5))).astype(a.dtype)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])

• Dilation

>>> a = np.zeros((5, 5))
>>> a[2, 2] = 1
>>> a
array([[ 0.,
[ 0.,
[ 0.,
[ 0.,
[ 0.,

0.,
0.,
0.,
0.,
0.,

0.,
0.,
1.,
0.,
0.,

0.,
0.,
0.,
0.,
0.,

0.],
0.],
0.],
0.],
0.]])

>>> ndimage.binary\_dilation(a).astype(a.dtype)
array([[ 0.,
[ 0.,
[ 0.,
[ 0.,
[ 0.,

0.],
0.],
0.],
0.],
0.]])

0.,
0.,
1.,
0.,
0.,

0.,
0.,
1.,
0.,
0.,

0.,
1.,
1.,
1.,
0.,

• Opening

>>> a = np.zeros((5, 5), dtype=np.int)
>>> a[1:4, 1:4] = 1
>>> a[4, 4] = 1
>>> a
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 1]])

>>> # Opening removes small objects
>>> ndimage.binary\_opening(a, structure=np.ones((3, 3))).astype(np.int)
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 0]])

>>> # Opening can also smooth corners
>>> ndimage.binary\_opening(a).astype(np.int)
array([[0, 0, 0, 0, 0],
[0, 0, 1, 0, 0],
[0, 1, 1, 1, 0],
[0, 0, 1, 0, 0],
[0, 0, 0, 0, 0]])

• Closing: ndimage.binary\_closing

Exercise

Check that opening amounts to eroding, then dilating.

5.10.

Image processing: scipy.ndimage

122

An opening operation removes small structures, while a closing operation ﬁlls small holes. Such operations
can therefore be used to “clean” an image.

Scipy lecture notes, Edition 2015.2

>>> a = np.zeros((50, 50))
>>> a[10:-10, 10:-10] = 1
>>> a += 0.25 \* np.random.standard\_normal(a.shape)
>>> mask = a>=0.5
>>> opened\_mask = ndimage.binary\_opening(mask)
>>> closed\_mask = ndimage.binary\_closing(opened\_mask)

Exercise

Check that the area of the reconstructed square is smaller than the area of the initial square.
(The opposite would occur if the closing step was performed before the opening).

For gray-valued images, eroding (resp. dilating) amounts to replacing a pixel by the minimal (resp. maximal)
value among pixels covered by the structuring element centered on the pixel of interest.

>>> a = np.zeros((7, 7), dtype=np.int)
>>> a[1:6, 1:6] = 3
>>> a[4, 4] = 2; a[2, 3] = 1
>>> a
array([[0, 0, 0, 0, 0, 0, 0],
[0, 3, 3, 3, 3, 3, 0],
[0, 3, 3, 1, 3, 3, 0],
[0, 3, 3, 3, 3, 3, 0],
[0, 3, 3, 3, 2, 3, 0],
[0, 3, 3, 3, 3, 3, 0],
[0, 0, 0, 0, 0, 0, 0]])

>>> ndimage.grey\_erosion(a, size=(3, 3))
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 3, 2, 2, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])

5.10.4 Measurements on images

Let us ﬁrst generate a nice synthetic binary image.

>>> x, y = np.indices((100, 100))
>>> sig = np.sin(2\*np.pi\*x/50.) \* np.sin(2\*np.pi\*y/50.) \* (1+x\*y/50.\*\*2)\*\*2
>>> mask = sig > 1

Now we look for various information about the objects in the image:

>>> labels, nb = ndimage.label(mask)
>>> nb
8

5.10.

Image processing: scipy.ndimage

123

Scipy lecture notes, Edition 2015.2

>>> areas = ndimage.sum(mask, labels, range(1, labels.max()+1))
>>> areas
array([ 190.,
>>> maxima = ndimage.maximum(sig, labels, range(1, labels.max()+1))
>>> maxima
array([

424.])

190.,

549.,

424.,

278.,

459.,

45.,

2.49611818,
5.51954079])

1.80238238,
6.71673619,

5.51954079,
16.76547217,

1.13527605,
1.80238238,
>>> ndimage.find\_objects(labels==4)
[(slice(30L, 48L, None), slice(30L, 48L, None))]
>>> sl = ndimage.find\_objects(labels==4)
>>> import pylab as pl
>>> pl.imshow(sig[sl[0]])


See the summary exercise on Image processing application: counting bubbles and unmolten grains for a more
advanced example.

5.11 Summary exercises on scientific computing

The summary exercises use mainly Numpy, Scipy and Matplotlib. They provide some real-life examples of sci-
entiﬁc computing with Python. Now that the basics of working with Numpy and Scipy have been introduced,
the interested user is invited to try these exercises.

5.11.1 Maximum wind speed prediction at the Sprogø station

The exercise goal is to predict the maximum wind speed occurring every 50 years even if no measure exists
for such a period. The available data are only measured over 21 years at the Sprogø meteorological station
located in Denmark. First, the statistical steps will be given and then illustrated with functions from the
scipy.interpolate module. At the end the interested readers are invited to compute results from raw data and
in a slightly different approach.

Statistical approach

The annual maxima are supposed to ﬁt a normal probability density function. However such function is not
going to be estimated because it gives a probability from a wind speed maxima. Finding the maximum wind
speed occurring every 50 years requires the opposite approach, the result needs to be found from a deﬁned
probability. That is the quantile function role and the exercise goal will be to ﬁnd it. In the current model, it is
supposed that the maximum wind speed occurring every 50 years is deﬁned as the upper 2% quantile.

By deﬁnition, the quantile function is the inverse of the cumulative distribution function. The latter describes
the probability distribution of an annual maxima. In the exercise, the cumulative probability p\_i for a given
year i is deﬁned as p\_i = i/(N+1) with N = 21, the number of measured years. Thus it will be possible to
calculate the cumulative probability of every measured wind speed maxima. From those experimental points,
the scipy.interpolate module will be very useful for ﬁtting the quantile function. Finally the 50 years maxima is
going to be evaluated from the cumulative probability of the 2% quantile.

5.11. Summary exercises on scientific computing

124

Scipy lecture notes, Edition 2015.2

Computing the cumulative probabilities

The annual wind speeds maxima have already been computed and saved in the numpy format in the ﬁle
examples/max-speeds.npy, thus they will be loaded by using numpy:

>>> import numpy as np
>>> max\_speeds = np.load('intro/summary-exercises/examples/max-speeds.npy')
>>> years\_nb = max\_speeds.shape[0]

Following the cumulative probability deﬁnition p\_i from the previous section, the corresponding values will
be:

>>> cprob = (np.arange(years\_nb, dtype=np.float32) + 1)/(years\_nb + 1)

and they are assumed to ﬁt the given wind speeds:

>>> sorted\_max\_speeds = np.sort(max\_speeds)

Prediction with UnivariateSpline

In this section the quantile function will be estimated by using the UnivariateSpline class which can
represent a spline from points. The default behavior is to build a spline of degree 3 and points can
have different weights according to their reliability. Variants are InterpolatedUnivariateSpline and
LSQUnivariateSpline on which errors checking is going to change.
In case a 2D spline is wanted, the
BivariateSpline class family is provided. All those classes for 1D and 2D splines use the FITPACK For-
tran subroutines, that’s why a lower library access is available through the splrep and splev functions for
respectively representing and evaluating a spline. Moreover interpolation functions without the use of FIT-
PACK parameters are also provided for simpler use (see interp1d, interp2d, barycentric\_interpolate
and so on).
For the Sprogø maxima wind speeds, the UnivariateSpline will be used because a spline of degree 3 seems
to correctly ﬁt the data:

>>> from scipy.interpolate import UnivariateSpline
>>> quantile\_func = UnivariateSpline(cprob, sorted\_max\_speeds)

The quantile function is now going to be evaluated from the full range of probabilities:

>>> nprob = np.linspace(0, 1, 1e2)
>>> fitted\_max\_speeds = quantile\_func(nprob)

In the current model, the maximum wind speed occurring every 50 years is deﬁned as the upper 2% quantile.
As a result, the cumulative probability value will be:

>>> fifty\_prob = 1. - 0.02

So the storm wind speed occurring every 50 years can be guessed by:

>>> fifty\_wind = quantile\_func(fifty\_prob)
>>> fifty\_wind
array(32.97989825...)

The results are now gathered on a Matplotlib ﬁgure:

Exercise with the Gumbell distribution

The interested readers are now invited to make an exercise by using the wind speeds measured over 21 years.
The measurement period is around 90 minutes (the original period was around 10 minutes but the ﬁle size
has been reduced for making the exercise setup easier). The data are stored in numpy format inside the ﬁle
examples/sprog-windspeeds.npy. Do not look at the source code for the plots until you have completed
the exercise.

5.11. Summary exercises on scientific computing

125

Scipy lecture notes, Edition 2015.2

Figure 5.1: Solution: Python source ﬁle

5.11. Summary exercises on scientific computing

126

• The ﬁrst step will be to ﬁnd the annual maxima by using numpy and plot them as a matplotlib bar ﬁgure.

Scipy lecture notes, Edition 2015.2

Figure 5.2: Solution: Python source ﬁle

• The second step will be to use the Gumbell distribution on cumulative probabilities p\_i deﬁned as
-log( -log(p\_i) ) for ﬁtting a linear quantile function (remember that you can deﬁne the degree
of the UnivariateSpline). Plotting the annual maxima versus the Gumbell distribution should give
you the following ﬁgure.

• The last step will be to ﬁnd 34.23 m/s for the maximum wind speed occurring every 50 years.

5.11.2 Non linear least squares curve fitting: application to point extraction in

topographical lidar data

The goal of this exercise is to ﬁt a model to some data. The data used in this tutorial are lidar data and are
described in details in the following introductory paragraph. If you’re impatient and want to practice now,
please skip it and go directly to Loading and visualization.

Introduction

Lidars systems are optical rangeﬁnders that analyze property of scattered light to measure distances. Most of
them emit a short light impulsion towards a target and record the reﬂected signal. This signal is then processed
to extract the distance between the lidar system and the target.

Topographical lidar systems are such systems embedded in airborne platforms. They measure distances be-
tween the platform and the Earth, so as to deliver information on the Earth’s topography (see 1 for more de-

1 Mallet, C. and Bretar, F. Full-Waveform Topographic Lidar: State-of-the-Art. ISPRS Journal of Photogrammetry and Remote Sensing

64(1), pp.1-16, January 2009 http://dx.doi.org/10.1016/j.isprsjprs.2008.09.007

5.11. Summary exercises on scientific computing

127

Scipy lecture notes, Edition 2015.2

Figure 5.3: Solution: Python source ﬁle

5.11. Summary exercises on scientific computing

128

Scipy lecture notes, Edition 2015.2

tails).

In this tutorial, the goal is to analyze the waveform recorded by the lidar system 2. Such a signal contains peaks
whose center and amplitude permit to compute the position and some characteristics of the hit target. When
the footprint of the laser beam is around 1m on the Earth surface, the beam can hit multiple targets during the
two-way propagation (for example the ground and the top of a tree or building). The sum of the contributions
of each target hit by the laser beam then produces a complex signal with multiple peaks, each one containing
information about one target.

One state of the art method to extract information from these data is to decompose them in a sum of Gaussian
functions where each function represents the contribution of a target hit by the laser beam.
Therefore, we use the scipy.optimize module to ﬁt a waveform to one or a sum of Gaussian functions.

Loading and visualization

Load the ﬁrst waveform using:

>>> import numpy as np
>>> waveform\_1 = np.load('data/waveform\_1.npy')

and visualize it:

>>> import matplotlib.pyplot as plt
>>> t = np.arange(len(waveform\_1))
>>> plt.plot(t, waveform\_1)
[]
>>> plt.show()

As you can notice, this waveform is a 80-bin-length signal with a single peak.

2 The data used for this tutorial are part of the demonstration data available for the FullAnalyze software and were kindly provided by

the GIS DRAIX.

5.11. Summary exercises on scientific computing

129

Scipy lecture notes, Edition 2015.2

Fitting a waveform with a simple Gaussian model

The signal is very simple and can be modeled as a single Gaussian function and an offset corresponding to the
background noise. To ﬁt the signal with the function, we must:

• deﬁne the model

• propose an initial solution
• call scipy.optimize.leastsq

Model

A Gaussian function deﬁned by

B + A exp

(cid:182)2(cid:190)

(cid:189)

−

(cid:181) t − µ
σ

can be deﬁned in python by:

>>> def model(t, coeffs):
...

return coeffs[0] + coeffs[1] \* np.exp( - ((t-coeffs[2])/coeffs[3])\*\*2 )

where

• coeffs[0] is B (noise)
• coeffs[1] is A (amplitude)
• coeffs[2] is µ (center)
• coeffs[3] is σ (width)

Initial solution

An approximative initial solution that we can ﬁnd from looking at the graph is for instance:

>>> x0 = np.array([3, 30, 15, 1], dtype=float)

Fit

scipy.optimize.leastsq minimizes the sum of squares of the function given as an argument. Basically, the
function to minimize is the residuals (the difference between the data and the model):

>>> def residuals(coeffs, y, t):
...

return y - model(t, coeffs)

So let’s get our solution by calling scipy.optimize.leastsq() with the following arguments:

• the function to minimize

• an initial solution

• the additional arguments to pass to the function

>>> from scipy.optimize import leastsq
>>> x, flag = leastsq(residuals, x0, args=(waveform\_1, t))
>>> print(x)
2.70363341
[

15.47924562

3.05636228]

27.82020742

And visualize the solution:

5.11. Summary exercises on scientific computing

130

Scipy lecture notes, Edition 2015.2

>>> plt.plot(t, waveform\_1, t, model(t, x))
[, ]
>>> plt.legend(['waveform', 'model'])

>>> plt.show()

Remark: from scipy v0.8 and above, you should rather use scipy.optimize.curve\_fit() which takes the
model and the data as arguments, so you don’t need to deﬁne the residuals any more.

Going further

• Try with a more complex waveform (for instance data/waveform\_2.npy) that contains three signiﬁcant
peaks. You must adapt the model which is now a sum of Gaussian functions instead of only one Gaussian
peak.

• In some cases, writing an explicit function to compute the Jacobian is faster than letting leastsq esti-
mate it numerically. Create a function to compute the Jacobian of the residuals and use it as an input for
leastsq.

• When we want to detect very small peaks in the signal, or when the initial guess is too far from a good
solution, the result given by the algorithm is often not satisfying. Adding constraints to the parameters
of the model enables to overcome such limitations. An example of a priori knowledge we can add is the
sign of our variables (which are all positive).

With the following initial solution:

>>> x0 = np.array([3, 50, 20, 1], dtype=float)

compare
scipy.optimize.fmin\_slsqp() when adding boundary constraints.

scipy.optimize.leastsq()

result

the

of

and what

you

can

get with

5.11. Summary exercises on scientific computing

131

5.11.3 Image processing application: counting bubbles and unmolten grains

Scipy lecture notes, Edition 2015.2

Statement of the problem

1. Open the image ﬁle MV\_HFV\_012.jpg and display it. Browse through the keyword arguments in the doc-
string of imshow to display the image with the “right” orientation (origin in the bottom left corner, and not the
upper left corner as for standard arrays).

This Scanning Element Microscopy image shows a glass sample (light gray matrix) with some bubbles (on
black) and unmolten sand grains (dark gray). We wish to determine the fraction of the sample covered by
these three phases, and to estimate the typical size of sand grains and bubbles, their sizes, etc.

2. Crop the image to remove the lower panel with measure information.

3. Slightly ﬁlter the image with a median ﬁlter in order to reﬁne its histogram. Check how the histogram
changes.

4. Using the histogram of the ﬁltered image, determine thresholds that allow to deﬁne masks for sand pixels,
glass pixels and bubble pixels. Other option (homework): write a function that determines automatically the
thresholds from the minima of the histogram.

5. Display an image in which the three phases are colored with three different colors.

6. Use mathematical morphology to clean the different phases.

7. Attribute labels to all bubbles and sand grains, and remove from the sand mask grains that are smaller than
10 pixels. To do so, use ndimage.sum or np.bincount to compute the grain sizes.

8. Compute the mean size of bubbles.

Proposed solution

>>> import numpy as np
>>> import pylab as pl
>>> from scipy import ndimage

5.11. Summary exercises on scientific computing

132

5.11.4 Example of solution for the image processing exercise: unmolten grains in

glass

Scipy lecture notes, Edition 2015.2

1. Open the image ﬁle MV\_HFV\_012.jpg and display it. Browse through the keyword arguments in the
docstring of imshow to display the image with the “right” orientation (origin in the bottom left corner,
and not the upper left corner as for standard arrays).

>>> dat = pl.imread('data/MV\_HFV\_012.jpg')

2. Crop the image to remove the lower panel with measure information.

>>> dat = dat[:-60]

3. Slightly ﬁlter the image with a median ﬁlter in order to reﬁne its histogram. Check how the histogram

changes.

>>> filtdat = ndimage.median\_filter(dat, size=(7,7))
>>> hi\_dat = np.histogram(dat, bins=np.arange(256))
>>> hi\_filtdat = np.histogram(filtdat, bins=np.arange(256))

5.11. Summary exercises on scientific computing

133

Scipy lecture notes, Edition 2015.2

4. Using the histogram of the ﬁltered image, determine thresholds that allow to deﬁne masks for sand pix-
els, glass pixels and bubble pixels. Other option (homework): write a function that determines automat-
ically the thresholds from the minima of the histogram.

>>> void = filtdat <= 50
>>> sand = np.logical\_and(filtdat > 50, filtdat <= 114)
>>> glass = filtdat > 114

5. Display an image in which the three phases are colored with three different colors.

>>> phases = void.astype(np.int) + 2\*glass.astype(np.int) + 3\*sand.astype(np.int)

5.11. Summary exercises on scientific computing

134

Scipy lecture notes, Edition 2015.2

6. Use mathematical morphology to clean the different phases.

>>> sand\_op = ndimage.binary\_opening(sand, iterations=2)

7. Attribute labels to all bubbles and sand grains, and remove from the sand mask grains that are smaller

than 10 pixels. To do so, use ndimage.sum or np.bincount to compute the grain sizes.

>>> sand\_labels, sand\_nb = ndimage.label(sand\_op)
>>> sand\_areas = np.array(ndimage.sum(sand\_op, sand\_labels, np.arange(sand\_labels.max()+1)))
>>> mask = sand\_areas > 100
>>> remove\_small\_sand = mask[sand\_labels.ravel()].reshape(sand\_labels.shape)

8. Compute the mean size of bubbles.

>>> bubbles\_labels, bubbles\_nb = ndimage.label(void)
>>> bubbles\_areas = np.bincount(bubbles\_labels.ravel())[1:]
>>> mean\_bubble\_size = bubbles\_areas.mean()
>>> median\_bubble\_size = np.median(bubbles\_areas)
>>> mean\_bubble\_size, median\_bubble\_size

5.11. Summary exercises on scientific computing

135

(1699.875, 65.0)

Scipy lecture notes, Edition 2015.2

5.11. Summary exercises on scientific computing

136

CHAPTER 6

Getting help and finding documentation

Author: Emmanuelle Gouillart

Rather than knowing all functions in Numpy and Scipy, it is important to ﬁnd rapidly information throughout
the documentation and the available help. Here are some ways to get information:

• In Ipython, help function opens the docstring of the function. Only type the beginning of the func-

tion’s name and use tab completion to display the matching functions.

In [204]: help np.v
np.vander
np.var

np.vdot
np.vectorize

In [204]: help np.vander

np.version
np.void

np.void0
np.vsplit

np.vstack

In Ipython it
ever one can always open a second Ipython shell

is not possible to open a separated window for help and documentation; how-
to display help and docstrings...

just

• Numpy’s and Scipy’s documentations can be browsed online on http://docs.scipy.org/doc.
inside the reference documentation of the two packages

The search button is quite useful
(http://docs.scipy.org/doc/numpy/reference/ and http://docs.scipy.org/doc/scipy/reference/).

Tutorials on various topics as well as the complete API with all docstrings are found on this website.

• Numpy’s and Scipy’s documentation is enriched and updated on a regular basis by users on a wiki
http://docs.scipy.org/doc/numpy/. As a result, some docstrings are clearer or more detailed on the wiki,

137

Scipy lecture notes, Edition 2015.2

and you may want to read directly the documentation on the wiki instead of the ofﬁcial documentation
website. Note that anyone can create an account on the wiki and write better documentation; this is an
easy way to contribute to an open-source project and improve the tools you are using!

• Scipy central http://central.scipy.org/ gives recipes on many common problems frequently encoun-

tered, such as ﬁtting data points, solving ODE, etc.

• Matplotlib’s website http://matplotlib.org/ features a very nice gallery with a large number of plots, each
of them shows both the source code and the resulting plot. This is very useful for learning by example.
More standard documentation is also available.

Finally, two more “technical” possibilities are useful as well:

• In Ipython, the magical function %psearch search for objects matching patterns. This is useful if, for

example, one does not know the exact name of a function.

In [3]: import numpy as np
In [4]: %psearch np.diag\*
np.diag
np.diagflat
np.diagonal

• numpy.lookfor looks for keywords inside the docstrings of speciﬁed modules.

In [45]: numpy.lookfor('convolution')
Search results for 'convolution'
--------------------------------
numpy.convolve

Returns the discrete, linear convolution of two one-dimensional

sequences.
numpy.bartlett

Return the Bartlett window.

numpy.correlate

Discrete, linear correlation of two 1-dimensional sequences.

In [46]: numpy.lookfor('remove', module='os')
Search results for 'remove'
---------------------------
os.remove

remove(path)

os.removedirs

removedirs(path)

os.rmdir

rmdir(path)

os.unlink

unlink(path)

os.walk

Directory tree generator.

• If everything listed above fails (and Google doesn’t have the answer)... don’t despair! Write to the mailing-
list suited to your problem: you should have a quick answer if you describe your problem well. Experts
on scientiﬁc python often give very enlightening explanations on the mailing-list.

– Numpy discussion (numpy-discussion@scipy.org): all about numpy arrays, manipulating them,

indexation questions, etc.

138

Scipy lecture notes, Edition 2015.2

– SciPy Users List (scipy-user@scipy.org): scientiﬁc computing with Python, high-level data process-

ing, in particular with the scipy package.

– matplotlib-users@lists.sourceforge.net for plotting with matplotlib.

139

Part II

Advanced topics

140

This part of the Scipy lecture notes is dedicated to advanced usage. It strives to educate the proﬁcient Python
coder to be an expert and tackles various speciﬁc topics.

Scipy lecture notes, Edition 2015.2

141

CHAPTER 7

Advanced Python Constructs

Author Zbigniew J˛edrzejewski-Szmek

This section covers some features of the Python language which can be considered advanced — in the sense
that not every language has them, and also in the sense that they are more useful in more complicated pro-
grams or libraries, but not in the sense of being particularly specialized, or particularly complicated.

It is important to underline that this chapter is purely about the language itself — about features supported
through special syntax complemented by functionality of the Python stdlib, which could not be implemented
through clever external modules.

The process of developing the Python programming language, its syntax, is very transparent; proposed
changes are evaluated from various angles and discussed via Python Enhancement Proposals — PEPs. As a
result, features described in this chapter were added after it was shown that they indeed solve real problems
and that their use is as simple as possible.

Chapter contents

• Iterators, generator expressions and generators

– Iterators
– Generator expressions
– Generators
– Bidirectional communication
– Chaining generators

• Decorators

– Replacing or tweaking the original object
– Decorators implemented as classes and as functions
– Copying the docstring and other attributes of the original function
– Examples in the standard library
– Deprecation of functions
– A while-loop removing decorator
– A plugin registration system

• Context managers

– Catching exceptions
– Using generators to deﬁne context managers

7.1 Iterators, generator expressions and generators

7.1.1 Iterators

142

Scipy lecture notes, Edition 2015.2

Simplicity

Duplication of effort is wasteful, and replacing the various home-grown approaches with a standard fea-
ture usually ends up making things more readable, and interoperable as well.

Guido van Rossum — Adding Optional Static Typing to Python

An iterator is an object adhering to the iterator protocol — basically this means that it has a next method,
which, when called, returns the next item in the sequence, and when there’s nothing to return, raises the
StopIteration exception.

An iterator object allows to loop just once. It holds the state (position) of a single iteration, or from the other
side, each loop over a sequence requires a single iterator object. This means that we can iterate over the same
sequence more than once concurrently. Separating the iteration logic from the sequence allows us to have
more than one way of iteration.
Calling the \_\_iter\_\_ method on a container to create an iterator object is the most straightforward way to get
hold of an iterator. The iter function does that for us, saving a few keystrokes.

# note that ... varies: these are different objects

>>> nums = [1, 2, 3]
>>> iter(nums)
<...iterator object at ...>
>>> nums.\_\_iter\_\_()
<...iterator object at ...>
>>> nums.\_\_reversed\_\_()
<...reverseiterator object at ...>

>>> it = iter(nums)
>>> next(it)
1
>>> next(it)
2
>>> next(it)
3
>>> next(it)
Traceback (most recent call last):

File "", line 1, in 

StopIteration
Traceback (most recent call last):

File "", line 1, in 

StopIteration

When used in a loop, StopIteration is swallowed and causes the loop to ﬁnish. But with explicit invocation,
we can see that once the iterator is exhausted, accessing it raises an exception.
Using the for..in loop also uses the \_\_iter\_\_ method. This allows us to transparently start the iteration over a
sequence. But if we already have the iterator, we want to be able to use it in an for loop in the same way. In
order to achieve this, iterators in addition to next are also required to have a method called \_\_iter\_\_ which
returns the iterator (self).

Support for iteration is pervasive in Python: all sequences and unordered containers in the standard library
allow this. The concept is also stretched to other things: e.g. file objects support iteration over lines.

>>> f = open('/etc/fstab')
>>> f is f.\_\_iter\_\_()
True

The file is an iterator itself and it’s \_\_iter\_\_ method doesn’t create a separate object: only a single thread of
sequential access is allowed.

7.1.

Iterators, generator expressions and generators

143

Scipy lecture notes, Edition 2015.2

7.1.2 Generator expressions

A second way in which iterator objects are created is through generator expressions, the basis for list compre-
hensions. To increase clarity, a generator expression must always be enclosed in parentheses or an expression.
If round parentheses are used, then a generator iterator is created. If rectangular parentheses are used, the pro-
cess is short-circuited and we get a list.

>>> (i for i in nums)
 at 0x...>
>>> [i for i in nums]
[1, 2, 3]
>>> list(i for i in nums)
[1, 2, 3]

The list comprehension syntax also extends to dictionary and set comprehensions. A set is created when the
generator expression is enclosed in curly braces. A dict is created when the generator expression contains
“pairs” of the form key:value:

>>> {i for i in range(3)}
set([0, 1, 2])
>>> {i:i\*\*2 for i in range(3)}
{0: 0, 1: 1, 2: 4}

One gotcha should be mentioned: in old Pythons the index variable (i) would leak, and in versions >= 3 this is
ﬁxed.

7.1.3 Generators

Generators

A generator is a function that produces a sequence of results instead of a single value.

David Beazley — A Curious Course on Coroutines and Concurrency

A third way to create iterator objects is to call a generator function. A generator is a function containing the
keyword yield. It must be noted that the mere presence of this keyword completely changes the nature of the
function: this yield statement doesn’t have to be invoked, or even reachable, but causes the function to be
marked as a generator. When a normal function is called, the instructions contained in the body start to be
executed. When a generator is called, the execution stops before the ﬁrst instruction in the body. An invocation
of a generator function creates a generator object, adhering to the iterator protocol. As with normal function
invocations, concurrent and recursive invocations are allowed.
When next is called, the function is executed until the ﬁrst yield. Each encountered yield statement gives a
value becomes the return value of next. After executing the yield statement, the execution of this function is
suspended.

yield 1
yield 2

>>> def f():
...
...
>>> f()

>>> gen = f()
>>> next(gen)
1
>>> next(gen)
2
>>> next(gen)
Traceback (most recent call last):

File "", line 1, in 

StopIteration

7.1.

Iterators, generator expressions and generators

144

Let’s go over the life of the single invocation of the generator function.

Scipy lecture notes, Edition 2015.2

print("-- start --")
yield 3
print("-- middle --")
yield 4
print("-- finished --")

>>> def f():
...
...
...
...
...
>>> gen = f()
>>> next(gen)
-- start --
3
>>> next(gen)
-- middle --
4
>>> next(gen)
-- finished --
Traceback (most recent call last):

...

StopIteration
Traceback (most recent call last):

...

StopIteration

Contrary to a normal function, where executing f() would immediately cause the ﬁrst print to be executed,
gen is assigned without executing any statements in the function body. Only when gen.next() is invoked by
next, the statements up to the ﬁrst yield are executed. The second next prints -- middle -- and execution
halts on the second yield. The third next prints -- finished -- and falls of the end of the function. Since
no yield was reached, an exception is raised.

What happens with the function after a yield, when the control passes to the caller? The state of each generator
is stored in the generator object. From the point of view of the generator function, is looks almost as if it was
running in a separate thread, but this is just an illusion: execution is strictly single-threaded, but the interpreter
keeps and restores the state in between the requests for the next value.

Why are generators useful? As noted in the parts about iterators, a generator function is just a different way to
create an iterator object. Everything that can be done with yield statements, could also be done with next
methods. Nevertheless, using a function and having the interpreter perform its magic to create an iterator
has advantages. A function can be much shorter than the deﬁnition of a class with the required next and
\_\_iter\_\_ methods. What is more important, it is easier for the author of the generator to understand the state
which is kept in local variables, as opposed to instance attributes, which have to be used to pass data between
consecutive invocations of next on an iterator object.

A broader question is why are iterators useful? When an iterator is used to power a loop, the loop becomes very
simple. The code to initialise the state, to decide if the loop is ﬁnished, and to ﬁnd the next value is extracted
into a separate place. This highlights the body of the loop — the interesting part. In addition, it is possible to
reuse the iterator code in other places.

7.1.4 Bidirectional communication

Each yield statement causes a value to be passed to the caller. This is the reason for the introduction of
generators by PEP 255 (implemented in Python 2.2). But communication in the reverse direction is also useful.
One obvious way would be some external state, either a global variable or a shared mutable object. Direct
communication is possible thanks to PEP 342 (implemented in 2.5). It is achieved by turning the previously
boring yield statement into an expression. When the generator resumes execution after a yield statement,
the caller can call a method on the generator object to either pass a value into the generator, which then is
returned by the yield statement, or a different method to inject an exception into the generator.
The ﬁrst of the new methods is send(value), which is similar to next(), but passes value into the generator
to be used for the value of the yield expression. In fact, g.next() and g.send(None) are equivalent.
The second of the new methods is throw(type, value=None, traceback=None) which is equivalent to:

7.1.

Iterators, generator expressions and generators

145

Scipy lecture notes, Edition 2015.2

raise type, value, traceback

at the point of the yield statement.
Unlike raise (which immediately raises an exception from the current execution point), throw() ﬁrst resumes
the generator, and only then raises the exception. The word throw was picked because it is suggestive of putting
the exception in another location, and is associated with exceptions in other languages.

What happens when an exception is raised inside the generator? It can be either raised explicitly or when
executing some statements or it can be injected at the point of a yield statement by means of the throw()
method. In either case, such an exception propagates in the standard manner: it can be intercepted by an
except or finally clause, or otherwise it causes the execution of the generator function to be aborted and
propagates in the caller.
For completeness’ sake, it’s worth mentioning that generator iterators also have a close() method, which can
be used to force a generator that would otherwise be able to provide more values to ﬁnish immediately. It
allows the generator \_\_del\_\_ method to destroy objects holding the state of generator.

Let’s deﬁne a generator which just prints what is passed in through send and throw.

print('--start--')
for i in itertools.count():

print('--yielding %i --' % i)
try:

ans = yield i
except GeneratorExit:

print('--closing--')
raise

except Exception as e:

>>> import itertools
>>> def g():
...
...
...
...
...
...
...
...
...
...
...
...

else:

print('--yield raised %r --' % e)

print('--yield returned %s --' % ans)

>>> it = g()
>>> next(it)
--start--
--yielding 0--
0
>>> it.send(11)
--yield returned 11--
--yielding 1--
1
>>> it.throw(IndexError)
--yield raised IndexError()--
--yielding 2--
2
>>> it.close()
--closing--

next or \_\_next\_\_?
In Python 2.x, the iterator method to retrieve the next value is called next.
It is invoked implicitly
through the global function next, which means that it should be called \_\_next\_\_. Just like the global
function iter calls \_\_iter\_\_. This inconsistency is corrected in Python 3.x, where it.next becomes
it.\_\_next\_\_. For other generator methods — send and throw — the situation is more complicated,
because they are not called implicitly by the interpreter. Nevertheless, there’s a proposed syntax exten-
sion to allow continue to take an argument which will be passed to send of the loop’s iterator. If this
extension is accepted, it’s likely that gen.send will become gen.\_\_send\_\_. The last of generator meth-
ods, close, is pretty obviously named incorrectly, because it is already invoked implicitly.

7.1.

Iterators, generator expressions and generators

146

Scipy lecture notes, Edition 2015.2

7.1.5 Chaining generators

This is a preview of PEP 380 (not yet implemented, but accepted for Python 3.3).

Let’s say we are writing a generator and we want to yield a number of values generated by a second generator,
a subgenerator. If yielding of values is the only concern, this can be performed without much difﬁculty using
a loop such as

subgen = some\_other\_generator()
for v in subgen:
yield v

However, if the subgenerator is to interact properly with the caller in the case of calls to send(), throw()
and close(), things become considerably more difﬁcult. The yield statement has to be guarded by a
try..except..ﬁnally structure similar to the one deﬁned in the previous section to “debug” the generator func-
tion. Such code is provided in PEP 380, here it sufﬁces to say that new syntax to properly yield from a subgen-
erator is being introduced in Python 3.3:

yield from some\_other\_generator()

This behaves like the explicit loop above, repeatedly yielding values from some\_other\_generator until it is
exhausted, but also forwards send, throw and close to the subgenerator.

7.2 Decorators

Summary

This amazing feature appeared in the language almost apologetically and with concern that it might not
be that useful.

Bruce Eckel — An Introduction to Python Decorators

Since a function or a class are objects, they can be passed around. Since they are mutable objects, they can be
modiﬁed. The act of altering a function or class object after it has been constructed but before is is bound to
its name is called decorating.

There are two things hiding behind the name “decorator” — one is the function which does the work of deco-
rating, i.e. performs the real work, and the other one is the expression adhering to the decorator syntax, i.e. an
at-symbol and the name of the decorating function.

Function can be decorated by using the decorator syntax for functions:

@decorator
def function():

pass

# (cid:183)
# (cid:182)

• A function is deﬁned in the standard way. (cid:182)
• An expression starting with @ placed before the function deﬁnition is the decorator (cid:183). The part after @
must be a simple expression, usually this is just the name of a function or class. This part is evaluated
ﬁrst, and after the function deﬁned below is ready, the decorator is called with the newly deﬁned function
object as the single argument. The value returned by the decorator is attached to the original name of
the function.

Decorators can be applied to functions and to classes. For classes the semantics are identical — the original
class deﬁnition is used as an argument to call the decorator and whatever is returned is assigned under the
original name.

Before the decorator syntax was implemented (PEP 318), it was possible to achieve the same effect by assign-
ing the function or class object to a temporary variable and then invoking the decorator explicitly and then
assigning the return value to the name of the function. This sounds like more typing, and it is, and also the

7.2. Decorators

147

Scipy lecture notes, Edition 2015.2

name of the decorated function doubling as a temporary variable must be used at least three times, which is
prone to errors. Nevertheless, the example above is equivalent to:

def function():

pass

# (cid:182)

function = decorator(function)

# (cid:183)

Decorators can be stacked — the order of application is bottom-to-top, or inside-out. The semantics are such
that the originally deﬁned function is used as an argument for the ﬁrst decorator, whatever is returned by
the ﬁrst decorator is used as an argument for the second decorator, ..., and whatever is returned by the last
decorator is attached under the name of the original function.

The decorator syntax was chosen for its readability. Since the decorator is speciﬁed before the header of the
function, it is obvious that its is not a part of the function body and its clear that it can only operate on the
whole function. Because the expression is preﬁxed with @ is stands out and is hard to miss (“in your face”,
according to the PEP :) ). When more than one decorator is applied, each one is placed on a separate line in an
easy to read way.

7.2.1 Replacing or tweaking the original object

Decorators can either return the same function or class object or they can return a completely different ob-
ject. In the ﬁrst case, the decorator can exploit the fact that function and class objects are mutable and add
attributes, e.g. add a docstring to a class. A decorator might do something useful even without modifying
the object, for example register the decorated class in a global registry. In the second case, virtually anything is
possible: when something different is substituted for the original function or class, the new object can be com-
pletely different. Nevertheless, such behaviour is not the purpose of decorators: they are intended to tweak
the decorated object, not do something unpredictable. Therefore, when a function is “decorated” by replacing
it with a different function, the new function usually calls the original function, after doing some preparatory
work. Likewise, when a class is “decorated” by replacing if with a new class, the new class is usually derived
from the original class. When the purpose of the decorator is to do something “every time”, like to log every call
to a decorated function, only the second type of decorators can be used. On the other hand, if the ﬁrst type is
sufﬁcient, it is better to use it, because it is simpler.

7.2.2 Decorators implemented as classes and as functions

The only requirement on decorators is that they can be called with a single argument. This means that deco-
rators can be implemented as normal functions, or as classes with a \_\_call\_\_ method, or in theory, even as
lambda functions.
Let’s compare the function and class approaches. The decorator expression (the part after @) can be either just
a name, or a call. The bare-name approach is nice (less to type, looks cleaner, etc.), but is only possible when
no arguments are needed to customise the decorator. Decorators written as functions can be used in those
two cases:

>>> def simple\_decorator(function):
print("doing decoration")
...
return function
...
>>> @simple\_decorator
... def function():
...
doing decoration
>>> function()
inside function

print("inside function")

>>> def decorator\_with\_arguments(arg):
print("defining the decorator")
...
def \_decorator(function):
...
...
...
...

# in this inner function, arg is available too
print("doing decoration, %r " % arg)
return function

7.2. Decorators

148

Scipy lecture notes, Edition 2015.2

return \_decorator

print("inside function")

...
>>> @decorator\_with\_arguments("abc")
... def function():
...
defining the decorator
doing decoration, 'abc'
>>> function()
inside function

The two trivial decorators above fall into the category of decorators which return the original function. If they
were to return a new function, an extra level of nestedness would be required. In the worst case, three levels of
nested functions.

# in this inner function, arg is available too
print("doing decoration, %r " % arg)
def \_wrapper(\*args, \*\*kwargs):

print("inside wrapper, %r %r " % (args, kwargs))
return function(\*args, \*\*kwargs)

return \_wrapper

>>> def replacing\_decorator\_with\_args(arg):
print("defining the decorator")
...
def \_decorator(function):
...
...
...
...
...
...
...
...
>>> @replacing\_decorator\_with\_args("abc")
... def function(\*args, \*\*kwargs):
...
...
defining the decorator
doing decoration, 'abc'
>>> function(11, 12)
inside wrapper, (11, 12) {}
inside function, (11, 12) {}
14

return \_decorator

print("inside function, %r %r " % (args, kwargs))
return 14

The \_wrapper function is deﬁned to accept all positional and keyword arguments. In general we cannot know
what arguments the decorated function is supposed to accept, so the wrapper function just passes everything
to the wrapped function. One unfortunate consequence is that the apparent argument list is misleading.

Compared to decorators deﬁned as functions, complex decorators deﬁned as classes are simpler. When an
object is created, the \_\_init\_\_ method is only allowed to return None, and the type of the created object
cannot be changed. This means that when a decorator is deﬁned as a class, it doesn’t make much sense to use
the argument-less form: the ﬁnal decorated object would just be an instance of the decorating class, returned
by the constructor call, which is not very useful. Therefore it’s enough to discuss class-based decorators where
arguments are given in the decorator expression and the decorator \_\_init\_\_ method is used for decorator
construction.

# this method is called in the decorator expression
print("in decorator init, %s " % arg)
self.arg = arg

# this method is called to do the job
print("in decorator call, %s " % self.arg)
return function

def \_\_call\_\_(self, function):

>>> class decorator\_class(object):
def \_\_init\_\_(self, arg):
...
...
...
...
...
...
...
...
>>> deco\_instance = decorator\_class('foo')
in decorator init, foo
>>> @deco\_instance
... def function(\*args, \*\*kwargs):
...
in decorator call, foo
>>> function()
in function, () {}

print("in function, %s %s " % (args, kwargs))

7.2. Decorators

149

Scipy lecture notes, Edition 2015.2

Contrary to normal rules (PEP 8) decorators written as classes behave more like functions and therefore their
name often starts with a lowercase letter.

In reality, it doesn’t make much sense to create a new class just to have a decorator which returns the original
function. Objects are supposed to hold state, and such decorators are more useful when the decorator returns
a new object.

# this method is called in the decorator expression
print("in decorator init, %s " % arg)
self.arg = arg

def \_\_init\_\_(self, arg):

def \_\_call\_\_(self, function):

# this method is called to do the job
print("in decorator call, %s " % self.arg)
self.function = function
return self.\_wrapper

>>> class replacing\_decorator\_class(object):
...
...
...
...
...
...
...
...
...
...
...
...
>>> deco\_instance = replacing\_decorator\_class('foo')
in decorator init, foo
>>> @deco\_instance
... def function(\*args, \*\*kwargs):
...
in decorator call, foo
>>> function(11, 12)
in the wrapper, (11, 12) {}
in function, (11, 12) {}

print("in function, %s %s " % (args, kwargs))

def \_wrapper(self, \*args, \*\*kwargs):

print("in the wrapper, %s %s " % (args, kwargs))
return self.function(\*args, \*\*kwargs)

A decorator like this can do pretty much anything, since it can modify the original function object and mangle
the arguments, call the original function or not, and afterwards mangle the return value.

7.2.3 Copying the docstring and other attributes of the original function

When a new function is returned by the decorator to replace the original function, an unfortunate conse-
quence is that the original function name, the original docstring, the original argument list are lost. Those
attributes of the original function can partially be “transplanted” to the new function by setting \_\_doc\_\_ (the
docstring), \_\_module\_\_ and \_\_name\_\_ (the full name of the function), and \_\_annotations\_\_ (extra informa-
tion about arguments and the return value of the function available in Python 3). This can be done automati-
cally by using functools.update\_wrapper.

7.2. Decorators

150

Scipy lecture notes, Edition 2015.2

functools.update\_wrapper(wrapper, wrapped)

“Update a wrapper function to look like the wrapped function.”

print("inside wrapper, %r %r " % (args, kwargs))
return function(\*args, \*\*kwargs)

return functools.update\_wrapper(\_wrapper, function)

return \_decorator

print("doing decoration, %r " % arg)
def \_wrapper(\*args, \*\*kwargs):

>>> import functools
>>> def replacing\_decorator\_with\_args(arg):
print("defining the decorator")
...
def \_decorator(function):
...
...
...
...
...
...
...
>>> @replacing\_decorator\_with\_args("abc")
... def function():
...
...
...
defining the decorator
doing decoration, 'abc'
>>> function

>>> print(function.\_\_doc\_\_)
extensive documentation

"extensive documentation"
print("inside function")
return 14

One important thing is missing from the list of attributes which can be copied to the replacement func-
tion: the argument list. The default values for arguments can be modiﬁed through the \_\_defaults\_\_,
\_\_kwdefaults\_\_ attributes, but unfortunately the argument list itself cannot be set as an attribute. This
means that help(function) will display a useless argument list which will be confusing for the user of the
function. An effective but ugly way around this problem is to create the wrapper dynamically, using eval. This
can be automated by using the external decorator module. It provides support for the decorator decorator,
which takes a wrapper and turns it into a decorator which preserves the function signature.
To sum things up, decorators should always use functools.update\_wrapper or some other means of copy-
ing function attributes.

7.2.4 Examples in the standard library

First, it should be mentioned that there’s a number of useful decorators available in the standard library. There
are three decorators which really form a part of the language:

• classmethod causes a method to become a “class method”, which means that it can be invoked without
creating an instance of the class. When a normal method is invoked, the interpreter inserts the instance
object as the ﬁrst positional parameter, self. When a class method is invoked, the class itself is given as
the ﬁrst parameter, often called cls.

Class methods are still accessible through the class’ namespace, so they don’t pollute the module’s
namespace. Class methods can be used to provide alternative constructors:

class Array(object):

def \_\_init\_\_(self, data):
self.data = data

@classmethod
def fromfile(cls, file):

data = numpy.load(file)
return cls(data)

This is cleaner then using a multitude of ﬂags to \_\_init\_\_.

7.2. Decorators

151

Scipy lecture notes, Edition 2015.2

• staticmethod is applied to methods to make them “static”, i.e. basically a normal function, but acces-
sible through the class namespace. This can be useful when the function is only needed inside this class
(its name would then be preﬁxed with \_), or when we want the user to think of the method as connected
to the class, despite an implementation which doesn’t require this.

• property is the pythonic answer to the problem of getters and setters. A method decorated with

property becomes a getter which is automatically called on attribute access.

>>> class A(object):
@property
...
def a(self):
...
...
...
>>> A.a

>>> A().a
'a value'

"an important attribute"
return "a value"

In this example, A.a is an read-only attribute. It is also documented: help(A) includes the docstring for
attribute a taken from the getter method. Deﬁning a as a property allows it to be a calculated on the ﬂy,
and has the side effect of making it read-only, because no setter is deﬁned.

To have a setter and a getter, two methods are required, obviously. Since Python 2.6 the following syntax
is preferred:

class Rectangle(object):

def \_\_init\_\_(self, edge):
self.edge = edge

@property
def area(self):

"""Computed area.

Setting this updates the edge length to the proper value.
"""
return self.edge\*\*2

@area.setter
def area(self, area):

self.edge = area \*\* 0.5

The way that this works, is that the property decorator replaces the getter method with a property
object. This object in turn has three methods, getter, setter, and deleter, which can be used as
decorators. Their job is to set the getter, setter and deleter of the property object (stored as attributes
fget, fset, and fdel). The getter can be set like in the example above, when creating the object. When
deﬁning the setter, we already have the property object under area, and we add the setter to it by using
the setter method. All this happens when we are creating the class.

Afterwards, when an instance of the class has been created, the property object is special. When the
interpreter executes attribute access, assignment, or deletion, the job is delegated to the methods of the
property object.

To make everything crystal clear, let’s deﬁne a “debug” example:

@property
def a(self):

>>> class D(object):
...
...
...
...
...
...
...
...
...

@a.deleter
def a(self):

print("getting 1")
return 1
@a.setter
def a(self, value):

print("setting %r " % value)

7.2. Decorators

152

Scipy lecture notes, Edition 2015.2

print("deleting")

...
>>> D.a

>>> D.a.fget

>>> D.a.fset

>>> D.a.fdel

>>> d = D()
>>> d.a
getting 1
1
>>> d.a = 2
setting 2
>>> del d.a
deleting
>>> d.a
getting 1
1

# ... varies, this is not the same `a` function

Properties are a bit of a stretch for the decorator syntax. One of the premises of the decorator syntax —
that the name is not duplicated — is violated, but nothing better has been invented so far. It is just good
style to use the same name for the getter, setter, and deleter methods.

Some newer examples include:

• functools.lru\_cache memoizes an arbitrary function maintaining a limited cache of argu-

ments:answer pairs (Python 3.2)

• functools.total\_ordering is a class decorator which ﬁlls in missing ordering methods (\_\_lt\_\_,

\_\_gt\_\_, \_\_le\_\_, ...) based on a single available one (Python 2.7).

7.2.5 Deprecation of functions

Let’s say we want to print a deprecation warning on stderr on the ﬁrst invocation of a function we don’t like
anymore. If we don’t want to modify the function, we can use a decorator:

class deprecated(object):

"""Print a deprecation warning once on first use of the function.

# doctest: +SKIP

# doctest: +SKIP

>>> @deprecated()
... def f():
...
pass
>>> f()
f is deprecated
"""
def \_\_call\_\_(self, func):
self.func = func
self.count = 0
return self.\_wrapper

def \_wrapper(self, \*args, \*\*kwargs):

self.count += 1
if self.count == 1:

print self.func.\_\_name\_\_, 'is deprecated'

return self.func(\*args, \*\*kwargs)

It can also be implemented as a function:

def deprecated(func):

"""Print a deprecation warning once on first use of the function.

>>> @deprecated

# doctest: +SKIP

7.2. Decorators

153

Scipy lecture notes, Edition 2015.2

... def f():
...
pass
>>> f()
f is deprecated
"""
count = [0]
def wrapper(\*args, \*\*kwargs):

count[0] += 1
if count[0] == 1:

# doctest: +SKIP

print func.\_\_name\_\_, 'is deprecated'

return func(\*args, \*\*kwargs)

return wrapper

7.2.6 A while-loop removing decorator

Let’s say we have function which returns a lists of things, and this list created by running a loop. If we don’t
know how many objects will be needed, the standard way to do this is something like:

def find\_answers():
answers = []
while True:

ans = look\_for\_next\_answer()
if ans is None:
break

answers.append(ans)

return answers

This is ﬁne, as long as the body of the loop is fairly compact. Once it becomes more complicated, as often
happens in real code, this becomes pretty unreadable. We could simplify this by using yield statements, but
then the user would have to explicitly call list(find\_answers()).

We can deﬁne a decorator which constructs the list for us:

def vectorized(generator\_func):

def wrapper(\*args, \*\*kwargs):

return list(generator\_func(\*args, \*\*kwargs))

return functools.update\_wrapper(wrapper, generator\_func)

Our function then becomes:

@vectorized
def find\_answers():
while True:

ans = look\_for\_next\_answer()
if ans is None:
break
yield ans

7.2.7 A plugin registration system

This is a class decorator which doesn’t modify the class, but just puts it in a global registry. It falls into the
category of decorators returning the original object:

class WordProcessor(object):

PLUGINS = []
def process(self, text):

for plugin in self.PLUGINS:

text = plugin().cleanup(text)

return text

7.2. Decorators

154

Scipy lecture notes, Edition 2015.2

@classmethod
def plugin(cls, plugin):

cls.PLUGINS.append(plugin)

@WordProcessor.plugin
class CleanMdashesExtension(object):

def cleanup(self, text):

return text.replace('—', u'\N{em dash}')

Here we use a decorator to decentralise the registration of plugins. We call our decorator with a noun, instead
of a verb, because we use it to declare that our class is a plugin for WordProcessor. Method plugin simply
appends the class to the list of plugins.

A word about the plugin itself: it replaces HTML entity for em-dash with a real Unicode em-dash character.
It exploits the unicode literal notation to insert a character by using its name in the unicode database (“EM
DASH”). If the Unicode character was inserted directly, it would be impossible to distinguish it from an en-
dash in the source of a program.

See also:

More examples and reading

• PEP 318 (function and method decorator syntax)

• PEP 3129 (class decorator syntax)

• http://wiki.python.org/moin/PythonDecoratorLibrary

• https://docs.python.org/dev/library/functools.html

• http://pypi.python.org/pypi/decorator

• Bruce Eckel

– Decorators I: Introduction to Python Decorators

– Python Decorators II: Decorator Arguments

– Python Decorators III: A Decorator-Based Build System

7.3 Context managers

A context manager is an object with \_\_enter\_\_ and \_\_exit\_\_ methods which can be used in the with state-
ment:

with manager as var:
do\_something(var)

is in the simplest case equivalent to

var = manager.\_\_enter\_\_()
try:

do\_something(var)

finally:

manager.\_\_exit\_\_()

In other words, the context manager protocol deﬁned in PEP 343 permits the extraction of the boring part of a
try..except..ﬁnally structure into a separate class leaving only the interesting do\_something block.

1. The \_\_enter\_\_ method is called ﬁrst. It can return a value which will be assigned to var. The as-part is

optional: if it isn’t present, the value returned by \_\_enter\_\_ is simply ignored.

2. The block of code underneath with is executed. Just like with try clauses, it can either execute success-
fully to the end, or it can break, continue‘ or return, or it can throw an exception. Either way, after the
block is ﬁnished, the \_\_exit\_\_ method is called. If an exception was thrown, the information about the

7.3. Context managers

155

Scipy lecture notes, Edition 2015.2

exception is passed to \_\_exit\_\_, which is described below in the next subsection. In the normal case,
exceptions can be ignored, just like in a finally clause, and will be rethrown after \_\_exit\_\_ is ﬁnished.

Let’s say we want to make sure that a ﬁle is closed immediately after we are done writing to it:

def \_\_init\_\_(self, obj):

self.obj = obj
def \_\_enter\_\_(self):
return self.obj

>>> class closing(object):
...
...
...
...
...
...
>>> with closing(open('/tmp/file', 'w')) as f:
...

def \_\_exit\_\_(self, \*args):

f.write('the contents\n')

self.obj.close()

Here we have made sure that the f.close() is called when the with block is exited. Since closing ﬁles is such
a common operation, the support for this is already present in the file class. It has an \_\_exit\_\_ method
which calls close and can be used as a context manager itself:

>>> with open('/tmp/file', 'a') as f:
f.write('more contents\n')
...

The common use for try..finally is releasing resources. Various different cases are implemented similarly:
in the \_\_enter\_\_ phase the resource is acquired, in the \_\_exit\_\_ phase it is released, and the exception, if
thrown, is propagated. As with ﬁles, there’s often a natural operation to perform after the object has been used
and it is most convenient to have the support built in. With each release, Python provides support in more
places:

• all ﬁle-like objects:

– file (cid:229) automatically closed
– fileinput, tempfile (py >= 3.2)
– bz2.BZ2File, gzip.GzipFile, tarfile.TarFile, zipfile.ZipFile
– ftplib, nntplib (cid:229) close connection (py >= 3.2 or 3.3)

• locks

– multiprocessing.RLock (cid:229) lock and unlock
– multiprocessing.Semaphore
– memoryview (cid:229) automatically release (py >= 3.2 and 2.7)

• decimal.localcontext (cid:229) modify precision of computations temporarily
• \_winreg.PyHKEY (cid:229) open and close hive key
• warnings.catch\_warnings (cid:229) kill warnings temporarily
• contextlib.closing (cid:229) the same as the example above, call close

• parallel programming

– concurrent.futures.ThreadPoolExecutor (cid:229) invoke in parallel then kill thread pool (py >= 3.2)
– concurrent.futures.ProcessPoolExecutor (cid:229) invoke in parallel then kill process pool (py >=

3.2)

– nogil (cid:229) solve the GIL problem temporarily (cython only :( )

7.3.1 Catching exceptions

When an exception is thrown in the with-block, it is passed as arguments to \_\_exit\_\_. Three arguments are
used, the same as returned by sys.exc\_info(): type, value, traceback. When no exception is thrown, None is
used for all three arguments. The context manager can “swallow” the exception by returning a true value from

7.3. Context managers

156

Scipy lecture notes, Edition 2015.2

\_\_exit\_\_. Exceptions can be easily ignored, because if \_\_exit\_\_ doesn’t use return and just falls of the end,
None is returned, a false value, and therefore the exception is rethrown after \_\_exit\_\_ is ﬁnished.

The ability to catch exceptions opens interesting possibilities. A classic example comes from unit-tests — we
want to make sure that some code throws the right kind of exception:

class assert\_raises(object):

# based on pytest and unittest.TestCase
def \_\_init\_\_(self, type):
self.type = type
def \_\_enter\_\_(self):

pass

def \_\_exit\_\_(self, type, value, traceback):

if type is None:

raise AssertionError('exception expected')

if issubclass(type, self.type):

return True # swallow the expected exception

raise AssertionError('wrong exception type')

with assert\_raises(KeyError):

{}['foo']

7.3.2 Using generators to define context managers

When discussing generators, it was said that we prefer generators to iterators implemented as classes because
they are shorter, sweeter, and the state is stored as local, not instance, variables. On the other hand, as de-
scribed in Bidirectional communication, the ﬂow of data between the generator and its caller can be bidirec-
tional. This includes exceptions, which can be thrown into the generator. We would like to implement context
managers as special generator functions. In fact, the generator protocol was designed to support this use case.

@contextlib.contextmanager
def some\_generator():


try:

yield 

finally:



The contextlib.contextmanager helper takes a generator and turns it into a context manager. The gener-
ator has to obey some rules which are enforced by the wrapper function — most importantly it must yield
exactly once. The part before the yield is executed from \_\_enter\_\_, the block of code protected by the con-
text manager is executed when the generator is suspended in yield, and the rest is executed in \_\_exit\_\_. If
an exception is thrown, the interpreter hands it to the wrapper through \_\_exit\_\_ arguments, and the wrap-
per function then throws it at the point of the yield statement. Through the use of generators, the context
manager is shorter and simpler.
Let’s rewrite the closing example as a generator:

@contextlib.contextmanager
def closing(obj):

try:

yield obj

finally:

obj.close()

Let’s rewrite the assert\_raises example as a generator:

@contextlib.contextmanager
def assert\_raises(type):

try:

yield
except type:

7.3. Context managers

157

Scipy lecture notes, Edition 2015.2

return

except Exception as value:

raise AssertionError('wrong exception type')

else:

raise AssertionError('exception expected')

Here we use a decorator to turn generator functions into context managers!

7.3. Context managers

158

CHAPTER 8

Advanced Numpy

Author: Pauli Virtanen

Numpy is at the base of Python’s scientiﬁc stack of tools. Its purpose to implement efﬁcient operations on
many items in a block of memory. Understanding how it works in detail helps in making efﬁcient use of its
ﬂexibility, taking useful shortcuts.

This section covers:

• Anatomy of Numpy arrays, and its consequences. Tips and tricks.

• Universal functions: what, why, and what to do if you want a new one.

• Integration with other tools: Numpy offers several ways to wrap any data in an ndarray, without unnec-

essary copies.

• Recently added features, and what’s in them: PEP 3118 buffers, generalized ufuncs, ...

Prerequisites

• Numpy
• Cython
• Pillow (Python imaging library, used in a couple of examples)

159

Scipy lecture notes, Edition 2015.2

Chapter contents

• Life of ndarray
– It’s...
– Block of memory
– Data types
– Indexing scheme: strides
– Findings in dissection

• Universal functions
– What they are?
– Exercise: building an ufunc from scratch
– Solution: building an ufunc from scratch
– Generalized ufuncs
• Interoperability features

– Sharing multidimensional, typed data
– The old buffer protocol
– The old buffer protocol
– Array interface protocol

• Array siblings: chararray, maskedarray, matrix
– chararray: vectorized string operations
– masked\_array missing data
– recarray: purely convenience
– matrix: convenience?

• Summary
• Contributing to Numpy/Scipy

– Why
– Reporting bugs
– Contributing to documentation
– Contributing features
– How to help, in general

In this section, numpy will be imported as follows:

>>> import numpy as np

8.1 Life of ndarray

8.1.1 It’s...

ndarray =

block of memory + indexing scheme + data type descriptor

• raw data

• how to locate an element

• how to interpret an element

8.1. Life of ndarray

160

Scipy lecture notes, Edition 2015.2

typedef struct PyArrayObject {
PyObject\_HEAD

/\* Block of memory \*/
char \*data;

/\* Data type descriptor \*/
PyArray\_Descr \*descr;

/\* Indexing scheme \*/
int nd;
npy\_intp \*dimensions;
npy\_intp \*strides;

/\* Other stuff \*/
PyObject \*base;
int flags;
PyObject \*weakreflist;

} PyArrayObject;

8.1.2 Block of memory

>>> x = np.array([1, 2, 3], dtype=np.int32)
>>> x.data
<... at ...>
>>> str(x.data)
'\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'

Memory address of the data:

>>> x.\_\_array\_interface\_\_['data'][0]
64803824

The whole \_\_array\_interface\_\_:

>>> x.\_\_array\_interface\_\_
{'data': (35828928, False),

'descr': [('', '>> x = np.array([1, 2, 3, 4])
>>> y = x[:-1]

8.1. Life of ndarray

161

Scipy lecture notes, Edition 2015.2

>>> x[0] = 9
>>> y
array([9, 2, 3])

Memory does not need to be owned by an ndarray:

>>> x = b'1234'

# The 'b' is for "bytes", necessary in Python 3

x is a string (in Python 3 a bytes), we can represent its data as an array of ints:

>>> y = np.frombuffer(x, dtype=np.int8)
>>> y.data
<... at ...>
>>> y.base is x
True

>>> y.flags

C\_CONTIGUOUS : True
F\_CONTIGUOUS : True
OWNDATA : False
WRITEABLE : False
ALIGNED : True
UPDATEIFCOPY : False

The owndata and writeable ﬂags indicate status of the memory block.

8.1.3 Data types

The descriptor

dtype describes a single item in the array:

type

itemsize
byte-
order
ﬁelds
shape

scalar type of the data, one of:
int8, int16, ﬂoat64, et al. (ﬁxed size)
str, unicode, void (ﬂexible size)
size of the data block
byte order: big-endian > / little-endian < / not applicable |

sub-dtypes, if it’s a structured data type
shape of the array, if it’s a sub-array

>>> np.dtype(int).type

>>> np.dtype(int).itemsize
8
>>> np.dtype(int).byteorder
'='

Example: reading .wav files

The .wav ﬁle header:

8.1. Life of ndarray

162

Scipy lecture notes, Edition 2015.2

chunk\_id
chunk\_size
format
fmt\_id
fmt\_size
audio\_fmt
num\_channels
sample\_rate
byte\_rate
block\_align
bits\_per\_sample
data\_id
data\_size

"RIFF"

4-byte unsigned little-endian integer
"WAVE"
"fmt "

4-byte unsigned little-endian integer
2-byte unsigned little-endian integer
2-byte unsigned little-endian integer
4-byte unsigned little-endian integer
4-byte unsigned little-endian integer
2-byte unsigned little-endian integer
2-byte unsigned little-endian integer
"data"

4-byte unsigned little-endian integer

• 44-byte block of raw data (in the beginning of the ﬁle)
• ... followed by data\_size bytes of actual sound data.

The .wav ﬁle header as a Numpy structured data type:

#

# little-endian unsigned 32-bit integer
# 4-byte string

>>> wav\_header\_dtype = np.dtype([
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...

("chunk\_id", (bytes, 4)), # flexible-sized scalar type, item size 4
("chunk\_size", ">> wav\_header\_dtype['format']
dtype('S4')
>>> wav\_header\_dtype.fields
dict\_proxy({'block\_align': (dtype('uint16'), 32), 'format': (dtype('S4'), 8), 'data\_id': (dtype(('S1', (2, 2))), 36), 'fmt\_id': (dtype('S4'), 12), 'byte\_rate': (dtype('uint32'), 28), 'chunk\_id': (dtype('S4'), 0), 'num\_channels': (dtype('uint16'), 22), 'sample\_rate': (dtype('uint32'), 24), 'bits\_per\_sample': (dtype('uint16'), 34), 'chunk\_size': (dtype('uint32'), 4), 'fmt\_size': (dtype('uint32'), 16), 'data\_size': (dtype('uint32'), 40), 'audio\_fmt': (dtype('uint16'), 20)})
>>> wav\_header\_dtype.fields['format']
(dtype('S4'), 8)

• The ﬁrst element is the sub-dtype in the structured data, corresponding to the name format

• The second one is its offset (in bytes) from the beginning of the item

8.1. Life of ndarray

163

Scipy lecture notes, Edition 2015.2

Exercise

Mini-exercise, make a “sparse” dtype by using offsets, and only some of the ﬁelds:

names=['format', 'sample\_rate', 'data\_id'],
offsets=[offset\_1, offset\_2, offset\_3], # counted from start of structure in bytes
formats=list of dtypes for each of the fields,

>>> wav\_header\_dtype = np.dtype(dict(
...
...
...
... ))
and use that to read the sample rate, and data\_id (as sub-array).

>>> f = open('data/test.wav', 'r')
>>> wav\_header = np.fromfile(f, dtype=wav\_header\_dtype, count=1)
>>> f.close()
>>> print(wav\_header)
[ ('RIFF', 17402L, 'WAVE', 'fmt ', 16L, 1, 1, 16000L, 32000L, 2, 16, [['d', 'a'], ['t', 'a']], 17366L)]
>>> wav\_header['sample\_rate']
array([16000], dtype=uint32)

Let’s try accessing the sub-array:

>>> wav\_header['data\_id']
array([[['d', 'a'],

['t', 'a']]],

dtype='|S1')

>>> wav\_header.shape
(1,)
>>> wav\_header['data\_id'].shape
(1, 2, 2)

When accessing sub-arrays, the dimensions get added to the end!

There are existing modules such as wavfile, audiolab, etc. for loading sound data...

Casting and re-interpretation/views

casting

• on assignment

• on array construction

• on arithmetic

• etc.
• and manually: .astype(dtype)

data re-interpretation

• manually: .view(dtype)

Casting

• Casting in arithmetic, in nutshell:

– only type (not value!) of operands matters

– largest “safe” type able to represent both is picked

– scalars can “lose” to arrays in some situations

• Casting in general copies data:

8.1. Life of ndarray

164

Scipy lecture notes, Edition 2015.2

3.,

2.,

4.])

>>> x = np.array([1, 2, 3, 4], dtype=np.float)
>>> x
array([ 1.,
>>> y = x.astype(np.int8)
>>> y
array([1, 2, 3, 4], dtype=int8)
>>> y + 1
array([2, 3, 4, 5], dtype=int8)
>>> y + 256
array([257, 258, 259, 260], dtype=int16)
>>> y + 256.0
array([ 257.,
>>> y + np.array([256], dtype=np.int32)
array([257, 258, 259, 260], dtype=int32)

260.])

258.,

259.,

• Casting on setitem: dtype of the array is not changed on item assignment:

>>> y[:] = y + 1.5
>>> y
array([2, 3, 4, 5], dtype=int8)

Exact rules: see numpy documentation

Re-interpretation / viewing

• Data block in memory (4 bytes)

0x01

||

0x02

||

0x03

||

0x04

– 4 of uint8, OR,

– 4 of int8, OR,

– 2 of int16, OR,

– 1 of int32, OR,

– 1 of ﬂoat32, OR,

– ...

How to switch from one to another?

1. Switch the dtype:

>>> x = np.array([1, 2, 3, 4], dtype=np.uint8)
>>> x.dtype = ">> x
array([ 513, 1027], dtype=int16)
>>> 0x0201, 0x0403
(513, 1027)

0x01

0x02

||

0x03

0x04

little-endian: least signiﬁcant byte is on the left in memory

2. Create a new view:

>>> y = x.view(">> y
array([67305985], dtype=int32)
>>> 0x04030201
67305985

0x01

0x02

0x03

0x04

8.1. Life of ndarray

165

Scipy lecture notes, Edition 2015.2

• .view() makes views, does not copy (or alter) the memory block
• only changes the dtype (and adjusts array shape):

>>> x[1] = 5
>>> y
array([328193], dtype=int32)
>>> y.base is x
True

Mini-exercise: data re-interpretation

See also:

view-colors.py

You have RGBA data in an array:

>>> x = np.zeros((10, 10, 4), dtype=np.int8)
>>> x[:, :, 0] = 1
>>> x[:, :, 1] = 2
>>> x[:, :, 2] = 3
>>> x[:, :, 3] = 4

where the last three dimensions are the R, B, and G, and alpha channels.

How to make a (10, 10) structured array with ﬁeld names ‘r’, ‘g’, ‘b’, ‘a’ without copying data?

>>> y = ...

>>> assert (y['r'] == 1).all()
>>> assert (y['g'] == 2).all()
>>> assert (y['b'] == 3).all()
>>> assert (y['a'] == 4).all()

Solution

>>> y = x.view([('r', 'i1'),
('g', 'i1'),
...
('b', 'i1'),
...
('a', 'i1')]
...
)[:, :, 0]
...

8.1. Life of ndarray

166

Scipy lecture notes, Edition 2015.2

(cid:66)

Another array taking exactly 4 bytes of memory:

>>> y = np.array([[1, 3], [2, 4]], dtype=np.uint8).transpose()
>>> x = y.copy()
>>> x
array([[1, 2],

[3, 4]], dtype=uint8)

>>> y
array([[1, 2],

[3, 4]], dtype=uint8)

>>> x.view(np.int16)
array([[ 513],

[1027]], dtype=int16)

>>> 0x0201, 0x0403
(513, 1027)
>>> y.view(np.int16)
array([[ 769, 1026]], dtype=int16)

• What happened?
• ... we need to look into what x[0,1] actually means

>>> 0x0301, 0x0402
(769, 1026)

8.1.4 Indexing scheme: strides

Main point

The question:

>>> x = np.array([[1, 2, 3],
[4, 5, 6],
...
[7, 8, 9]], dtype=np.int8)
...
>>> str(x.data)
'\x01\x02\x03\x04\x05\x06\x07\x08\t'

At which byte in ``x.data`` does the item ``x[1, 2]`` begin?

The answer (in Numpy)

• strides: the number of bytes to jump to ﬁnd the next element

# to find x[1, 2]

• 1 stride per dimension

>>> x.strides
(3, 1)
>>> byte\_offset = 3\*1 + 1\*2
>>> x.flat[byte\_offset]
6
>>> x[1, 2]
6

- simple, \*\*flexible\*\*

C and Fortran order

>>> x = np.array([[1, 2, 3],
...
>>> x.strides
(6, 2)

[4, 5, 6]], dtype=np.int16, order='C')

8.1. Life of ndarray

167

Scipy lecture notes, Edition 2015.2

>>> str(x.data)
'\x01\x00\x02\x00\x03\x00\x04\x00\x05\x00\x06\x00'

• Need to jump 6 bytes to ﬁnd the next row

• Need to jump 2 bytes to ﬁnd the next column

>>> y = np.array(x, order='F')
>>> y.strides
(2, 4)
>>> str(y.data)
'\x01\x00\x04\x00\x02\x00\x05\x00\x03\x00\x06\x00'

• Need to jump 2 bytes to ﬁnd the next row

• Need to jump 4 bytes to ﬁnd the next column

• Similarly to higher dimensions:

– C: last dimensions vary fastest (= smaller strides)

– F: ﬁrst dimensions vary fastest

shape = (d1, d2, ..., dn)
strides = (s1, s2, ..., sn)

sC
j
sF
j

= d j +1d j +2...dn × itemsize
= d1d2...d j −1 × itemsize

Now we can understand the behavior of .view():

>>> y = np.array([[1, 3], [2, 4]], dtype=np.uint8).transpose()
>>> x = y.copy()

Transposition does not affect the memory layout of the data, only strides

>>> x.strides
(2, 1)
>>> y.strides
(1, 2)

>>> str(x.data)
'\x01\x02\x03\x04'
>>> str(y.data)
'\x01\x03\x02\x04'

• the results are different when interpreted as 2 of int16
• .copy() creates new arrays in the C order (by default)

Slicing with integers

• Everything can be represented by changing only shape, strides, and possibly adjusting the data

pointer!

• Never makes copies of the data

>>> x = np.array([1, 2, 3, 4, 5, 6], dtype=np.int32)
>>> y = x[::-1]
>>> y
array([6, 5, 4, 3, 2, 1], dtype=int32)
>>> y.strides
(-4,)

8.1. Life of ndarray

168

Scipy lecture notes, Edition 2015.2

>>> y = x[2:]
>>> y.\_\_array\_interface\_\_['data'][0] - x.\_\_array\_interface\_\_['data'][0]
8

>>> x = np.zeros((10, 10, 10), dtype=np.float)
>>> x.strides
(800, 80, 8)
>>> x[::2,::3,::4].strides
(1600, 240, 32)

• Similarly, transposes never make copies (it just swaps strides):

>>> x = np.zeros((10, 10, 10), dtype=np.float)
>>> x.strides
(800, 80, 8)
>>> x.T.strides
(8, 80, 800)

But: not all reshaping operations can be represented by playing with strides:

>>> a = np.arange(6, dtype=np.int8).reshape(3, 2)
>>> b = a.T
>>> b.strides
(1, 2)

So far, so good. However:

>>> str(a.data)
'\x00\x01\x02\x03\x04\x05'
>>> b
array([[0, 2, 4],

[1, 3, 5]], dtype=int8)

>>> c = b.reshape(3\*2)
>>> c
array([0, 2, 4, 1, 3, 5], dtype=int8)

Here, there is no way to represent the array c given one stride and the block of memory for a. Therefore, the
reshape operation needs to make a copy here.

Example: fake dimensions with strides

Stride manipulation

>>> from numpy.lib.stride\_tricks import as\_strided
>>> help(as\_strided)
as\_strided(x, shape=None, strides=None)

Make an ndarray from the given array with the given shape and strides

(cid:66) as\_strided does not check that you stay inside the memory block bounds...

>>> x = np.array([1, 2, 3, 4], dtype=np.int16)
>>> as\_strided(x, strides=(2\*2, ), shape=(2, ))
array([1, 3], dtype=int16)
>>> x[::2]
array([1, 3], dtype=int16)

See also:

stride-fakedims.py

Exercise

8.1. Life of ndarray

169

Scipy lecture notes, Edition 2015.2

array([1, 2, 3, 4], dtype=np.int8)

-> array([[1, 2, 3, 4],
[1, 2, 3, 4],
[1, 2, 3, 4]], dtype=np.int8)

using only as\_strided.:

Hint: byte\_offset = stride[0]\*index[0] + stride[1]\*index[1] + ...

Spoiler

Stride can also be 0:

>>> x = np.array([1, 2, 3, 4], dtype=np.int8)
>>> y = as\_strided(x, strides=(0, 1), shape=(3, 4))
>>> y
array([[1, 2, 3, 4],
[1, 2, 3, 4],
[1, 2, 3, 4]], dtype=int8)

>>> y.base.base is x
True

Broadcasting

• Doing something useful with it: outer product of [1, 2, 3, 4] and [5, 6, 7]

>>> x = np.array([1, 2, 3, 4], dtype=np.int16)
>>> x2 = as\_strided(x, strides=(0, 1\*2), shape=(3, 4))
>>> x2
array([[1, 2, 3, 4],
[1, 2, 3, 4],
[1, 2, 3, 4]], dtype=int16)

>>> y = np.array([5, 6, 7], dtype=np.int16)
>>> y2 = as\_strided(y, strides=(1\*2, 0), shape=(3, 4))
>>> y2
array([[5, 5, 5, 5],
[6, 6, 6, 6],
[7, 7, 7, 7]], dtype=int16)

>>> x2 \* y2
array([[ 5, 10, 15, 20],
[ 6, 12, 18, 24],
[ 7, 14, 21, 28]], dtype=int16)

... seems somehow familiar ...

>>> x = np.array([1, 2, 3, 4], dtype=np.int16)
>>> y = np.array([5, 6, 7], dtype=np.int16)
>>> x[np.newaxis,:] \* y[:,np.newaxis]
array([[ 5, 10, 15, 20],
[ 6, 12, 18, 24],
[ 7, 14, 21, 28]], dtype=int16)

• Internally, array broadcasting is indeed implemented using 0-strides.

More tricks: diagonals

See also:

8.1. Life of ndarray

170

Scipy lecture notes, Edition 2015.2

stride-diagonals.py

Challenge

• Pick diagonal entries of the matrix: (assume C memory order):

>>> x = np.array([[1, 2, 3],
[4, 5, 6],
...
[7, 8, 9]], dtype=np.int32)
...

>>> x\_diag = as\_strided(x, shape=(3,), strides=(???,))

• Pick the ﬁrst super-diagonal entries [2, 6].

• And the sub-diagonals?

(Hint to the last two: slicing ﬁrst moves the point where striding starts from.)

Solution

Pick diagonals:

>>> x\_diag = as\_strided(x, shape=(3, ), strides=((3+1)\*x.itemsize, ))
>>> x\_diag
array([1, 5, 9], dtype=int32)

Slice ﬁrst, to adjust the data pointer:

>>> as\_strided(x[0, 1:], shape=(2, ), strides=((3+1)\*x.itemsize, ))
array([2, 6], dtype=int32)

>>> as\_strided(x[1:, 0], shape=(2, ), strides=((3+1)\*x.itemsize, ))
array([4, 8], dtype=int32)

Using np.diag

>>> y = np.diag(x, k=1)
>>> y
array([2, 6], dtype=int32)

However,

>>> y.flags.owndata
False

Note This behavior has changed: before numpy 1.9, np.diag would make a copy.

See also:

stride-diagonals.py

Challenge

Compute the tensor trace:

>>> x = np.arange(5\*5\*5\*5).reshape(5, 5, 5, 5)
>>> s = 0
>>> for i in range(5):
...
...

for j in range(5):

s += x[j, i, j, i]

by striding, and using sum() on the result.

>>> y = as\_strided(x, shape=(5, 5), strides=(TODO, TODO))
>>> s2 = ...
>>> assert s == s2

Solution

8.1. Life of ndarray

171

Scipy lecture notes, Edition 2015.2

>>> y = as\_strided(x, shape=(5, 5), strides=((5\*5\*5 + 5)\*x.itemsize,
(5\*5 + 1)\*x.itemsize))
...
>>> s2 = y.sum()

CPU cache effects

Memory layout can affect performance:

In [1]: x = np.zeros((20000,))

In [2]: y = np.zeros((20000\*67,))[::67]

In [3]: x.shape, y.shape
((20000,), (20000,))

In [4]: %timeit x.sum()
100000 loops, best of 3: 0.180 ms per loop

In [5]: %timeit y.sum()
100000 loops, best of 3: 2.34 ms per loop

In [6]: x.strides, y.strides
((8,), (536,))

Smaller strides are faster?

• CPU pulls data from main memory to its cache in blocks

• If many array items consecutively operated on ﬁt in a single block (small stride):

– ⇒ fewer transfers needed

– ⇒ faster

See also:

numexpr is designed to mitigate cache effects in array computing.

Example: inplace operations (caveat emptor)

• Sometimes,

>>> a -= b

is not the same as

>>> a -= b.copy()

8.1. Life of ndarray

172

Scipy lecture notes, Edition 2015.2

>>> x = np.array([[1, 2], [3, 4]])
>>> x -= x.transpose()
>>> x
array([[ 0, -1],

[ 4,

0]])

>>> y = np.array([[1, 2], [3, 4]])
>>> y -= y.T.copy()
>>> y
array([[ 0, -1],

[ 1,

0]])

• x and x.transpose() share data
• x -= x.transpose() modiﬁes the data element-by-element...
• because x and x.transpose() have different striding, modiﬁed data re-appears on the RHS

8.1.5 Findings in dissection

• memory block: may be shared, .base, .data
• data type descriptor: structured data, sub-arrays, byte order, casting, viewing, .astype(), .view()
• strided indexing: strides, C/F-order, slicing w/ integers, as\_strided, broadcasting, stride tricks, diag,

CPU cache coherence

8.2 Universal functions

8.2.1 What they are?

• Ufunc performs and elementwise operation on all elements of an array.

Examples:

np.add, np.subtract, scipy.special.\*, ...

• Automatically support: broadcasting, casting, ...

• The author of an ufunc only has to supply the elementwise operation, Numpy takes care of the rest.

• The elementwise operation needs to be implemented in C (or, e.g., Cython)

8.2. Universal functions

173

Scipy lecture notes, Edition 2015.2

Parts of an Ufunc

1. Provided by user

void ufunc\_loop(void \*\*args, int \*dimensions, int \*steps, void \*data)
{

/\*

\* int8 output = elementwise\_function(int8 input\_1, int8 input\_2)
\*
\* This function must compute the ufunc for many values at once,
\* in the way shown below.
\*/
char \*input\_1 = (char\*)args[0];
char \*input\_2 = (char\*)args[1];
char \*output = (char\*)args[2];
int i;

for (i = 0; i < dimensions[0]; ++i) {

\*output = elementwise\_function(\*input\_1, \*input\_2);
input\_1 += steps[0];
input\_2 += steps[1];
output += steps[2];

}

}

2. The Numpy part, built by

char types[3]

types[0] = NPY\_BYTE
types[1] = NPY\_BYTE
types[2] = NPY\_BYTE

/\* type of first input arg \*/
/\* type of second input arg \*/
/\* type of third input arg \*/

PyObject \*python\_ufunc = PyUFunc\_FromFuncAndData(

ufunc\_loop,
NULL,
types,
1, /\* ntypes \*/
2, /\* num\_inputs \*/
1, /\* num\_outputs \*/
identity\_element,
name,
docstring,
unused)

• A ufunc can also support multiple different input-output type combinations.

Making it easier

3. ufunc\_loop is of very generic form, and Numpy provides pre-made ones

PyUfunc\_f\_f
float elementwise\_func(float input\_1)
PyUfunc\_ff\_f float elementwise\_func(float input\_1, float input\_2)
PyUfunc\_d\_d
double elementwise\_func(double input\_1)
PyUfunc\_dd\_d double elementwise\_func(double input\_1, double input\_2)
PyUfunc\_D\_D
PyUfunc\_DD\_D elementwise\_func(npy\_cdouble \*in1, npy\_cdouble \*in2, npy\_cdouble\*

elementwise\_func(npy\_cdouble \*input, npy\_cdouble\* output)

out)

• Only elementwise\_func needs to be supplied

• ... except when your elementwise function is not in one of the above forms

8.2. Universal functions

174

Scipy lecture notes, Edition 2015.2

8.2.2 Exercise: building an ufunc from scratch

The Mandelbrot fractal is deﬁned by the iteration

z ← z2 + c

where c = x + i y is a complex number. This iteration is repeated – if z stays ﬁnite no matter how long the
iteration runs, c belongs to the Mandelbrot set.

• Make ufunc called mandel(z0, c) that computes:

z = z0
for k in range(iterations):

z = z\*z + c

say, 100 iterations or until z.real\*\*2 + z.imag\*\*2 > 1000. Use it to determine which c are in the
Mandelbrot set.

• Our function is a simple one, so make use of the PyUFunc\_\* helpers.

• Write it in Cython

See also:

mandel.pyx, mandelplot.py

#
# Fix the parts marked by TODO
#

cython mandel.pyx
python setup.py build\_ext -i

#
# Compile this file by (Cython >= 0.12 required because of the complex vars)
#
#
#
#
# and try it out with, in this directory,
#
#
#
#
#

>>> import mandel
>>> mandel.mandel(0, 1 + 2j)

# The elementwise function
# ------------------------

cdef void mandel\_single\_point(double complex \*z\_in,
double complex \*c\_in,
double complex \*z\_out) nogil:

#
# The Mandelbrot iteration
#

#
# Some points of note:
#
# - It's \*NOT\* allowed to call any Python functions here.
#
#
#
#
# - And so all local variables must be declared with ``cdef``
#
# - Note also that this function receives \*pointers\* to the data
#

The Ufunc loop runs with the Python Global Interpreter Lock released.
Hence, the ``nogil``.

8.2. Universal functions

175

Scipy lecture notes, Edition 2015.2

cdef double complex z = z\_in[0]
cdef double complex c = c\_in[0]
cdef int k

# the integer we use in the for loop

as you would write it in Python.

#
# TODO: write the Mandelbrot iteration for one point here,
#
#
#
#
#

Say, use 100 as the maximum number of iterations, and 1000
as the cutoff for z.real\*\*2 + z.imag\*\*2.

TODO: mandelbrot iteration should go here

# Return the answer for this point
z\_out[0] = z

# Boilerplate Cython definitions
#
# The litany below is particularly long, but you don't really need to
# read this part; it just pulls in stuff from the Numpy C headers.
# ----------------------------------------------------------

cdef extern from "numpy/arrayobject.h":

void import\_array()
ctypedef int npy\_intp
cdef enum NPY\_TYPES:

NPY\_DOUBLE
NPY\_CDOUBLE
NPY\_LONG

cdef extern from "numpy/ufuncobject.h":

void import\_ufunc()
ctypedef void (\*PyUFuncGenericFunction)(char\*\*, npy\_intp\*, npy\_intp\*, void\*)
object PyUFunc\_FromFuncAndData(PyUFuncGenericFunction\* func, void\*\* data,

char\* types, int ntypes, int nin, int nout,
int identity, char\* name, char\* doc, int c)

# List of pre-defined loop functions

void PyUFunc\_f\_f\_As\_d\_d(char\*\* args, npy\_intp\* dimensions, npy\_intp\* steps, void\* func)
void PyUFunc\_d\_d(char\*\* args, npy\_intp\* dimensions, npy\_intp\* steps, void\* func)
void PyUFunc\_f\_f(char\*\* args, npy\_intp\* dimensions, npy\_intp\* steps, void\* func)
void PyUFunc\_g\_g(char\*\* args, npy\_intp\* dimensions, npy\_intp\* steps, void\* func)
void PyUFunc\_F\_F\_As\_D\_D(char\*\* args, npy\_intp\* dimensions, npy\_intp\* steps, void\* func)
void PyUFunc\_F\_F(char\*\* args, npy\_intp\* dimensions, npy\_intp\* steps, void\* func)
void PyUFunc\_D\_D(char\*\* args, npy\_intp\* dimensions, npy\_intp\* steps, void\* func)
void PyUFunc\_G\_G(char\*\* args, npy\_intp\* dimensions, npy\_intp\* steps, void\* func)
void PyUFunc\_ff\_f\_As\_dd\_d(char\*\* args, npy\_intp\* dimensions, npy\_intp\* steps, void\* func)
void PyUFunc\_ff\_f(char\*\* args, npy\_intp\* dimensions, npy\_intp\* steps, void\* func)
void PyUFunc\_dd\_d(char\*\* args, npy\_intp\* dimensions, npy\_intp\* steps, void\* func)
void PyUFunc\_gg\_g(char\*\* args, npy\_intp\* dimensions, npy\_intp\* steps, void\* func)
void PyUFunc\_FF\_F\_As\_DD\_D(char\*\* args, npy\_intp\* dimensions, npy\_intp\* steps, void\* func)
void PyUFunc\_DD\_D(char\*\* args, npy\_intp\* dimensions, npy\_intp\* steps, void\* func)
void PyUFunc\_FF\_F(char\*\* args, npy\_intp\* dimensions, npy\_intp\* steps, void\* func)
void PyUFunc\_GG\_G(char\*\* args, npy\_intp\* dimensions, npy\_intp\* steps, void\* func)

# Required module initialization
# ------------------------------

import\_array()

8.2. Universal functions

176

Scipy lecture notes, Edition 2015.2

import\_ufunc()

# The actual ufunc declaration
# ----------------------------

cdef PyUFuncGenericFunction loop\_func[1]
cdef char input\_output\_types[3]
cdef void \*elementwise\_funcs[1]

=======================================================
``float elementwise\_func(float input\_1)``
``float elementwise\_func(float input\_1, float input\_2)``
``double elementwise\_func(double input\_1)``
``double elementwise\_func(double input\_1, double input\_2)``
``elementwise\_func(complex\_double \*input, complex\_double\* complex\_double)``
``elementwise\_func(complex\_double \*in1, complex\_double \*in2, complex\_double\* out)``
=======================================================

#
# Reminder: some pre-made Ufunc loops:
#
# ================
# ``PyUfunc\_f\_f``
# ``PyUfunc\_ff\_f``
# ``PyUfunc\_d\_d``
# ``PyUfunc\_dd\_d``
# ``PyUfunc\_D\_D``
# ``PyUfunc\_DD\_D``
# ================
#
# The full list is above.
#
#
# Type codes:
#
# NPY\_BOOL, NPY\_BYTE, NPY\_UBYTE, NPY\_SHORT, NPY\_USHORT, NPY\_INT, NPY\_UINT,
# NPY\_LONG, NPY\_ULONG, NPY\_LONGLONG, NPY\_ULONGLONG, NPY\_FLOAT, NPY\_DOUBLE,
# NPY\_LONGDOUBLE, NPY\_CFLOAT, NPY\_CDOUBLE, NPY\_CLONGDOUBLE, NPY\_DATETIME,
# NPY\_TIMEDELTA, NPY\_OBJECT, NPY\_STRING, NPY\_UNICODE, NPY\_VOID
#

loop\_func[0] = ... TODO: suitable PyUFunc\_\* ...
input\_output\_types[0] = ... TODO ...
... TODO: fill in rest of input\_output\_types ...

# This thing is passed as the ``data`` parameter for the generic
# PyUFunc\_\* loop, to let it know which function it should call.
elementwise\_funcs[0] = mandel\_single\_point

# Construct the ufunc:

mandel = PyUFunc\_FromFuncAndData(

loop\_func,
elementwise\_funcs,
input\_output\_types,
1, # number of supported input types
TODO, # number of input args
TODO, # number of output args
0, # `identity` element, never mind this
"mandel", # function name
"mandel(z, c) -> computes z\*z + c", # docstring
0 # unused
)

Reminder: some pre-made Ufunc loops:

8.2. Universal functions

177

Scipy lecture notes, Edition 2015.2

float elementwise\_func(float input\_1)
PyUfunc\_f\_f
PyUfunc\_ff\_f float elementwise\_func(float input\_1, float input\_2)
PyUfunc\_d\_d
double elementwise\_func(double input\_1)
PyUfunc\_dd\_d double elementwise\_func(double input\_1, double input\_2)
PyUfunc\_D\_D
PyUfunc\_DD\_D elementwise\_func(complex\_double \*in1, complex\_double \*in2,

elementwise\_func(complex\_double \*input, complex\_double\* output)

complex\_double\* out)

Type codes:

NPY\_BOOL, NPY\_BYTE, NPY\_UBYTE, NPY\_SHORT, NPY\_USHORT, NPY\_INT, NPY\_UINT,
NPY\_LONG, NPY\_ULONG, NPY\_LONGLONG, NPY\_ULONGLONG, NPY\_FLOAT, NPY\_DOUBLE,
NPY\_LONGDOUBLE, NPY\_CFLOAT, NPY\_CDOUBLE, NPY\_CLONGDOUBLE, NPY\_DATETIME,
NPY\_TIMEDELTA, NPY\_OBJECT, NPY\_STRING, NPY\_UNICODE, NPY\_VOID

8.2.3 Solution: building an ufunc from scratch

# The elementwise function
# ------------------------

cdef void mandel\_single\_point(double complex \*z\_in,
double complex \*c\_in,
double complex \*z\_out) nogil:

#
# The Mandelbrot iteration
#

The Ufunc loop runs with the Python Global Interpreter Lock released.
Hence, the ``nogil``.

#
# Some points of note:
#
# - It's \*NOT\* allowed to call any Python functions here.
#
#
#
#
# - And so all local variables must be declared with ``cdef``
#
# - Note also that this function receives \*pointers\* to the data;
#
#

the "traditional" solution to passing complex variables around

cdef double complex z = z\_in[0]
cdef double complex c = c\_in[0]
cdef int k # the integer we use in the for loop

# Straightforward iteration

for k in range(100):
z = z\*z + c
if z.real\*\*2 + z.imag\*\*2 > 1000:

break

# Return the answer for this point
z\_out[0] = z

# Boilerplate Cython definitions
#
# You don't really need to read this part, it just pulls in
# stuff from the Numpy C headers.
# ----------------------------------------------------------

8.2. Universal functions

178

Scipy lecture notes, Edition 2015.2

cdef extern from "numpy/arrayobject.h":

void import\_array()
ctypedef int npy\_intp
cdef enum NPY\_TYPES:
NPY\_CDOUBLE

cdef extern from "numpy/ufuncobject.h":

void import\_ufunc()
ctypedef void (\*PyUFuncGenericFunction)(char\*\*, npy\_intp\*, npy\_intp\*, void\*)
object PyUFunc\_FromFuncAndData(PyUFuncGenericFunction\* func, void\*\* data,

char\* types, int ntypes, int nin, int nout,
int identity, char\* name, char\* doc, int c)

void PyUFunc\_DD\_D(char\*\*, npy\_intp\*, npy\_intp\*, void\*)

# Required module initialization
# ------------------------------

import\_array()
import\_ufunc()

# The actual ufunc declaration
# ----------------------------

cdef PyUFuncGenericFunction loop\_func[1]
cdef char input\_output\_types[3]
cdef void \*elementwise\_funcs[1]

loop\_func[0] = PyUFunc\_DD\_D

input\_output\_types[0] = NPY\_CDOUBLE
input\_output\_types[1] = NPY\_CDOUBLE
input\_output\_types[2] = NPY\_CDOUBLE

elementwise\_funcs[0] = mandel\_single\_point

mandel = PyUFunc\_FromFuncAndData(

loop\_func,
elementwise\_funcs,
input\_output\_types,
1, # number of supported input types
2, # number of input args
1, # number of output args
0, # `identity` element, never mind this
"mandel", # function name
"mandel(z, c) -> computes iterated z\*z + c", # docstring
0 # unused
)

"""
Plot Mandelbrot
================

Plot the Mandelbrot ensemble.

"""

import numpy as np
import mandel
x = np.linspace(-1.7, 0.6, 1000)
y = np.linspace(-1.4, 1.4, 1000)

8.2. Universal functions

179

Scipy lecture notes, Edition 2015.2

c = x[None,:] + 1j\*y[:,None]
z = mandel.mandel(c, c)

import matplotlib.pyplot as plt
plt.imshow(abs(z)\*\*2 < 1000, extent=[-1.7, 0.6, -1.4, 1.4])
plt.gray()
plt.show()

Most of the boilerplate could be automated by these Cython modules:
http://wiki.cython.org/MarkLodato/CreatingUfuncs

Several accepted input types

E.g. supporting both single- and double-precision versions

cdef void mandel\_single\_point(double complex \*z\_in,
double complex \*c\_in,
double complex \*z\_out) nogil:

...

cdef void mandel\_single\_point\_singleprec(float complex \*z\_in,
float complex \*c\_in,
float complex \*z\_out) nogil:

...

cdef PyUFuncGenericFunction loop\_funcs[2]
cdef char input\_output\_types[3\*2]
cdef void \*elementwise\_funcs[1\*2]

loop\_funcs[0] = PyUFunc\_DD\_D
input\_output\_types[0] = NPY\_CDOUBLE
input\_output\_types[1] = NPY\_CDOUBLE
input\_output\_types[2] = NPY\_CDOUBLE
elementwise\_funcs[0] = mandel\_single\_point

loop\_funcs[1] = PyUFunc\_FF\_F
input\_output\_types[3] = NPY\_CFLOAT
input\_output\_types[4] = NPY\_CFLOAT
input\_output\_types[5] = NPY\_CFLOAT
elementwise\_funcs[1] = mandel\_single\_point\_singleprec

mandel = PyUFunc\_FromFuncAndData(

loop\_func,
elementwise\_funcs,
input\_output\_types,

8.2. Universal functions

180

Scipy lecture notes, Edition 2015.2

<----------------

2, # number of supported input types
2, # number of input args
1, # number of output args
0, # `identity` element, never mind this
"mandel", # function name
"mandel(z, c) -> computes iterated z\*z + c", # docstring
0 # unused
)

8.2.4 Generalized ufuncs

ufunc

output = elementwise\_function(input)

Both output and input can be a single array element only.

generalized ufunc

output and input can be arrays with a ﬁxed number of dimensions

For example, matrix trace (sum of diag elements):

input shape = (n, n)
output shape = ()

i.e.

scalar

(n, n) -> ()

Matrix product:

input\_1 shape = (m, n)
input\_2 shape = (n, p)
= (m, p)
output shape

(m, n), (n, p) -> (m, p)

• This is called the “signature” of the generalized ufunc

• The dimensions on which the g-ufunc acts, are “core dimensions”

Status in Numpy

• g-ufuncs are in Numpy already ...
• new ones can be created with PyUFunc\_FromFuncAndDataAndSignature

• ... but we don’t ship with public g-ufuncs, except for testing, ATM

>>> import numpy.core.umath\_tests as ut
>>> ut.matrix\_multiply.signature
'(m,n),(n,p)->(m,p)'

>>> x = np.ones((10, 2, 4))
>>> y = np.ones((10, 4, 5))
>>> ut.matrix\_multiply(x, y).shape
(10, 2, 5)

• the last two dimensions became core dimensions, and are modiﬁed as per the signature

• otherwise, the g-ufunc operates “elementwise”

• matrix multiplication this way could be useful for operating on many small matrices at once

8.2. Universal functions

181

Scipy lecture notes, Edition 2015.2

Generalized ufunc loop

Matrix multiplication (m,n),(n,p) -> (m,p)

void gufunc\_loop(void \*\*args, int \*dimensions, int \*steps, void \*data)
{

char \*input\_1 = (char\*)args[0]; /\* these are as previously \*/
char \*input\_2 = (char\*)args[1];
char \*output = (char\*)args[2];

int input\_1\_stride\_m = steps[3]; /\* strides for the core dimensions \*/
int input\_1\_stride\_n = steps[4]; /\* are added after the non-core \*/
int input\_2\_strides\_n = steps[5]; /\* steps \*/
int input\_2\_strides\_p = steps[6];
int output\_strides\_n = steps[7];
int output\_strides\_p = steps[8];

int m = dimension[1]; /\* core dimensions are added after \*/
int n = dimension[2]; /\* the main dimension; order as in \*/
int p = dimension[3]; /\* signature \*/

int i;

for (i = 0; i < dimensions[0]; ++i) {

matmul\_for\_strided\_matrices(input\_1, input\_2, output,

strides for each array...);

input\_1 += steps[0];
input\_2 += steps[1];
output += steps[2];

}

}

8.3 Interoperability features

8.3.1 Sharing multidimensional, typed data

Suppose you

1. Write a library than handles (multidimensional) binary data,

2. Want to make it easy to manipulate the data with Numpy, or whatever other library,

3.

... but would not like to have Numpy as a dependency.

Currently, 3 solutions:

1. the “old” buffer interface

2. the array interface

3. the “new” buffer interface (PEP 3118)

8.3.2 The old buffer protocol

• Only 1-D buffers

• No data type information
• C-level interface; PyBufferProcs tp\_as\_buffer in the type object

• But it’s integrated into Python (e.g. strings support it)

8.3.

Interoperability features

182

Scipy lecture notes, Edition 2015.2

Mini-exercise using Pillow (Python Imaging Library):

See also:

pilbuffer.py

>>> from PIL import Image
>>> data = np.zeros((200, 200, 4), dtype=np.int8)
>>> data[:, :] = [255, 0, 0, 255] # Red
>>> # In PIL, RGBA images consist of 32-bit integers whose bytes are [RR,GG,BB,AA]
>>> data = data.view(np.int32).squeeze()
>>> img = Image.frombuffer("RGBA", (200, 200), data, "raw", "RGBA", 0, 1)
>>> img.save('test.png')

Q:

Check what happens if data is now modiﬁed, and img saved again.

8.3.3 The old buffer protocol

"""
From buffer
============

Show how to exchange data between numpy and a library that only knows
the buffer interface.
"""

import numpy as np
import Image

# Let's make a sample image, RGBA format

x = np.zeros((200, 200, 4), dtype=np.int8)

x[:,:,0] = 254 # red
x[:,:,3] = 255 # opaque

data = x.view(np.int32) # Check that you understand why this is OK!

img = Image.frombuffer("RGBA", (200, 200), data)
img.save('test.png')

#
# Modify the original data, and save again.
#
# It turns out that PIL, which knows next to nothing about Numpy,
# happily shares the same data.
#

x[:,:,1] = 254
img.save('test2.png')

8.3.

Interoperability features

183

Scipy lecture notes, Edition 2015.2

8.3.4 Array interface protocol

• Multidimensional buffers

• Data type information present

• Numpy-speciﬁc approach; slowly deprecated (but not going away)

• Not integrated in Python otherwise

See also:

Documentation: http://docs.scipy.org/doc/numpy/reference/arrays.interface.html

>>> x = np.array([[1, 2], [3, 4]])
>>> x.\_\_array\_interface\_\_
{'data': (171694552, False),

'descr': [('', '>> from PIL import Image
>>> img = Image.open('data/test.png')
>>> img.\_\_array\_interface\_\_
{'data': ...,

'shape': (200, 200, 4),
'typestr': '|u1'}
>>> x = np.asarray(img)
>>> x.shape
(200, 200, 4)

A more C-friendly variant of the array interface is also deﬁned.

8.4 Array siblings: chararray, maskedarray, matrix

8.4.1 chararray: vectorized string operations

>>> x = np.array(['a', ' bbb', ' ccc']).view(np.chararray)
>>> x.lstrip(' ')
chararray(['a', 'bbb', 'ccc'],

dtype='...')

>>> x.upper()
chararray(['A', ' BBB', ' CCC'],

dtype='...')

.view() has a second meaning: it can make an ndarray an instance of a specialized ndarray subclass

8.4.2 masked\_array missing data

Masked arrays are arrays that may have missing or invalid entries.

For example, suppose we have an array where the fourth entry is invalid:

>>> x = np.array([1, 2, 3, -99, 5])

One way to describe this is to create a masked array:

>>> mx = np.ma.masked\_array(x, mask=[0, 0, 0, 1, 0])
>>> mx
masked\_array(data = [1 2 3 -- 5],

mask = [False False False

True False],

fill\_value = 999999)

Masked mean ignores masked data:

>>> mx.mean()
2.75
>>> np.mean(mx)
2.75

(cid:66)

Not all Numpy functions respect masks, for instance np.dot, so check the return types.

The masked\_array returns a view to the original array:

>>> mx[1] = 9
>>> x
array([

1,

9,

3, -99,

5])

8.4. Array siblings: chararray, maskedarray, matrix

185

Scipy lecture notes, Edition 2015.2

The mask

You can modify the mask by assigning:

>>> mx[1] = np.ma.masked
>>> mx
masked\_array(data = [1 -- 3 -- 5],

mask = [False

True False

True False],

fill\_value = 999999)

The mask is cleared on assignment:

>>> mx[1] = 9
>>> mx
masked\_array(data = [1 9 3 -- 5],

mask = [False False False

True False],

fill\_value = 999999)

The mask is also available directly:

>>> mx.mask
array([False, False, False,

True, False], dtype=bool)

The masked entries can be ﬁlled with a given value to get an usual array back:

>>> x2 = mx.filled(-1)
>>> x2
array([ 1,

3, -1,

9,

5])

The mask can also be cleared:

>>> mx.mask = np.ma.nomask
>>> mx
masked\_array(data = [1 9 3 -99 5],

mask = [False False False False False],

fill\_value = 999999)

Domain-aware functions

The masked array package also contains domain-aware functions:

>>> np.ma.log(np.array([1, 2, -1, -2, 3, -5]))
masked\_array(data = [0.0 0.6931471805599453 -- -- 1.0986122886681098 --],
True

mask = [False False

True False

True],

fill\_value = 1e+20)

Streamlined and more seamless support for dealing with missing data in arrays is making its way into Numpy
1.7. Stay tuned!

8.4. Array siblings: chararray, maskedarray, matrix

186

Scipy lecture notes, Edition 2015.2

Example: Masked statistics

Canadian rangers were distracted when counting hares and lynxes in 1903-1910 and 1917-1918, and got
the numbers are wrong. (Carrot farmers stayed alert, though.) Compute the mean populations over time,
ignoring the invalid numbers.

>>> data = np.loadtxt('data/populations.txt')
>>> populations = np.ma.masked\_array(data[:,1:])
>>> year = data[:, 0]

>>> bad\_years = (((year >= 1903) & (year <= 1910))
| ((year >= 1917) & (year <= 1918)))
...
>>> # '&' means 'and' and '|' means 'or'
>>> populations[bad\_years, 0] = np.ma.masked
>>> populations[bad\_years, 1] = np.ma.masked

>>> populations.mean(axis=0)
masked\_array(data = [40472.72727272727 18627.272727272728 42400.0],

mask = [False False False],

fill\_value = 1e+20)

>>> populations.std(axis=0)
masked\_array(data = [21087.656489006717 15625.799814240254 3322.5062255844787],

mask = [False False False],

fill\_value = 1e+20)

Note that Matplotlib knows about masked arrays:

>>> plt.plot(year, populations, 'o-')
[, ...]

8.4. Array siblings: chararray, maskedarray, matrix

187

1900190519101915192001000020000300004000050000600007000080000Scipy lecture notes, Edition 2015.2

8.4.3 recarray: purely convenience

>>> arr = np.array([('a', 1), ('b', 2)], dtype=[('x', 'S1'), ('y', int)])
>>> arr2 = arr.view(np.recarray)
>>> arr2.x
chararray(['a', 'b'],

dtype='|S1')

>>> arr2.y
array([1, 2])

8.4.4 matrix: convenience?

• always 2-D
• \* is the matrix product, not the elementwise one

>>> np.matrix([[1, 0], [0, 1]]) \* np.matrix([[1, 2], [3, 4]])
matrix([[1, 2],

[3, 4]])

8.5 Summary

• Anatomy of the ndarray: data, dtype, strides.

• Universal functions: elementwise operations, how to make new ones

• Ndarray subclasses

• Various buffer interfaces for integration with other tools

• Recent additions: PEP 3118, generalized ufuncs

8.6 Contributing to Numpy/Scipy

Get this tutorial: http://www.euroscipy.org/talk/882

8.6.1 Why

• “There’s a bug?”

• “I don’t understand what this is supposed to do?”

• “I have this fancy code. Would you like to have it?”

• “I’d like to help! What can I do?”

8.6.2 Reporting bugs

• Bug tracker (prefer this)

– http://projects.scipy.org/numpy

– http://projects.scipy.org/scipy

– Click the “Register” link to get an account

• Mailing lists ( scipy.org/Mailing\_Lists )

– If you’re unsure

8.5. Summary

188

Scipy lecture notes, Edition 2015.2

– No replies in a week or so? Just ﬁle a bug ticket.

Good bug report

Title: numpy.random.permutations fails for non-integer arguments

I'm trying to generate random permutations, using numpy.random.permutations

When calling numpy.random.permutation with non-integer arguments
it fails with a cryptic error message::

>>> np.random.permutation(12)
array([ 6, 11,
8,
>>> np.random.permutation(12.)
Traceback (most recent call last):

4, 10,

2,

1,

7,

9,

3,

0,

5])

File "", line 1, in 
File "mtrand.pyx", line 3311, in mtrand.RandomState.permutation
File "mtrand.pyx", line 3254, in mtrand.RandomState.shuffle

TypeError: len() of unsized object

This also happens with long arguments, and so
np.random.permutation(X.shape[0]) where X is an array fails on 64
bit windows (where shape is a tuple of longs).

It would be great if it could cast to integer or at least raise a
proper error for non-integer types.

I'm using Numpy 1.4.1, built from the official tarball, on Windows
64 with Visual studio 2008, on Python.org 64-bit Python.

0. What are you trying to do?

1. Small code snippet reproducing the bug (if possible)

• What actually happens

• What you’d expect

2. Platform (Windows / Linux / OSX, 32/64 bits, x86/PPC, ...)

3. Version of Numpy/Scipy

>>> print(np.\_\_version\_\_)
1...

Check that the following is what you expect

>>> print(np.\_\_file\_\_)
/...

In case you have old/broken Numpy installations lying around.

If unsure, try to remove existing Numpy installations, and reinstall...

8.6.3 Contributing to documentation

1. Documentation editor

• http://docs.scipy.org/doc/numpy

• Registration

– Register an account
– Subscribe to scipy-dev mailing list (subscribers-only)

8.6. Contributing to Numpy/Scipy

189

Scipy lecture notes, Edition 2015.2

– Problem with mailing lists: you get mail

\* But: you can turn mail delivery off

\* “change your subscription options”, at the bottom of

http://mail.scipy.org/mailman/listinfo/scipy-dev

– Send a mail @ scipy-dev mailing list; ask for activation:

To: scipy-dev@scipy.org

Hi,

I'd like to edit Numpy/Scipy docstrings. My account is XXXXX

Cheers,
N. N.

• Check the style guide:

– http://docs.scipy.org/doc/numpy/

– Don’t be intimidated; to ﬁx a small thing, just ﬁx it

• Edit

2. Edit sources and send patches (as for bugs)

3. Complain on the mailing list

8.6.4 Contributing features

0. Ask on mailing list, if unsure where it should go

1. Write a patch, add an enhancement ticket on the bug tracket

2. OR, create a Git branch implementing the feature + add enhancement ticket.

• Especially for big/invasive additions

• http://projects.scipy.org/numpy/wiki/GitMirror

• http://www.spheredev.org/wiki/Git\_for\_the\_lazy

# Clone numpy repository
git clone --origin svn http://projects.scipy.org/git/numpy.git numpy
cd numpy

# Create a feature branch
git checkout -b name-of-my-feature-branch

svn/trunk



git commit -a

• Create account on https://github.com (or anywhere)

• Create a new repository @ Github

• Push your work to github

git remote add github git@github:USERNAME/REPOSITORYNAME.git
git push github name-of-my-feature-branch

8.6. Contributing to Numpy/Scipy

190

Scipy lecture notes, Edition 2015.2

8.6.5 How to help, in general

• Bug ﬁxes always welcome!

– What irks you most

– Browse the tracker

• Documentation work

– API docs: improvements to docstrings

\* Know some Scipy module well?

– User guide

\* Needs to be done eventually.

\* Want to think? Come up with a Table of Contents

http://scipy.org/Developer\_Zone/UG\_Toc

• Ask on communication channels:
– numpy-discussion list
– scipy-dev list

8.6. Contributing to Numpy/Scipy

191

CHAPTER 9

Debugging code

Author: Gaël Varoquaux

This section explores tools to understand better your code base: debugging, to ﬁnd and ﬁx bugs.

It is not speciﬁc to the scientiﬁc Python community, but the strategies that we will employ are tailored to its
needs.

Prerequisites

• Numpy
• IPython
• nosetests (http://readthedocs.org/docs/nose/en/latest/)
• pyﬂakes (http://pypi.python.org/pypi/pyﬂakes)
• gdb for the C-debugging part.

Chapter contents

• Avoiding bugs

– Coding best practices to avoid getting in trouble
– pyﬂakes: fast static analysis

• Debugging workﬂow
• Using the Python debugger
– Invoking the debugger
– Debugger commands and interaction

• Debugging segmentation faults using gdb

9.1 Avoiding bugs

9.1.1 Coding best practices to avoid getting in trouble

Brian Kernighan

“Everyone knows that debugging is twice as hard as writing a program in the ﬁrst place. So if you’re as
clever as you can be when you write it, how will you ever debug it?”

• We all write buggy code. Accept it. Deal with it.

• Write your code with testing and debugging in mind.

• Keep It Simple, Stupid (KISS).

192

Scipy lecture notes, Edition 2015.2

– What is the simplest thing that could possibly work?

• Don’t Repeat Yourself (DRY).

– Every piece of knowledge must have a single, unambiguous, authoritative representation within a

system.

– Constants, algorithms, etc...

• Try to limit interdependencies of your code. (Loose Coupling)

• Give your variables, functions and modules meaningful names (not mathematics names)

9.1.2 pyflakes: fast static analysis

They are several static analysis tools in Python; to name a few:

• pylint

• pychecker

• pyﬂakes

• pep8

• ﬂake8

Here we focus on pyflakes, which is the simplest tool.

• Fast, simple

• Detects syntax errors, missing imports, typos on names.

Another good recommendation is the flake8 tool which is a combination of pyﬂakes and pep8. Thus, in
addition to the types of errors that pyﬂakes catches, ﬂake8 detects violations of the recommendation in PEP8
style guide.

Integrating pyﬂakes (or ﬂake8) in your editor or IDE is highly recommended, it does yield productivity gains.

Running pyflakes on the current edited file

You can bind a key to run pyﬂakes in the current buffer.

• In kate Menu: ‘settings -> conﬁgure kate

– In plugins enable ‘external tools’
– In external Tools’, add pyflakes:

kdialog --title "pyflakes %filename" --msgbox "$(pyflakes %filename)"

• In TextMate

Menu: TextMate -> Preferences -> Advanced -> Shell variables, add a shell variable:

TM\_PYCHECKER = /Library/Frameworks/Python.framework/Versions/Current/bin/pyflakes

Then Ctrl-Shift-V is binded to a pyﬂakes report

• In vim In your vimrc (binds F5 to pyflakes):

autocmd FileType python let ∓ = 'echo "\*\*\* running % \*\*\*" ; pyflakes %'
autocmd FileType tex,mp,rst,python imap [15~ :make!^M
autocmd FileType tex,mp,rst,python map
autocmd FileType tex,mp,rst,python set autowrite

[15~ :make!^M

• In emacs In your emacs (binds F5 to pyflakes):

9.1. Avoiding bugs

193

Scipy lecture notes, Edition 2015.2

(defun pyflakes-thisfile () (interactive)

(compile (format "pyflakes %s" (buffer-file-name)))

)

(define-minor-mode pyflakes-mode

"Toggle pyflakes mode.
With no argument, this command toggles the mode.
Non-null prefix argument turns on the mode.
Null prefix argument turns off the mode."
;; The initial value.
nil
;; The indicator for the mode line.
" Pyflakes"
;; The minor mode bindings.
'( ([f5] . pyflakes-thisfile) )

)

(add-hook 'python-mode-hook (lambda () (pyflakes-mode t)))

A type-as-go spell-checker like integration

• In vim

– Use the pyﬂakes.vim plugin:

1. download the zip ﬁle from http://www.vim.org/scripts/script.php?script\_id=2441
2. extract the ﬁles in ~/.vim/ftplugin/python
3. make sure your vimrc has filetype plugin indent on

– Alternatively: use the syntastic plugin. This can be conﬁgured to use flake8 too and also handles

on-the-ﬂy checking for many other languages.

• In

emacs

documented
http://www.plope.com/Members/chrism/ﬂymake-mode : add the following to your .emacs ﬁle:

pyﬂakes,

ﬂymake

mode

with

Use

the

(when (load "flymake" t)

(defun flymake-pyflakes-init ()
(let\* ((temp-file (flymake-init-create-temp-buffer-copy

'flymake-create-temp-inplace))

(local-file (file-relative-name

temp-file

9.1. Avoiding bugs

on

194

Scipy lecture notes, Edition 2015.2

(file-name-directory buffer-file-name))))

(list "pyflakes" (list local-file))))

(add-to-list 'flymake-allowed-file-name-masks
'("\\.py\\'" flymake-pyflakes-init)))

(add-hook 'find-file-hook 'flymake-find-file-hook)

9.2 Debugging workflow

If you do have a non trivial bug, this is when debugging strategies kick in. There is no silver bullet. Yet, strategies
help:

For debugging a given problem, the favorable situation is when the problem is isolated in a
small number of lines of code, outside framework or application code, with short modify-run-
fail cycles

1. Make it fail reliably. Find a test case that makes the code fail every time.

2. Divide and Conquer. Once you have a failing test case, isolate the failing code.

• Which module.

• Which function.

• Which line of code.

=> isolate a small reproducible failure: a test case

3. Change one thing at a time and re-run the failing test case.

4. Use the debugger to understand what is going wrong.

5. Take notes and be patient. It may take a while.

Once you have gone through this process: isolated a tight piece of code reproducing the bug and ﬁx the bug
using this piece of code, add the corresponding code to your test suite.

9.3 Using the Python debugger

The python debugger, pdb: https://docs.python.org/library/pdb.html, allows you to inspect your code inter-
actively.

Speciﬁcally it allows you to:

• View the source code.

• Walk up and down the call stack.

• Inspect values of variables.

• Modify values of variables.

• Set breakpoints.

print
Yes, print statements do work as a debugging tool. However to inspect runtime, it is often more efﬁcient
to use the debugger.

9.2. Debugging workflow

195

Scipy lecture notes, Edition 2015.2

9.3.1 Invoking the debugger

Ways to launch the debugger:

1. Postmortem, launch debugger after module errors.

2. Launch the module with the debugger.

3. Call the debugger inside the module

Postmortem

Situation: You’re working in IPython and you get a traceback.
Here we debug the ﬁle index\_error.py. When running it, an IndexError is raised. Type %debug and drop
into the debugger.

In [1]: %run index\_error.py
---------------------------------------------------------------------------
Traceback (most recent call last)
IndexError
/home/varoquau/dev/scipy-lecture-notes/advanced/debugging/index\_error.py in ()

6
7 if \_\_name\_\_ == '\_\_main\_\_':

----> 8
9

index\_error()

/home/varoquau/dev/scipy-lecture-notes/advanced/debugging/index\_error.py in index\_error()

3 def index\_error():
4
----> 5
6
7 if \_\_name\_\_ == '\_\_main\_\_':

lst = list('foobar')
print lst[len(lst)]

IndexError: list index out of range

In [2]: %debug
> /home/varoquau/dev/scipy-lecture-notes/advanced/debugging/index\_error.py(5)index\_error()

lst = list('foobar')
print lst[len(lst)]

4
----> 5
6

ipdb> list

1 """Small snippet to raise an IndexError."""
2
3 def index\_error():
4
----> 5
6
7 if \_\_name\_\_ == '\_\_main\_\_':
8
9

lst = list('foobar')
print lst[len(lst)]

index\_error()

ipdb> len(lst)
6
ipdb> print lst[len(lst)-1]
r
ipdb> quit

In [3]:

9.3. Using the Python debugger

196

Scipy lecture notes, Edition 2015.2

Post-mortem debugging without IPython

In some situations you cannot use IPython, for instance to debug a script that wants to be called from
the command line. In this case, you can call the script with python -m pdb script.py:

$ python -m pdb index\_error.py
> /home/varoquau/dev/scipy-lecture-notes/advanced/optimizing/index\_error.py(1)()
-> """Small snippet to raise an IndexError."""
(Pdb) continue
Traceback (most recent call last):
File "/usr/lib/python2.6/pdb.py", line 1296, in main

pdb.\_runscript(mainpyfile)

File "/usr/lib/python2.6/pdb.py", line 1215, in \_runscript

self.run(statement)

File "/usr/lib/python2.6/bdb.py", line 372, in run

exec cmd in globals, locals
File "", line 1, in 
File "index\_error.py", line 8, in 

index\_error()

File "index\_error.py", line 5, in index\_error

print lst[len(lst)]

IndexError: list index out of range
Uncaught exception. Entering post mortem debugging
Running 'cont' or 'step' will restart the program
> /home/varoquau/dev/scipy-lecture-notes/advanced/optimizing/index\_error.py(5)index\_error()
-> print lst[len(lst)]
(Pdb)

Step-by-step execution

Situation: You believe a bug exists in a module but are not sure where.
For instance we are trying to debug wiener\_filtering.py. Indeed the code runs, but the ﬁltering does not
work well.

• Run the script in IPython with the debugger using %run -d wiener\_filtering.p :

In [1]: %run -d wiener\_filtering.py
\*\*\* Blank or comment
\*\*\* Blank or comment
\*\*\* Blank or comment
Breakpoint 1 at /home/varoquau/dev/scipy-lecture-notes/advanced/optimizing/wiener\_filtering.py:4
NOTE: Enter 'c' at the ipdb>
> (1)()

prompt to start your script.

• Set a break point at line 34 using b 34:

ipdb> n
> /home/varoquau/dev/scipy-lecture-notes/advanced/optimizing/wiener\_filtering.py(4)()

3

1---> 4 import numpy as np
5 import scipy as sp

ipdb> b 34
Breakpoint 2 at /home/varoquau/dev/scipy-lecture-notes/advanced/optimizing/wiener\_filtering.py:34

• Continue execution to next breakpoint with c(ont(inue)):

ipdb> c
> /home/varoquau/dev/scipy-lecture-notes/advanced/optimizing/wiener\_filtering.py(34)iterated\_wiener()

33

"""

9.3. Using the Python debugger

197

Scipy lecture notes, Edition 2015.2

2--> 34
35

noisy\_img = noisy\_img
denoised\_img = local\_mean(noisy\_img, size=size)

• Step into code with n(ext) and s(tep): next jumps to the next statement in the current execution

context, while step will go across execution contexts, i.e. enable exploring inside function calls:

ipdb> s
> /home/varoquau/dev/scipy-lecture-notes/advanced/optimizing/wiener\_filtering.py(35)iterated\_wiener()
2
34
---> 35
36

noisy\_img = noisy\_img
denoised\_img = local\_mean(noisy\_img, size=size)
l\_var = local\_var(noisy\_img, size=size)

ipdb> n
> /home/varoquau/dev/scipy-lecture-notes/advanced/optimizing/wiener\_filtering.py(36)iterated\_wiener()

35
---> 36
37

denoised\_img = local\_mean(noisy\_img, size=size)
l\_var = local\_var(noisy\_img, size=size)
for i in range(3):

• Step a few lines and explore the local variables:

ipdb> n
> /home/varoquau/dev/scipy-lecture-notes/advanced/optimizing/wiener\_filtering.py(37)iterated\_wiener()

36
---> 37
38

l\_var = local\_var(noisy\_img, size=size)
for i in range(3):

res = noisy\_img - denoised\_img

ipdb> print l\_var
[[5868 5379 5316 ..., 5071 4799 5149]
262 4355]
604 3377]

437 ...,
344 ...,

346
392

363
410

362
392
789

308 ...,
290 ...,
736 ..., 1835 1725 1940]]

198 1632]
263 1653]

275
248

[5013
[5379
...,
[ 435
[ 548
[ 466

ipdb> print l\_var.min()
0

Oh dear, nothing but integers, and 0 variation. Here is our bug, we are doing integer arithmetic.

9.3. Using the Python debugger

198

Scipy lecture notes, Edition 2015.2

Raising exception on numerical errors
When we run the wiener\_filtering.py ﬁle, the following warnings are raised:

In [2]: %run wiener\_filtering.py
wiener\_filtering.py:40: RuntimeWarning: divide by zero encountered in divide

noise\_level = (1 - noise/l\_var )

We can turn these warnings in exception, which enables us to do post-mortem debugging on them, and
ﬁnd our problem more quickly:

In [3]: np.seterr(all='raise')
Out[3]: {'divide': 'print', 'invalid': 'print', 'over': 'print', 'under': 'ignore'}
In [4]: %run wiener\_filtering.py
---------------------------------------------------------------------------
FloatingPointError
Traceback (most recent call last)
/home/esc/anaconda/lib/python2.7/site-packages/IPython/utils/py3compat.pyc in execfile(fname, \*where)

176
177
--> 178

else:

filename = fname

\_\_builtin\_\_.execfile(filename, \*where)

/home/esc/physique-cuso-python-2013/scipy-lecture-notes/advanced/debugging/wiener\_filtering.py in ()

55 pl.matshow(noisy\_lena[cut], cmap=pl.cm.gray)
56

---> 57 denoised\_lena = iterated\_wiener(noisy\_lena)

58 pl.matshow(denoised\_lena[cut], cmap=pl.cm.gray)
59

/home/esc/physique-cuso-python-2013/scipy-lecture-notes/advanced/debugging/wiener\_filtering.py in iterated\_wiener(noisy\_img, size)

38
39
---> 40
41
42

res = noisy\_img - denoised\_img
noise = (res\*\*2).sum()/res.size
noise\_level = (1 - noise/l\_var )
noise\_level[noise\_level<0] = 0
denoised\_img += noise\_level\*res

FloatingPointError: divide by zero encountered in divide

Other ways of starting a debugger

• Raising an exception as a poor man break point

If you ﬁnd it tedious to note the line number to set a break point, you can simply raise an exception at
the point that you want to inspect and use IPython’s %debug. Note that in this case you cannot step or
continue the execution.

• Debugging test failures using nosetests

You can run nosetests --pdb to drop in post-mortem debugging on exceptions, and nosetests
--pdb-failure to inspect test failures using the debugger.

In addition, you can use the IPython interface for the debugger in nose by installing the nose plugin
ipdbplugin. You can than pass --ipdb and --ipdb-failure options to nosetests.

• Calling the debugger explicitly

Insert the following line where you want to drop in the debugger:

import pdb; pdb.set\_trace()

(cid:66)

When running nosetests, the output is captured, and thus it seems that the debugger does not work. Simply
run the nosetests with the -s ﬂag.

9.3. Using the Python debugger

199

Scipy lecture notes, Edition 2015.2

Graphical debuggers and alternatives

• For stepping through code and inspecting variables, you might ﬁnd it more convenient to use a

graphical debugger such as winpdb.

• Alternatively, pudb is a good semi-graphical debugger with a text user interface in the console.
• Also, the pydbgr project is probably worth looking at.

9.3.2 Debugger commands and interaction

l(list)
u(p)
d(own)
n(ext)
s(tep)
bt
a
!command

Lists the code at the current position
Walk up the call stack
Walk down the call stack
Execute the next line (does not go down in new functions)
Execute the next statement (goes down in new functions)
Print the call stack
Print the local variables
Execute the given Python command (by opposition to pdb commands

(cid:66)

Debugger commands are not Python code
You cannot name the variables the way you want. For instance, if in you cannot override the variables in the
current frame with the same name: use different names than your local variable when typing code in the
debugger.

Getting help when in the debugger

Type h or help to access the interactive help:

ipdb> help

Documented commands (type help ):
========================================
cont
EOF
continue
a
d
alias
debug
args
disable
b
down
break

bt
c
cl
clear
commands
condition

enable
exit
h
help
ignore
j

jump pdef
pdoc
l
pinfo
list
pp
n
q
next
quit
p

w
whatis
where

r
restart
return
run
s
step

tbreak
u
unalias
unt
until
up

Miscellaneous help topics:
==========================
exec

pdb

Undocumented commands:
======================
retval

rv

9.4 Debugging segmentation faults using gdb

If you have a segmentation fault, you cannot debug it with pdb, as it crashes the Python interpreter before it
can drop in the debugger. Similarly, if you have a bug in C code embedded in Python, pdb is useless. For this
we turn to the gnu debugger, gdb, available on Linux.

Before we start with gdb, let us add a few Python-speciﬁc tools to it. For this we add a few macros to our
~/.gbdinit. The optimal choice of macro depends on your Python version and your gdb version. I have
added a simpliﬁed version in gdbinit, but feel free to read DebuggingWithGdb.

9.4. Debugging segmentation faults using gdb

200

Scipy lecture notes, Edition 2015.2

To debug with gdb the Python script segfault.py, we can run the script in gdb as follows

$ gdb python
...
(gdb) run segfault.py
Starting program: /usr/bin/python segfault.py
[Thread debugging using libthread\_db enabled]

Program received signal SIGSEGV, Segmentation fault.
\_strided\_byte\_copy (dst=0x8537478 "\360\343G", outstrides=4, src=

0x86c0690 , instrides=32, N=3,
elsize=4)

at numpy/core/src/multiarray/ctors.c:365

\_FAST\_MOVE(Int32);

365
(gdb)

We get a segfault, and gdb captures it for post-mortem debugging in the C level stack (not the Python call
stack). We can debug the C call stack using gdb’s commands:

(gdb) up
#1

0x004af4f5 in \_copy\_from\_same\_shape (dest=,
src=, myfunc=0x496780 <\_strided\_byte\_copy>,
swap=0)

at numpy/core/src/multiarray/ctors.c:748
748

myfunc(dit->dataptr, dest->strides[maxaxis],

As you can see, right now, we are in the C code of numpy. We would like to know what is the Python code that
triggers this segfault, so we go up the stack until we hit the Python execution loop:

(gdb) up
#8

0x080ddd23 in call\_function (f=
Frame 0x85371ec, for file /home/varoquau/usr/lib/python2.6/site-packages/numpy/core/arrayprint.py, line 156, in \_leading\_trailing (a=, \_nc=), throwflag=0)
at ../Python/ceval.c:3750

3750

../Python/ceval.c: No such file or directory.
in ../Python/ceval.c

(gdb) up
#9

PyEval\_EvalFrameEx (f=
Frame 0x85371ec, for file /home/varoquau/usr/lib/python2.6/site-packages/numpy/core/arrayprint.py, line 156, in \_leading\_trailing (a=, \_nc=), throwflag=0)
at ../Python/ceval.c:2412

2412
(gdb)

in ../Python/ceval.c

Once we are in the Python execution loop, we can use our special Python helper function. For instance we can
ﬁnd the corresponding Python code:

(gdb) pyframe
/home/varoquau/usr/lib/python2.6/site-packages/numpy/core/arrayprint.py (158): \_leading\_trailing
(gdb)

This is numpy code, we need to go up until we ﬁnd code that we have written:

(gdb) up
...
(gdb) up
#34 0x080dc97a in PyEval\_EvalFrameEx (f=

Frame 0x82f064c, for file segfault.py, line 11, in print\_big\_array (small\_array=, big\_array=), throwflag=0) at ../Python/ceval.c:1630

1630

../Python/ceval.c: No such file or directory.
in ../Python/ceval.c

(gdb) pyframe
segfault.py (12): print\_big\_array

The corresponding code is:

9.4. Debugging segmentation faults using gdb

201

Scipy lecture notes, Edition 2015.2

def make\_big\_array(small\_array):

big\_array = stride\_tricks.as\_strided(small\_array,

shape=(2e6, 2e6), strides=(32, 32))

return big\_array

def print\_big\_array(small\_array):

big\_array = make\_big\_array(small\_array)

Thus the segfault happens when printing big\_array[-10:]. The reason is simply that big\_array has been
allocated with its end outside the program memory.

For a list of Python-speciﬁc commands deﬁned in the gdbinit, read the source of this ﬁle.

Wrap up exercise

The following script is well documented and hopefully legible. It seeks to answer a problem of actual
interest for numerical computing, but it does not work... Can you debug it?
Python source code: to\_debug.py

9.4. Debugging segmentation faults using gdb

202

CHAPTER 10

Optimizing code

Donald Knuth

“Premature optimization is the root of all evil”

Author: Gaël Varoquaux

This chapter deals with strategies to make Python code go faster.

Prerequisites

• line\_proﬁler

Chapters contents

• Optimization workﬂow
• Proﬁling Python code

– Timeit
– Proﬁler
– Line-proﬁler
• Making code go faster

– Algorithmic optimization
\* Example of the SVD
• Writing faster numerical code

– Additional Links

10.1 Optimization workflow

1. Make it work: write the code in a simple legible ways.

2. Make it work reliably: write automated test cases, make really sure that your algorithm is right and that

if you break it, the tests will capture the breakage.

3. Optimize the code by proﬁling simple use-cases to ﬁnd the bottlenecks and speeding up these bottle-
neck, ﬁnding a better algorithm or implementation. Keep in mind that a trade off should be found be-
tween proﬁling on a realistic example and the simplicity and speed of execution of the code. For efﬁcient
work, it is best to work with proﬁling runs lasting around 10s.

10.2 Profiling Python code

203

Scipy lecture notes, Edition 2015.2

No optimization without measuring!

• Measure: proﬁling, timing
• You’ll have surprises: the fastest code is not always what you think

10.2.1 Timeit

In IPython, use timeit (https://docs.python.org/library/timeit.html) to time elementary operations:

In [1]: import numpy as np

In [2]: a = np.arange(1000)

In [3]: %timeit a \*\* 2
100000 loops, best of 3: 5.73 us per loop

In [4]: %timeit a \*\* 2.1
1000 loops, best of 3: 154 us per loop

In [5]: %timeit a \* a
100000 loops, best of 3: 5.56 us per loop

Use this to guide your choice between strategies.

For long running calls, using %time instead of %timeit; it is less precise but faster

10.2.2 Profiler

Useful when you have a large program to proﬁle, for example the following file:

# For this example to run, you also need the 'ica.py' file

import numpy as np
from scipy import linalg

from ica import fastica

def test():

data = np.random.random((5000, 100))
u, s, v = linalg.svd(data)
pca = np.dot(u[:, :10].T, data)
results = fastica(pca.T, whiten=False)

if \_\_name\_\_ == '\_\_main\_\_':

test()

This is a combination of two unsupervised learning techniques, principal component analysis (PCA) and in-
dependent component analysis (ICA). PCA is a technique for dimensionality reduction, i.e. an algorithm to
explain the observed variance in your data using less dimensions. ICA is a source seperation technique, for ex-
ample to unmix multiple signals that have been recorded through multiple sensors. Doing a PCA ﬁrst and then
an ICA can be useful if you have more sensors than signals. For more information see: the FastICA example
from scikits-learn.
To run it, you also need to download the ica module. In IPython we can time the script:

In [1]: %run -t demo.py

IPython CPU timings (estimated):

10.2. Profiling Python code

204

Scipy lecture notes, Edition 2015.2

:
User
System:

14.3929 s.
0.256016 s.

and proﬁle it:

In [2]: %run -p demo.py

916 function calls in 14.551 CPU seconds

Ordered by: internal time

ncalls
1
1
1
54
2
6
6
14
19
1
1
107
7
7
172
1
29
35
35
21
41
28
1
...

tottime
14.457
0.054
0.017
0.011
0.005
0.001
0.001
0.001
0.001
0.001
0.001
0.000
0.000
0.000
0.000
0.000
0.000
0.000
0.000
0.000
0.000
0.000
0.000

percall
14.457
0.054
0.017
0.000
0.002
0.000
0.000
0.000
0.000
0.001
0.001
0.000
0.000
0.000
0.000
0.000
0.000
0.000
0.000
0.000
0.000
0.000
0.000

cumtime
14.479
0.054
0.021
0.011
0.005
0.001
0.001
0.001
0.001
0.008
14.551
0.001
0.004
0.002
0.000
14.551
0.000
0.000
0.001
0.001
0.000
0.000
0.008

percall filename:lineno (function)

14.479 decomp.py:849 (svd)

0.054 {method 'random\_sample' of 'mtrand.RandomState' objects}
0.021 function\_base.py:645 (asarray\_chkfinite)
0.000 {numpy.core.\_dotblas.dot}
0.002 {method 'any' of 'numpy.ndarray' objects}
0.000 ica.py:195 (gprime)
0.000 ica.py:192 (g)
0.000 {numpy.linalg.lapack\_lite.dsyevd}
0.000 twodim\_base.py:204 (diag)
0.008 ica.py:69 (\_ica\_par)

14.551 {execfile}

0.000 defmatrix.py:239 (\_\_array\_finalize\_\_)
0.001 ica.py:58 (\_sym\_decorrelation)
0.000 linalg.py:841 (eigh)
0.000 {isinstance}

14.551 demo.py:1 ()

0.000 numeric.py:180 (asarray)
0.000 defmatrix.py:193 (\_\_new\_\_)
0.000 defmatrix.py:43 (asmatrix)
0.000 defmatrix.py:287 (\_\_mul\_\_)
0.000 {numpy.core.multiarray.zeros}
0.000 {method 'transpose' of 'numpy.ndarray' objects}
0.008 ica.py:97 (fastica)

Clearly the svd (in decomp.py) is what takes most of our time, a.k.a. the bottleneck. We have to ﬁnd a way to
make this step go faster, or to avoid this step (algorithmic optimization). Spending time on the rest of the code
is useless.

Proﬁling outside of IPython, running ‘‘cProﬁle‘‘
Similar proﬁling can be done outside of IPython, simply calling the built-in Python proﬁlers cProfile
and profile.

$ python -m cProfile -o demo.prof demo.py
Using the -o switch will output the proﬁler results to the ﬁle demo.prof to view with an external tool.
This can be useful if you wish to process the proﬁler output with a visualization tool.

10.2.3 Line-profiler

The proﬁler tells us which function takes most of the time, but not where it is called.

For this, we use the line\_proﬁler: in the source ﬁle, we decorate a few functions that we want to inspect with
@profile (no need to import it)

@profile
def test():

data = np.random.random((5000, 100))

10.2. Profiling Python code

205

Scipy lecture notes, Edition 2015.2

u, s, v = linalg.svd(data)
pca = np.dot(u[:, :10], data)
results = fastica(pca.T, whiten=False)

Then we run the script using the kernprof.py program, with switches -l, --line-by-line and -v, --view
to use the line-by-line proﬁler and view the results in addition to saving them:

$ kernprof.py -l -v demo.py

Wrote profile results to demo.py.lprof
Timer unit: 1e-06 s

File: demo.py
Function: test at line 5
Total time: 14.2793 s

Line #
Line Contents
=========== ============ ===== ========= ======= ==== ========

Per Hit

% Time

Hits

Time

5
6
7
8
9
10

@profile
def test():

1
1
1
1

19015

19015.0

14242163 14242163.0

10282
7799

10282.0
7799.0

0.1
99.7
0.1
0.1

data = np.random.random((5000, 100))
u, s, v = linalg.svd(data)
pca = np.dot(u[:10, :], data)
results = fastica(pca.T, whiten=False)

The SVD is taking all the time. We need to optimise this line.

10.3 Making code go faster

Once we have identiﬁed the bottlenecks, we need to make the corresponding code go faster.

10.3.1 Algorithmic optimization

The ﬁrst thing to look for is algorithmic optimization: are there ways to compute less, or better?

For a high-level view of the problem, a good understanding of the maths behind the algorithm helps. However,
it is not uncommon to ﬁnd simple changes, like moving computation or memory allocation outside a for
loop, that bring in big gains.

Example of the SVD

In both examples above, the SVD - Singular Value Decomposition - is what takes most of the time. Indeed, the
computational cost of this algorithm is roughly n3 in the size of the input matrix.

However, in both of these example, we are not using all the output of the SVD, but only the ﬁrst few rows of
its ﬁrst return argument. If we use the svd implementation of scipy, we can ask for an incomplete version of
the SVD. Note that implementations of linear algebra in scipy are richer then those in numpy and should be
preferred.

In [3]: %timeit np.linalg.svd(data)
1 loops, best of 3: 14.5 s per loop

In [4]: from scipy import linalg

In [5]: %timeit linalg.svd(data)
1 loops, best of 3: 14.2 s per loop

In [6]: %timeit linalg.svd(data, full\_matrices=False)
1 loops, best of 3: 295 ms per loop

10.3. Making code go faster

206

Scipy lecture notes, Edition 2015.2

In [7]: %timeit np.linalg.svd(data, full\_matrices=False)
1 loops, best of 3: 293 ms per loop

We can then use this insight to optimize the previous code:

def test():

data = np.random.random((5000, 100))
u, s, v = linalg.svd(data, full\_matrices=False)
pca = np.dot(u[:, :10].T, data)
results = fastica(pca.T, whiten=False)

In [1]: import demo

In [2]: %timeit demo.
demo.np
demo.fastica
demo.prof
demo.linalg

demo.prof.pdf
demo.prof.png

demo.py
demo.py.lprof

demo.pyc
demo.test

In [2]: %timeit demo.test()
ica.py:65: RuntimeWarning: invalid value encountered in sqrt

W = (u \* np.diag(1.0/np.sqrt(s)) \* u.T) \* W

# W = (W \* W.T) ^{-1/2} \* W

1 loops, best of 3: 17.5 s per loop

In [3]: import demo\_opt

In [4]: %timeit demo\_opt.test()
1 loops, best of 3: 208 ms per loop

Real incomplete SVDs, e.g. computing only the ﬁrst 10 eigenvectors, can be computed with arpack, available
in scipy.sparse.linalg.eigsh.

Computational linear algebra

For certain algorithms, many of the bottlenecks will be linear algebra computations. In this case, using
the right function to solve the right problem is key. For instance, an eigenvalue problem with a symmetric
matrix is easier to solve than with a general matrix. Also, most often, you can avoid inverting a matrix and
use a less costly (and more numerically stable) operation.
Know your computational linear algebra. When in doubt, explore scipy.linalg, and use %timeit to
try out different alternatives on your data.

10.4 Writing faster numerical code

A complete discussion on advanced use of numpy is found in chapter Advanced Numpy, or in the article The
NumPy array: a structure for efﬁcient numerical computation by van der Walt et al. Here we discuss only some
commonly encountered tricks to make code faster.

• Vectorizing for loops

Find tricks to avoid for loops using numpy arrays. For this, masks and indices arrays can be useful.

• Broadcasting

Use broadcasting to do operations on arrays as small as possible before combining them.

• In place operations

In [1]: a = np.zeros(1e7)

In [2]: %timeit global a ; a = 0\*a
10 loops, best of 3: 111 ms per loop

10.4. Writing faster numerical code

207

Scipy lecture notes, Edition 2015.2

In [3]: %timeit global a ; a \*= 0
10 loops, best of 3: 48.4 ms per loop

note: we need global a in the timeit so that it work, as it is assigning to a, and thus considers it as a
local variable.

• Be easy on the memory: use views, and not copies

Copying big arrays is as costly as making simple numerical operations on them:

In [1]: a = np.zeros(1e7)

In [2]: %timeit a.copy()
10 loops, best of 3: 124 ms per loop

In [3]: %timeit a + 1
10 loops, best of 3: 112 ms per loop

• Beware of cache effects

Memory access is cheaper when it is grouped: accessing a big array in a continuous way is much faster
than random access. This implies amongst other things that smaller strides are faster (see CPU cache
effects):

In [1]: c = np.zeros((1e4, 1e4), order='C')

In [2]: %timeit c.sum(axis=0)
1 loops, best of 3: 3.89 s per loop

In [3]: %timeit c.sum(axis=1)
1 loops, best of 3: 188 ms per loop

In [4]: c.strides
Out[4]: (80000, 8)

This is the reason why Fortran ordering or C ordering may make a big difference on operations:

In [5]: a = np.random.rand(20, 2\*\*18)

In [6]: b = np.random.rand(20, 2\*\*18)

In [7]: %timeit np.dot(b, a.T)
1 loops, best of 3: 194 ms per loop

In [8]: c = np.ascontiguousarray(a.T)

In [9]: %timeit np.dot(b, c)
10 loops, best of 3: 84.2 ms per loop

Note that copying the data to work around this effect may not be worth it:

In [10]: %timeit c = np.ascontiguousarray(a.T)
10 loops, best of 3: 106 ms per loop

Using numexpr can be useful to automatically optimize code for such effects.

• Use compiled code

The last resort, once you are sure that all the high-level optimizations have been explored, is to transfer
the hot spots, i.e. the few lines or functions in which most of the time is spent, to compiled code. For
compiled code, the preferred option is to use Cython: it is easy to transform exiting Python code in
compiled code, and with a good use of the numpy support yields efﬁcient code on numpy arrays, for
instance by unrolling loops.

(cid:66)

For all the above: proﬁle and time your choices. Don’t base your optimization on theoretical considerations.

10.4. Writing faster numerical code

208

Scipy lecture notes, Edition 2015.2

10.4.1 Additional Links

• If you need to proﬁle memory usage, you could try the memory\_proﬁler

• If you need to proﬁle down into C extensions, you could try using gperftools from Python with yep.

• If you would like to track performace of your code across time, i.e. as you make new commits to your

repository, you could try: vbench

• If you need some interactive visualization why not try RunSnakeRun

10.4. Writing faster numerical code

209

CHAPTER 11

Sparse Matrices in SciPy

Author: Robert Cimrman

11.1 Introduction

(dense) matrix is:

• mathematical object

• data structure for storing a 2D array of values

important features:

• memory allocated once for all items

– usually a contiguous chunk, think NumPy ndarray

• fast access to individual items (\*)

11.1.1 Why Sparse Matrices?

• the memory, that grows like n\*\*2

• small example (double precision matrix):

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> x = np.linspace(0, 1e6, 10)
>>> plt.plot(x, 8.0 \* (x\*\*2) / 1e6, lw=5)
[]
>>> plt.xlabel('size n')

>>> plt.ylabel('memory [MB]')


11.1.2 Sparse Matrices vs. Sparse Matrix Storage Schemes

• sparse matrix is a matrix, which is almost empty

• storing all the zeros is wasteful -> store only nonzero items

• think compression

• pros: huge memory savings

210

Scipy lecture notes, Edition 2015.2

• cons: depends on actual storage scheme, (\*) usually does not hold

11.1.3 Typical Applications

• solution of partial differential equations (PDEs)

– the ﬁnite element method

– mechanical engineering, electrotechnics, physics, ...

• graph theory

– nonzero at (i, j) means that node i is connected to node j

• ...

11.1.4 Prerequisites

recent versions of
• numpy
• scipy
• matplotlib (optional)
• ipython (the enhancements come handy)

11.1.5 Sparsity Structure Visualization

• spy() from matplotlib

• example plots:

11.1.

Introduction

211

Scipy lecture notes, Edition 2015.2

11.2 Storage Schemes

• seven sparse matrix types in scipy.sparse:

1. csc\_matrix: Compressed Sparse Column format

2. csr\_matrix: Compressed Sparse Row format

3. bsr\_matrix: Block Sparse Row format

4. lil\_matrix: List of Lists format

5. dok\_matrix: Dictionary of Keys format

6. coo\_matrix: COOrdinate format (aka IJV, triplet format)

7. dia\_matrix: DIAgonal format

• each suitable for some tasks

• many employ sparsetools C++ module by Nathan Bell

• assume the following is imported:

>>> import numpy as np
>>> import scipy.sparse as sps
>>> import matplotlib.pyplot as plt

• warning for NumPy users:

– the multiplication with ‘\*’ is the matrix multiplication (dot product)

– not part of NumPy!

11.2. Storage Schemes

212

Scipy lecture notes, Edition 2015.2

\* passing a sparse matrix object to NumPy functions expecting ndarray/matrix does not

work

11.2.1 Common Methods

• all scipy.sparse classes are subclasses of spmatrix

– default implementation of arithmetic operations

\* always converts to CSR

\* subclasses override for efﬁciency

– shape, data type set/get

– nonzero indices
– format conversion, interaction with NumPy (toarray(), todense())

– ...

• attributes:

– mtx.A - same as mtx.toarray()
– mtx.T - transpose (same as mtx.transpose())
– mtx.H - Hermitian (conjugate) transpose
– mtx.real - real part of complex matrix
– mtx.imag - imaginary part of complex matrix
– mtx.size - the number of nonzeros (same as self.getnnz())
– mtx.shape - the number of rows and columns (tuple)

• data usually stored in NumPy arrays

11.2.2 Sparse Matrix Classes

Diagonal Format (DIA)

• very simple scheme

• diagonals in dense NumPy array of shape (n\_diag, length)

– ﬁxed length -> waste space a bit when far from main diagonal
– subclass of \_data\_matrix (sparse matrix classes with data attribute)

• offset for each diagonal

– 0 is the main diagonal

– negative offset = below

– positive offset = above

• fast matrix \* vector (sparsetools)

• fast and easy item-wise operations

– manipulate data array directly (fast NumPy machinery)

• constructor accepts:

– dense matrix (array)

– sparse matrix

11.2. Storage Schemes

213

Scipy lecture notes, Edition 2015.2

– shape tuple (create empty matrix)
– (data, offsets) tuple

• no slicing, no individual item access

• use:

– rather specialized

– solving PDEs by ﬁnite differences

– with an iterative solver

Examples

• create some DIA matrices:

>>> data = np.array([[1, 2, 3, 4]]).repeat(3, axis=0)
>>> data
array([[1, 2, 3, 4],
[1, 2, 3, 4],
[1, 2, 3, 4]])

>>> offsets = np.array([0, -1, 2])
>>> mtx = sparse.dia\_matrix((data, offsets), shape=(4, 4))
>>> mtx
<4x4 sparse matrix of type '<... 'numpy.int64'>'

with 9 stored elements (3 diagonals) in DIAgonal format>

>>> mtx.todense()
matrix([[1, 0, 3, 0],
[1, 2, 0, 4],
[0, 2, 3, 0],
[0, 0, 3, 4]])

>>> data = np.arange(12).reshape((3, 4)) + 1
>>> data
array([[ 1,
[ 5,
[ 9, 10, 11, 12]])

4],
8],

2,
6,

3,
7,

>>> mtx = sparse.dia\_matrix((data, offsets), shape=(4, 4))
>>> mtx.data
3,
array([[ 1,
[ 5,
7,
[ 9, 10, 11, 12]]...)

4],
8],

2,
6,

>>> mtx.offsets
array([ 0, -1,
>>> print(mtx)

2], dtype=int32)

(0, 0)
(1, 1)
(2, 2)
(3, 3)
(1, 0)
(2, 1)
(3, 2)
(0, 2)
(1, 3)

1
2
3
4
5
6
7
11
12
>>> mtx.todense()
matrix([[ 1,
[ 5,
[ 0,
[ 0,

0, 11,
2,
6,
0,

0],
0, 12],
0],
3,
4]])
7,

• explanation with a scheme:

11.2. Storage Schemes

214

offset: row

Scipy lecture notes, Edition 2015.2

2: 9
1: --10------
.
0: 1
. 12
5
.
3
.
.
4
7
---------8

. 11
2
6
.

-1:
-2:
-3:

• matrix-vector multiplication

1.])

1.,

1.,

>>> vec = np.ones((4, ))
>>> vec
array([ 1.,
>>> mtx \* vec
array([ 12.,
9.,
>>> mtx.toarray() \* vec
1.,
array([[
5.,
[
0.,
[
0.,
[

0.,
2.,
6.,
0.,

11.,
0.,
3.,
7.,

19.,

11.])

0.],
12.],
0.],
4.]])

List of Lists Format (LIL)

• row-based linked list

– each row is a Python list (sorted) of column indices of non-zero elements
– rows stored in a NumPy array (dtype=np.object)

– non-zero values data stored analogously

• efﬁcient for constructing sparse matrices incrementally

• constructor accepts:

– dense matrix (array)

– sparse matrix

– shape tuple (create empty matrix)

• ﬂexible slicing, changing sparsity structure is efﬁcient

• slow arithmetics, slow column slicing due to being row-based

• use:

Examples

– when sparsity pattern is not known apriori or changes

– example: reading a sparse matrix from a text ﬁle

• create an empty LIL matrix:

>>> mtx = sparse.lil\_matrix((4, 5))

• prepare random data:

>>> from numpy.random import rand
>>> data = np.round(rand(2, 3))
>>> data
array([[ 1.,
[ 1.,

1.],
1.]])

1.,
0.,

11.2. Storage Schemes

215

Scipy lecture notes, Edition 2015.2

• assign the data using fancy indexing:

>>> mtx[:2, [1, 2, 3]] = data
>>> mtx
<4x5 sparse matrix of type '<... 'numpy.float64'>'

with 5 stored elements in LInked List format>

>>> print(mtx)
1.0
1.0
1.0
1.0
1.0

(0, 1)
(0, 2)
(0, 3)
(1, 1)
(1, 3)

>>> mtx.todense()
1.,
matrix([[ 0.,
1.,
[ 0.,
0.,
[ 0.,
0.,
[ 0.,
>>> mtx.toarray()
1.,
array([[ 0.,
1.,
[ 0.,
0.,
[ 0.,
0.,
[ 0.,

1.,
0.,
0.,
0.,

1.,
1.,
0.,
0.,

0.],
0.],
0.],
0.]])

1.,
0.,
0.,
0.,

1.,
1.,
0.,
0.,

0.],
0.],
0.],
0.]])

• more slicing and indexing:

>>> mtx = sparse.lil\_matrix([[0, 1, 2, 0], [3, 0, 1, 0], [1, 0, 0, 1]])
>>> mtx.todense()
matrix([[0, 1, 2, 0],
[3, 0, 1, 0],
[1, 0, 0, 1]]...)

(0, 1)
(0, 2)
(1, 0)
(1, 2)
(2, 0)
(2, 3)

>>> print(mtx)
1
2
3
1
1
1
>>> mtx[:2, :]
<2x4 sparse matrix of type '<... 'numpy.int64'>'
with 4 stored elements in LInked List format>

>>> mtx[:2, :].todense()
matrix([[0, 1, 2, 0],

[3, 0, 1, 0]]...)

>>> mtx[1:2, [0,2]].todense()
matrix([[3, 1]]...)
>>> mtx.todense()
matrix([[0, 1, 2, 0],
[3, 0, 1, 0],
[1, 0, 0, 1]]...)

Dictionary of Keys Format (DOK)

• subclass of Python dict

– keys are (row, column) index tuples (no duplicate entries allowed)

– values are corresponding non-zero values

• efﬁcient for constructing sparse matrices incrementally

• constructor accepts:

– dense matrix (array)

– sparse matrix

11.2. Storage Schemes

216

Scipy lecture notes, Edition 2015.2

– shape tuple (create empty matrix)

• efﬁcient O(1) access to individual elements

• ﬂexible slicing, changing sparsity structure is efﬁcient

• can be efﬁciently converted to a coo\_matrix once constructed
• slow arithmetics (for loops with dict.iteritems())

• use:

Examples

– when sparsity pattern is not known apriori or changes

• create a DOK matrix element by element:

>>> mtx = sparse.dok\_matrix((5, 5), dtype=np.float64)
>>> mtx
<5x5 sparse matrix of type '<... 'numpy.float64'>'

with 0 stored elements in Dictionary Of Keys format>

for ic in range(5):

>>> for ir in range(5):
...
...
>>> mtx
<5x5 sparse matrix of type '<... 'numpy.float64'>'

mtx[ir, ic] = 1.0 \* (ir != ic)

with 20 stored elements in Dictionary Of Keys format>

>>> mtx.todense()
1.,
matrix([[ 0.,
0.,
[ 1.,
1.,
[ 1.,
1.,
[ 1.,
1.,
[ 1.,

1.,
1.,
0.,
1.,
1.,

1.,
1.,
1.,
0.,
1.,

1.],
1.],
1.],
1.],
0.]])

• slicing and indexing:

>>> mtx[1, 1]
0.0
>>> mtx[1, 1:3]
<1x2 sparse matrix of type '<... 'numpy.float64'>'

with 1 stored elements in Dictionary Of Keys format>

>>> mtx[1, 1:3].todense()
matrix([[ 0.,
>>> mtx[[2,1], 1:3].todense()
matrix([[ 1.,
[ 0.,

0.],
1.]])

1.]])

Coordinate Format (COO)

• also known as the ‘ijv’ or ‘triplet’ format

– three NumPy arrays: row, col, data
– data[i] is value at (row[i], col[i]) position

– permits duplicate entries
– subclass of \_data\_matrix (sparse matrix classes with data attribute)

• fast format for constructing sparse matrices

• constructor accepts:

– dense matrix (array)

11.2. Storage Schemes

217

Scipy lecture notes, Edition 2015.2

– sparse matrix

– shape tuple (create empty matrix)
– (data, ij) tuple

• very fast conversion to and from CSR/CSC formats

• fast matrix \* vector (sparsetools)

• fast and easy item-wise operations

– manipulate data array directly (fast NumPy machinery)

• no slicing, no arithmetics (directly)

• use:

– facilitates fast conversion among sparse formats

– when converting to other format (usually CSR or CSC), duplicate entries are summed together

\* facilitates efﬁcient construction of ﬁnite element matrices

Examples

• create empty COO matrix:

>>> mtx = sparse.coo\_matrix((3, 4), dtype=np.int8)
>>> mtx.todense()
matrix([[0, 0, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 0]], dtype=int8)

• create using (data, ij) tuple:

>>> row = np.array([0, 3, 1, 0])
>>> col = np.array([0, 3, 1, 2])
>>> data = np.array([4, 5, 7, 9])
>>> mtx = sparse.coo\_matrix((data, (row, col)), shape=(4, 4))
>>> mtx
<4x4 sparse matrix of type '<... 'numpy.int64'>'

with 4 stored elements in COOrdinate format>

>>> mtx.todense()
matrix([[4, 0, 9, 0],
[0, 7, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 5]])

• duplicates entries are summed together:

>>> row = np.array([0, 0, 1, 3, 1, 0, 0])
>>> col = np.array([0, 2, 1, 3, 1, 0, 0])
>>> data = np.array([1, 1, 1, 1, 1, 1, 1])
>>> mtx = sparse.coo\_matrix((data, (row, col)), shape=(4, 4))
>>> mtx.todense()
matrix([[3, 0, 1, 0],
[0, 2, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 1]])

• no slicing...:

>>> mtx[2, 3]
Traceback (most recent call last):
...
TypeError: 'coo\_matrix' object ...

11.2. Storage Schemes

218

Scipy lecture notes, Edition 2015.2

Traceback (most recent call last):
...
TypeError: 'coo\_matrix' object ...

Compressed Sparse Row Format (CSR)

• row oriented

– three NumPy arrays: indices, indptr, data
\* indices is array of column indices
\* data is array of corresponding nonzero values
\* indptr points to row starts in indices and data
\* length is n\_row + 1, last item = number of values = length of both indices and data
\* nonzero values of the i-th row are data[indptr[i]:indptr[i+1]] with column in-

dices indices[indptr[i]:indptr[i+1]]

\* item (i, j) can be accessed as data[indptr[i]+k], where k is position of j in

indices[indptr[i]:indptr[i+1]]

– subclass of \_cs\_matrix (common CSR/CSC functionality)

\* subclass of \_data\_matrix (sparse matrix classes with data attribute)

• fast matrix vector products and other arithmetics (sparsetools)

• constructor accepts:

– dense matrix (array)

– sparse matrix

– shape tuple (create empty matrix)
– (data, ij) tuple
– (data, indices, indptr) tuple

• efﬁcient row slicing, row-oriented operations

• slow column slicing, expensive changes to the sparsity structure

• use:

Examples

– actual computations (most linear solvers support this format)

• create empty CSR matrix:

>>> mtx = sparse.csr\_matrix((3, 4), dtype=np.int8)
>>> mtx.todense()
matrix([[0, 0, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 0]], dtype=int8)

• create using (data, ij) tuple:

>>> row = np.array([0, 0, 1, 2, 2, 2])
>>> col = np.array([0, 2, 2, 0, 1, 2])
>>> data = np.array([1, 2, 3, 4, 5, 6])
>>> mtx = sparse.csr\_matrix((data, (row, col)), shape=(3, 3))
>>> mtx

11.2. Storage Schemes

219

Scipy lecture notes, Edition 2015.2

<3x3 sparse matrix of type '<... 'numpy.int64'>'

with 6 stored elements in Compressed Sparse Row format>

>>> mtx.todense()
matrix([[1, 0, 2],
[0, 0, 3],
[4, 5, 6]]...)

>>> mtx.data
array([1, 2, 3, 4, 5, 6]...)
>>> mtx.indices
array([0, 2, 2, 0, 1, 2], dtype=int32)
>>> mtx.indptr
array([0, 2, 3, 6], dtype=int32)

• create using (data, indices, indptr) tuple:

>>> data = np.array([1, 2, 3, 4, 5, 6])
>>> indices = np.array([0, 2, 2, 0, 1, 2])
>>> indptr = np.array([0, 2, 3, 6])
>>> mtx = sparse.csr\_matrix((data, indices, indptr), shape=(3, 3))
>>> mtx.todense()
matrix([[1, 0, 2],
[0, 0, 3],
[4, 5, 6]])

Compressed Sparse Column Format (CSC)

• column oriented

– three NumPy arrays: indices, indptr, data
\* indices is array of row indices
\* data is array of corresponding nonzero values
\* indptr points to column starts in indices and data
\* length is n\_col + 1, last item = number of values = length of both indices and data
\* nonzero values of the i-th column are data[indptr[i]:indptr[i+1]] with row in-

dices indices[indptr[i]:indptr[i+1]]

\* item (i, j) can be accessed as data[indptr[j]+k], where k is position of i in

indices[indptr[j]:indptr[j+1]]

– subclass of \_cs\_matrix (common CSR/CSC functionality)

\* subclass of \_data\_matrix (sparse matrix classes with data attribute)

• fast matrix vector products and other arithmetics (sparsetools)

• constructor accepts:

– dense matrix (array)

– sparse matrix

– shape tuple (create empty matrix)
– (data, ij) tuple
– (data, indices, indptr) tuple

• efﬁcient column slicing, column-oriented operations

• slow row slicing, expensive changes to the sparsity structure

• use:

– actual computations (most linear solvers support this format)

11.2. Storage Schemes

220

Scipy lecture notes, Edition 2015.2

Examples

• create empty CSC matrix:

>>> mtx = sparse.csc\_matrix((3, 4), dtype=np.int8)
>>> mtx.todense()
matrix([[0, 0, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 0]], dtype=int8)

• create using (data, ij) tuple:

>>> row = np.array([0, 0, 1, 2, 2, 2])
>>> col = np.array([0, 2, 2, 0, 1, 2])
>>> data = np.array([1, 2, 3, 4, 5, 6])
>>> mtx = sparse.csc\_matrix((data, (row, col)), shape=(3, 3))
>>> mtx
<3x3 sparse matrix of type '<... 'numpy.int64'>'

with 6 stored elements in Compressed Sparse Column format>

>>> mtx.todense()
matrix([[1, 0, 2],
[0, 0, 3],
[4, 5, 6]]...)

>>> mtx.data
array([1, 4, 5, 2, 3, 6]...)
>>> mtx.indices
array([0, 2, 2, 0, 1, 2], dtype=int32)
>>> mtx.indptr
array([0, 2, 3, 6], dtype=int32)

• create using (data, indices, indptr) tuple:

>>> data = np.array([1, 4, 5, 2, 3, 6])
>>> indices = np.array([0, 2, 2, 0, 1, 2])
>>> indptr = np.array([0, 2, 3, 6])
>>> mtx = sparse.csc\_matrix((data, indices, indptr), shape=(3, 3))
>>> mtx.todense()
matrix([[1, 0, 2],
[0, 0, 3],
[4, 5, 6]])

Block Compressed Row Format (BSR)

• basically a CSR with dense sub-matrices of ﬁxed shape instead of scalar items
– block size (R, C) must evenly divide the shape of the matrix (M, N)

– three NumPy arrays: indices, indptr, data

\* indices is array of column indices for each block
\* data is array of corresponding nonzero values of shape (nnz, R, C)
\* ...

– subclass of \_cs\_matrix (common CSR/CSC functionality)

\* subclass of \_data\_matrix (sparse matrix classes with data attribute)

• fast matrix vector products and other arithmetics (sparsetools)

• constructor accepts:

– dense matrix (array)

– sparse matrix

11.2. Storage Schemes

221

Scipy lecture notes, Edition 2015.2

– shape tuple (create empty matrix)
– (data, ij) tuple
– (data, indices, indptr) tuple

• many arithmetic operations considerably more efﬁcient than CSR for sparse matrices with dense sub-

matrices

• use:

– like CSR

– vector-valued ﬁnite element discretizations

Examples

• create empty BSR matrix with (1, 1) block size (like CSR...):

>>> mtx = sparse.bsr\_matrix((3, 4), dtype=np.int8)
>>> mtx
<3x4 sparse matrix of type '<... 'numpy.int8'>'

with 0 stored elements (blocksize = 1x1) in Block Sparse Row format>

>>> mtx.todense()
matrix([[0, 0, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 0]], dtype=int8)

• create empty BSR matrix with (3, 2) block size:

>>> mtx = sparse.bsr\_matrix((3, 4), blocksize=(3, 2), dtype=np.int8)
>>> mtx
<3x4 sparse matrix of type '<... 'numpy.int8'>'

with 0 stored elements (blocksize = 3x2) in Block Sparse Row format>

>>> mtx.todense()
matrix([[0, 0, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 0]], dtype=int8)

– a bug?

• create using (data, ij) tuple with (1, 1) block size (like CSR...):

>>> row = np.array([0, 0, 1, 2, 2, 2])
>>> col = np.array([0, 2, 2, 0, 1, 2])
>>> data = np.array([1, 2, 3, 4, 5, 6])
>>> mtx = sparse.bsr\_matrix((data, (row, col)), shape=(3, 3))
>>> mtx
<3x3 sparse matrix of type '<... 'numpy.int64'>'

with 6 stored elements (blocksize = 1x1) in Block Sparse Row format>

>>> mtx.todense()
matrix([[1, 0, 2],
[0, 0, 3],
[4, 5, 6]]...)

>>> mtx.data
array([[[1]],

[[2]],

[[3]],

[[4]],

[[5]],

11.2. Storage Schemes

222

Scipy lecture notes, Edition 2015.2

[[6]]]...)

>>> mtx.indices
array([0, 2, 2, 0, 1, 2], dtype=int32)
>>> mtx.indptr
array([0, 2, 3, 6], dtype=int32)

• create using (data, indices, indptr) tuple with (2, 2) block size:

>>> indptr = np.array([0, 2, 3, 6])
>>> indices = np.array([0, 2, 2, 0, 1, 2])
>>> data = np.array([1, 2, 3, 4, 5, 6]).repeat(4).reshape(6, 2, 2)
>>> mtx = sparse.bsr\_matrix((data, indices, indptr), shape=(6, 6))
>>> mtx.todense()
matrix([[1, 1, 0, 0, 2, 2],
[1, 1, 0, 0, 2, 2],
[0, 0, 0, 0, 3, 3],
[0, 0, 0, 0, 3, 3],
[4, 4, 5, 5, 6, 6],
[4, 4, 5, 5, 6, 6]])

>>> data
array([[[1, 1],

[1, 1]],

[[2, 2],

[2, 2]],

[[3, 3],

[3, 3]],

[[4, 4],

[4, 4]],

[[5, 5],

[5, 5]],

[[6, 6],

[6, 6]]])

11.2.3 Summary

Table 11.1: Summary of storage schemes.

for-
mat
DIA

LIL

matrix \*
vector
sparse-
tools
via CSR

DOK

python

get
item
.

yes

yes

COO sparse-

.

fancy
get
.

yes

one axis
only
.

CSR

CSC

BSR

tools
sparse-
tools
sparse-
tools
sparse-
tools

yes

yes

.

yes

yes

.

set
item
.

yes

yes

.

slow

slow

.

fancy
set
.

yes

yes

.

.

.

.

solvers

note

itera-
tive
itera-
tive
itera-
tive
itera-
tive
any

any

spe-
cialized

has data array, specialized

arithmetics via CSR,
incremental construction
O(1) item access, incremental
construction
has data array, facilitates fast
conversion
has data array, fast row-wise ops

has data array, fast column-wise
ops
has data array, specialized

11.2. Storage Schemes

223

Scipy lecture notes, Edition 2015.2

11.3 Linear System Solvers

• sparse matrix/eigenvalue problem solvers live in scipy.sparse.linalg

• the submodules:

– dsolve: direct factorization methods for solving linear systems
– isolve: iterative methods for solving linear systems
– eigen: sparse eigenvalue problem solvers

• all solvers are accessible from:

>>> import scipy.sparse.linalg as spla
>>> spla.\_\_all\_\_
['LinearOperator', 'Tester', 'arpack', 'aslinearoperator', 'bicg',
'bicgstab', 'cg', 'cgs', 'csc\_matrix', 'csr\_matrix', 'dsolve',
'eigen', 'eigen\_symmetric', 'factorized', 'gmres', 'interface',
'isolve', 'iterative', 'lgmres', 'linsolve', 'lobpcg', 'lsqr',
'minres', 'np', 'qmr', 'speigs', 'spilu', 'splu', 'spsolve', 'svd',
'test', 'umfpack', 'use\_solver', 'utils', 'warnings']

11.3.1 Sparse Direct Solvers

• default solver: SuperLU 4.0

– included in SciPy

– real and complex systems

– both single and double precision

• optional: umfpack

– real and complex systems

– double precision only

– recommended for performance
– wrappers now live in scikits.umfpack
– check-out the new scikits.suitesparse by Nathaniel Smith

Examples

• import the whole module, and see its docstring:

>>> from scipy.sparse.linalg import dsolve
>>> help(dsolve)

• both superlu and umfpack can be used (if the latter is installed) as follows:

– prepare a linear system:

>>> import numpy as np
>>> from scipy import sparse
>>> mtx = sparse.spdiags([[1, 2, 3, 4, 5], [6, 5, 8, 9, 10]], [0, 1], 5, 5)
>>> mtx.todense()
5,
matrix([[ 1,
2,
[ 0,
0,
[ 0,
0,
[ 0,
0,
[ 0,

0],
0,
0],
0,
0],
9,
4, 10],
0,

0,
8,
3,
0,
0,

5]])

>>> rhs = np.array([1, 2, 3, 4, 5], dtype=np.float32)

11.3. Linear System Solvers

224

– solve as single precision real:

Scipy lecture notes, Edition 2015.2

>>> mtx1 = mtx.astype(np.float32)
>>> x = dsolve.spsolve(mtx1, rhs, use\_umfpack=False)
>>> print(x)
-21.
[ 106.
>>> print("Error: %s " % (mtx1 \* x - rhs))
Error:

[ 0.

-1.5

1. ]

0.]

5.5

0.

0.

0.

– solve as double precision real:

>>> mtx2 = mtx.astype(np.float64)
>>> x = dsolve.spsolve(mtx2, rhs, use\_umfpack=True)
>>> print(x)
[ 106.
-21.
>>> print("Error: %s " % (mtx2 \* x - rhs))
Error:

[ 0.

1. ]

-1.5

5.5

0.]

0.

0.

0.

– solve as single precision complex:

>>> mtx1 = mtx.astype(np.complex64)
>>> x = dsolve.spsolve(mtx1, rhs, use\_umfpack=False)
>>> print(x)
[ 106.0+0.j
>>> print("Error: %s " % (mtx1 \* x - rhs))
0.+0.j
Error:

-21.0+0.j

[ 0.+0.j

-1.5+0.j

5.5+0.j

0.+0.j]

0.+0.j

0.+0.j

1.0+0.j]

– solve as double precision complex:

>>> mtx2 = mtx.astype(np.complex128)
>>> x = dsolve.spsolve(mtx2, rhs, use\_umfpack=True)
>>> print(x)
[ 106.0+0.j
>>> print("Error: %s " % (mtx2 \* x - rhs))
0.+0.j
Error:

-21.0+0.j

[ 0.+0.j

-1.5+0.j

0.+0.j]

5.5+0.j

0.+0.j

0.+0.j

1.0+0.j]

"""
Solve a linear system
=======================

Construct a 1000x1000 lil\_matrix and add some values to it, convert it
to CSR format and solve A x = b for x:and solve a linear system with a
direct solver.
"""
import numpy as np
import scipy.sparse as sps
from matplotlib import pyplot as plt
from scipy.sparse.linalg.dsolve import linsolve

rand = np.random.rand

mtx = sps.lil\_matrix((1000, 1000), dtype=np.float64)
mtx[0, :100] = rand(100)
mtx[1, 100:200] = mtx[0, :100]
mtx.setdiag(rand(1000))

plt.clf()
plt.spy(mtx, marker='.', markersize=2)
plt.show()

mtx = mtx.tocsr()
rhs = rand(1000)

x = linsolve.spsolve(mtx, rhs)

11.3. Linear System Solvers

225

Scipy lecture notes, Edition 2015.2

print('rezidual: %r ' % np.linalg.norm(mtx \* x - rhs))

• examples/direct\_solve.py

11.3.2 Iterative Solvers

• the isolve module contains the following solvers:

– bicg (BIConjugate Gradient)
– bicgstab (BIConjugate Gradient STABilized)
– cg (Conjugate Gradient) - symmetric positive deﬁnite matrices only
– cgs (Conjugate Gradient Squared)
– gmres (Generalized Minimal RESidual)
– minres (MINimum RESidual)
– qmr (Quasi-Minimal Residual)

Common Parameters

• mandatory:

A [{sparse matrix, dense matrix, LinearOperator}] The N-by-N matrix of the linear system.

b [{array, matrix}] Right hand side of the linear system. Has shape (N,) or (N,1).

• optional:

x0 [{array, matrix}] Starting guess for the solution.

tol [ﬂoat] Relative tolerance to achieve before terminating.

maxiter [integer] Maximum number of iterations. Iteration will stop after maxiter steps even if the spec-

iﬁed tolerance has not been achieved.

M [{sparse matrix, dense matrix, LinearOperator}] Preconditioner for A. The preconditioner should ap-
proximate the inverse of A. Effective preconditioning dramatically improves the rate of conver-
gence, which implies that fewer iterations are needed to reach a given error tolerance.

callback [function] User-supplied function to call after each iteration. It is called as callback(xk), where

xk is the current solution vector.

LinearOperator Class

from scipy.sparse.linalg.interface import LinearOperator

• common interface for performing matrix vector products

• useful abstraction that enables using dense and sparse matrices within the solvers, as well as matrix-free

solutions

• has shape and matvec() (+ some optional parameters)

• example:

>>> import numpy as np
>>> from scipy.sparse.linalg import LinearOperator
>>> def mv(v):
...
...
>>> A = LinearOperator((2, 2), matvec=mv)

return np.array([2\*v[0], 3\*v[1]])

11.3. Linear System Solvers

226

Scipy lecture notes, Edition 2015.2

>>> A
<2x2 LinearOperator with unspecified dtype>
>>> A.matvec(np.ones(2))
array([ 2.,
3.])
>>> A \* np.ones(2)
3.])
array([ 2.,

A Few Notes on Preconditioning

• problem speciﬁc

• often hard to develop

• if not sure, try ILU

– available in dsolve as spilu()

11.3.3 Eigenvalue Problem Solvers

The eigen module

• arpack \* a collection of Fortran77 subroutines designed to solve large scale eigenvalue problems
• lobpcg (Locally Optimal Block Preconditioned Conjugate Gradient Method) \* works very well in combi-

nation with PyAMG \* example by Nathan Bell:

"""
Compute eigenvectors and eigenvalues using a preconditioned eigensolver
========================================================================

In this example Smoothed Aggregation (SA) is used to precondition
the LOBPCG eigensolver on a two-dimensional Poisson problem with
Dirichlet boundary conditions.
"""

import scipy
from scipy.sparse.linalg import lobpcg

from pyamg import smoothed\_aggregation\_solver
from pyamg.gallery import poisson

N = 100
K = 9
A = poisson((N,N), format='csr')

# create the AMG hierarchy
ml = smoothed\_aggregation\_solver(A)

# initial approximation to the K eigenvectors
X = scipy.rand(A.shape[0], K)

# preconditioner based on ml
M = ml.aspreconditioner()

# compute eigenvalues and eigenvectors with LOBPCG
W,V = lobpcg(A, X, M=M, tol=1e-8, largest=False)

#plot the eigenvectors
import pylab

11.3. Linear System Solvers

227

Scipy lecture notes, Edition 2015.2

pylab.figure(figsize=(9,9))

for i in range(K):

pylab.subplot(3, 3, i+1)
pylab.title('Eigenvector %d ' % i)
pylab.pcolor(V[:,i].reshape(N,N))
pylab.axis('equal')
pylab.axis('off')

pylab.show()

– examples/pyamg\_with\_lobpcg.py

• example by Nils Wagner:

– examples/lobpcg\_sakurai.py

• output:

$ python examples/lobpcg\_sakurai.py
Results by LOBPCG for n=2500

[ 0.06250083

0.06250028

0.06250007]

Exact eigenvalues

[ 0.06250005

0.0625002

0.06250044]

Elapsed time 7.01

11.3. Linear System Solvers

228

Scipy lecture notes, Edition 2015.2

11.4 Other Interesting Packages

• PyAMG

– algebraic multigrid solvers

– http://code.google.com/p/pyamg

• Pysparse

– own sparse matrix classes

– matrix and eigenvalue problem solvers

– http://pysparse.sourceforge.net/

11.4. Other Interesting Packages

229

CHAPTER 12

Image manipulation and processing using Numpy and Scipy

Authors: Emmanuelle Gouillart, Gaël Varoquaux

This section addresses basic image manipulation and processing using the core scientiﬁc modules NumPy and
SciPy. Some of the operations covered by this tutorial may be useful for other kinds of multidimensional array
processing than image processing. In particular, the submodule scipy.ndimage provides functions operating
on n-dimensional NumPy arrays.

See also:

For more advanced image processing and image-speciﬁc routines, see the tutorial Scikit-image: image pro-
cessing, dedicated to the skimage module.

Image = 2-D numerical array

(or 3-D: CT, MRI, 2D + time; 4-D, ...)
Here, image == Numpy array np.array

Tools used in this tutorial:

• numpy: basic array manipulation
• scipy: scipy.ndimage submodule dedicated to image processing (n-dimensional images). See the

documentation:

>>> from scipy import ndimage

Common tasks in image processing:

• Input/Output, displaying images

• Basic manipulations: cropping, ﬂipping, rotating, ...

• Image ﬁltering: denoising, sharpening

• Image segmentation: labeling pixels corresponding to different objects

• Classiﬁcation

• Feature extraction

• Registration

• ...

230

Scipy lecture notes, Edition 2015.2

Chapters contents

• Opening and writing to image ﬁles
• Displaying images
• Basic manipulations

– Statistical information
– Geometrical transformations

• Image ﬁltering

– Blurring/smoothing
– Sharpening
– Denoising
– Mathematical morphology

• Feature extraction

– Edge detection
– Segmentation

• Measuring objects properties: ndimage.measurements

12.1 Opening and writing to image files

Writing an array to a ﬁle:

Displaying Lena
================

Small example to plot lena.
"""

from scipy import misc
l = misc.lena()
misc.imsave('lena.png', l) # uses the Image module (PIL)

import matplotlib.pyplot as plt
plt.imshow(l)
plt.show()

Creating a numpy array from an image ﬁle:

12.1. Opening and writing to image files

231

Scipy lecture notes, Edition 2015.2

>>> from scipy import misc
>>> lena = misc.lena()
>>> misc.imsave('lena.png', lena) # First we need to create the PNG file

>>> lena = misc.imread('lena.png')
>>> type(lena)
<... 'numpy.ndarray'>
>>> lena.shape, lena.dtype
((512, 512), dtype('uint8'))

dtype is uint8 for 8-bit images (0-255)

Opening raw ﬁles (camera, 3-D images)

>>> lena.tofile('lena.raw') # Create raw file
>>> lena\_from\_raw = np.fromfile('lena.raw', dtype=np.uint8)
>>> lena\_from\_raw.shape
(262144,)
>>> lena\_from\_raw.shape = (512, 512)

Need to know the shape and dtype of the image (how to separate data bytes).
For large data, use np.memmap for memory mapping:

>>> lena\_memmap = np.memmap('lena.raw', dtype=np.uint8, shape=(512, 512))

(data are read from the ﬁle, and not loaded into memory)

Working on a list of image ﬁles

im = np.random.random\_integers(0, 255, 10000).reshape((100, 100))
misc.imsave('random\_%02d .png' % i, im)

>>> for i in range(10):
...
...
>>> from glob import glob
>>> filelist = glob('random\*.png')
>>> filelist.sort()

12.2 Displaying images

Use matplotlib and imshow to display an image inside a matplotlib figure:

>>> l = misc.lena()
>>> import matplotlib.pyplot as plt
>>> plt.imshow(l, cmap=plt.cm.gray)


Increase contrast by setting min and max values:

>>> plt.imshow(l, cmap=plt.cm.gray, vmin=30, vmax=200)

>>> # Remove axes and ticks
>>> plt.axis('off')
(-0.5, 511.5, 511.5, -0.5)

Draw contour lines:

>>> plt.contour(l, [60, 211])


For ﬁne inspection of intensity variations, use interpolation=’nearest’:

12.2. Displaying images

232

Scipy lecture notes, Edition 2015.2

>>> plt.imshow(l[200:220, 200:220], cmap=plt.cm.gray)

>>> plt.imshow(l[200:220, 200:220], cmap=plt.cm.gray, interpolation='nearest')


3-D visualization: Mayavi

See 3D plotting with Mayavi.
• Image plane widgets
• Isosurfaces
• ...

12.3 Basic manipulations

Images are arrays: use the whole numpy machinery.

12.3. Basic manipulations

233

Scipy lecture notes, Edition 2015.2

>>> lena = misc.lena()
>>> lena[0, 40]
166
>>> # Slicing
>>> lena[10:13, 20:23]
array([[158, 156, 157],
[157, 155, 155],
[157, 157, 158]])
>>> lena[100:120] = 255
>>>
>>> lx, ly = lena.shape
>>> X, Y = np.ogrid[0:lx, 0:ly]
>>> mask = (X - lx / 2) \*\* 2 + (Y - ly / 2) \*\* 2 > lx \* ly / 4
>>> # Masks
>>> lena[mask] = 0
>>> # Fancy indexing
>>> lena[range(400), range(400)] = 255

12.3.1 Statistical information

>>> lena = misc.lena()
>>> lena.mean()
124.04678344726562
>>> lena.max(), lena.min()
(245, 25)

12.3. Basic manipulations

234

Scipy lecture notes, Edition 2015.2

np.histogram

Exercise

• Open as an array the scikit-image logo (http://scikit-image.org/\_static/img/logo.png), or an im-

age that you have on your computer.

• Crop a meaningful part of the image, for example the python circle in the logo.
• Display the image array using matplotlib. Change the interpolation method and zoom to see the

difference.

• Transform your image to greyscale
• Increase the contrast of the image by changing its minimum and maximum values. Optional: use
scipy.stats.scoreatpercentile (read the docstring!) to saturate 5% of the darkest pixels and
5% of the lightest pixels.

• Save the array to two different ﬁle formats (png, jpg, tiff)

12.3.2 Geometrical transformations

>>> lena = misc.lena()
>>> lx, ly = lena.shape
>>> # Cropping
>>> crop\_lena = lena[lx / 4: - lx / 4, ly / 4: - ly / 4]
>>> # up <-> down flip
>>> flip\_ud\_lena = np.flipud(lena)
>>> # rotation
>>> rotate\_lena = ndimage.rotate(lena, 45)
>>> rotate\_lena\_noreshape = ndimage.rotate(lena, 45, reshape=False)

12.4 Image filtering

Local ﬁlters: replace the value of pixels by a function of the values of neighboring pixels.

Neighbourhood: square (choose size), disk, or more complicated structuring element.

12.4.

Image filtering

235

Scipy lecture notes, Edition 2015.2

12.4.1 Blurring/smoothing

Gaussian ﬁlter from scipy.ndimage:

>>> from scipy import misc
>>> lena = misc.lena()
>>> blurred\_lena = ndimage.gaussian\_filter(lena, sigma=3)
>>> very\_blurred = ndimage.gaussian\_filter(lena, sigma=5)

Uniform ﬁlter

>>> local\_mean = ndimage.uniform\_filter(lena, size=11)

12.4.2 Sharpening

Sharpen a blurred image:

>>> from scipy import misc
>>> lena = misc.lena()
>>> blurred\_l = ndimage.gaussian\_filter(lena, 3)

increase the weight of edges by adding an approximation of the Laplacian:

>>> filter\_blurred\_l = ndimage.gaussian\_filter(blurred\_l, 1)
>>> alpha = 30
>>> sharpened = blurred\_l + alpha \* (blurred\_l - filter\_blurred\_l)

12.4.3 Denoising

Noisy lena:

>>> from scipy import misc
>>> l = misc.lena()
>>> l = l[230:310, 210:350]
>>> noisy = l + 0.4 \* l.std() \* np.random.random(l.shape)

12.4.

Image filtering

236

Scipy lecture notes, Edition 2015.2

A Gaussian ﬁlter smoothes the noise out... and the edges as well:

>>> gauss\_denoised = ndimage.gaussian\_filter(noisy, 2)

Most local linear isotropic ﬁlters blur the image (ndimage.uniform\_filter)

A median ﬁlter preserves better the edges:

>>> med\_denoised = ndimage.median\_filter(noisy, 3)

Median ﬁlter: better result for straight boundaries (low curvature):

>>> im = np.zeros((20, 20))
>>> im[5:-5, 5:-5] = 1
>>> im = ndimage.distance\_transform\_bf(im)
>>> im\_noise = im + 0.2 \* np.random.randn(\*im.shape)
>>> im\_med = ndimage.median\_filter(im\_noise, 3)

Other rank ﬁlter: ndimage.maximum\_filter, ndimage.percentile\_filter
Other local non-linear ﬁlters: Wiener (scipy.signal.wiener), etc.

Non-local ﬁlters

Exercise: denoising

• Create a binary image (of 0s and 1s) with several objects (circles, ellipses, squares, or random

shapes).

• Add some noise (e.g., 20% of noise)
• Try two different denoising methods for denoising the image: gaussian ﬁltering and median ﬁlter-

ing.

• Compare the histograms of the two different denoised images. Which one is the closest to the

histogram of the original (noise-free) image?

See also:
More denoising ﬁlters are available in skimage.denoising, see the Scikit-image: image processing tutorial.

12.4.4 Mathematical morphology

See wikipedia for a deﬁnition of mathematical morphology.

Probe an image with a simple shape (a structuring element), and modify this image according to how the
shape locally ﬁts or misses the image.

Structuring element:

12.4.

Image filtering

237

Scipy lecture notes, Edition 2015.2

>>> el = ndimage.generate\_binary\_structure(2, 1)
>>> el
array([[False,
[ True,
[False,
>>> el.astype(np.int)
array([[0, 1, 0],
[1, 1, 1],
[0, 1, 0]])

True, False],
True,
True],
True, False]], dtype=bool)

Erosion = minimum ﬁlter. Replace the value of a pixel by the minimal value covered by the structuring ele-
ment.:

>>> a = np.zeros((7,7), dtype=np.int)
>>> a[1:6, 2:5] = 1
>>> a
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])

>>> ndimage.binary\_erosion(a).astype(a.dtype)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])

>>> #Erosion removes objects smaller than the structure
>>> ndimage.binary\_erosion(a, structure=np.ones((5,5))).astype(a.dtype)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])

12.4.

Image filtering

238

Scipy lecture notes, Edition 2015.2

Dilation: maximum ﬁlter:

>>> a = np.zeros((5, 5))
>>> a[2, 2] = 1
>>> a
array([[ 0., 0.,
0.,
0.,
0.,
0.,

[ 0.,
[ 0.,
[ 0.,
[ 0.,

0.,
0.,
1.,
0.,
0.,

0.,
0.,
0.,
0.,
0.,

0.],
0.],
0.],
0.],
0.]])

>>> ndimage.binary\_dilation(a).astype(a.dtype)
array([[ 0., 0.,
0.,
1.,
0.,
0.,

0.],
0.],
0.],
0.],
0.]])

[ 0.,
[ 0.,
[ 0.,
[ 0.,

0.,
0.,
1.,
0.,
0.,

0.,
1.,
1.,
1.,
0.,

Also works for grey-valued images:

>>> np.random.seed(2)
>>> im = np.zeros((64, 64))
>>> x, y = (63\*np.random.random((2, 8))).astype(np.int)
>>> im[x, y] = np.arange(8)

>>> bigger\_points = ndimage.grey\_dilation(im, size=(5, 5), structure=np.ones((5, 5)))

>>> square = np.zeros((16, 16))
>>> square[4:-4, 4:-4] = 1
>>> dist = ndimage.distance\_transform\_bf(square)
>>> dilate\_dist = ndimage.grey\_dilation(dist, size=(3, 3), \
...

structure=np.ones((3, 3)))

Opening: erosion + dilation:

>>> a = np.zeros((5,5), dtype=np.int)
>>> a[1:4, 1:4] = 1; a[4, 4] = 1
>>> a
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 1]])

>>> # Opening removes small objects
>>> ndimage.binary\_opening(a, structure=np.ones((3,3))).astype(np.int)
array([[0, 0, 0, 0, 0],

12.4.

Image filtering

239

Scipy lecture notes, Edition 2015.2

[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 0]])

>>> # Opening can also smooth corners
>>> ndimage.binary\_opening(a).astype(np.int)
array([[0, 0, 0, 0, 0],
[0, 0, 1, 0, 0],
[0, 1, 1, 1, 0],
[0, 0, 1, 0, 0],
[0, 0, 0, 0, 0]])

Application: remove noise:

>>> square = np.zeros((32, 32))
>>> square[10:-10, 10:-10] = 1
>>> np.random.seed(2)
>>> x, y = (32\*np.random.random((2, 20))).astype(np.int)
>>> square[x, y] = 1

>>> open\_square = ndimage.binary\_opening(square)

>>> eroded\_square = ndimage.binary\_erosion(square)
>>> reconstruction = ndimage.binary\_propagation(eroded\_square, mask=square)

Closing: dilation + erosion

Many other mathematical morphology operations: hit and miss transform, tophat, etc.

12.5 Feature extraction

12.5.1 Edge detection

Synthetic data:

>>> im = np.zeros((256, 256))
>>> im[64:-64, 64:-64] = 1
>>>
>>> im = ndimage.rotate(im, 15, mode='constant')
>>> im = ndimage.gaussian\_filter(im, 8)

Use a gradient operator (Sobel) to ﬁnd high intensity variations:

>>> sx = ndimage.sobel(im, axis=0, mode='constant')
>>> sy = ndimage.sobel(im, axis=1, mode='constant')
>>> sob = np.hypot(sx, sy)

12.5. Feature extraction

240

Scipy lecture notes, Edition 2015.2

12.5.2 Segmentation

• Histogram-based segmentation (no spatial information)

>>> n = 10
>>> l = 256
>>> im = np.zeros((l, l))
>>> np.random.seed(1)
>>> points = l\*np.random.random((2, n\*\*2))
>>> im[(points[0]).astype(np.int), (points[1]).astype(np.int)] = 1
>>> im = ndimage.gaussian\_filter(im, sigma=l/(4.\*n))

>>> mask = (im > im.mean()).astype(np.float)
>>> mask += 0.1 \* im
>>> img = mask + 0.2\*np.random.randn(\*mask.shape)

>>> hist, bin\_edges = np.histogram(img, bins=60)
>>> bin\_centers = 0.5\*(bin\_edges[:-1] + bin\_edges[1:])

>>> binary\_img = img > 0.5

Use mathematical morphology to clean up the result:

>>> # Remove small white regions
>>> open\_img = ndimage.binary\_opening(binary\_img)
>>> # Remove small black hole
>>> close\_img = ndimage.binary\_closing(open\_img)

Exercise

Check that reconstruction operations (erosion + propagation) produce a better result than open-
ing/closing:

>>> eroded\_img = ndimage.binary\_erosion(binary\_img)
>>> reconstruct\_img = ndimage.binary\_propagation(eroded\_img, mask=binary\_img)
>>> tmp = np.logical\_not(reconstruct\_img)
>>> eroded\_tmp = ndimage.binary\_erosion(tmp)
>>> reconstruct\_final = np.logical\_not(ndimage.binary\_propagation(eroded\_tmp, mask=tmp))
>>> np.abs(mask - close\_img).mean()
0.00727836...
>>> np.abs(mask - reconstruct\_final).mean()
0.00059502...

12.5. Feature extraction

241

Scipy lecture notes, Edition 2015.2

Exercise

Check how a ﬁrst denoising step (e.g. with a median ﬁlter) modiﬁes the histogram, and check that the
resulting histogram-based segmentation is more accurate.

See also:
More advanced segmentation algorithms are found in the scikit-image: see Scikit-image: image processing.

See also:

Other Scientiﬁc Packages provide algorithms that can be useful for image processing. In this example, we use
the spectral clustering function of the scikit-learn in order to segment glued objects.

>>> from sklearn.feature\_extraction import image
>>> from sklearn.cluster import spectral\_clustering

>>> l = 100
>>> x, y = np.indices((l, l))

>>> center1 = (28, 24)
>>> center2 = (40, 50)
>>> center3 = (67, 58)
>>> center4 = (24, 70)
>>> radius1, radius2, radius3, radius4 = 16, 14, 15, 14

>>> circle1 = (x - center1[0])\*\*2 + (y - center1[1])\*\*2 < radius1\*\*2
>>> circle2 = (x - center2[0])\*\*2 + (y - center2[1])\*\*2 < radius2\*\*2
>>> circle3 = (x - center3[0])\*\*2 + (y - center3[1])\*\*2 < radius3\*\*2
>>> circle4 = (x - center4[0])\*\*2 + (y - center4[1])\*\*2 < radius4\*\*2

>>> # 4 circles
>>> img = circle1 + circle2 + circle3 + circle4
>>> mask = img.astype(bool)
>>> img = img.astype(float)

>>> img += 1 + 0.2\*np.random.randn(\*img.shape)
>>> # Convert the image into a graph with the value of the gradient on
>>> # the edges.
>>> graph = image.img\_to\_graph(img, mask=mask)

>>> # Take a decreasing function of the gradient: we take it weakly
>>> # dependant from the gradient the segmentation is close to a voronoi
>>> graph.data = np.exp(-graph.data/graph.data.std())

>>> labels = spectral\_clustering(graph, n\_clusters=4, eigen\_solver='arpack')
>>> label\_im = -np.ones(mask.shape)
>>> label\_im[mask] = labels

12.5. Feature extraction

242

Scipy lecture notes, Edition 2015.2

12.6 Measuring objects properties: ndimage.measurements

Synthetic data:

>>> n = 10
>>> l = 256
>>> im = np.zeros((l, l))
>>> points = l\*np.random.random((2, n\*\*2))
>>> im[(points[0]).astype(np.int), (points[1]).astype(np.int)] = 1
>>> im = ndimage.gaussian\_filter(im, sigma=l/(4.\*n))
>>> mask = im > im.mean()

• Analysis of connected components
Label connected components: ndimage.label:

>>> label\_im, nb\_labels = ndimage.label(mask)
>>> nb\_labels # how many regions?
16
>>> plt.imshow(label\_im)


Compute size, mean\_value, etc. of each region:

>>> sizes = ndimage.sum(mask, label\_im, range(nb\_labels + 1))
>>> mean\_vals = ndimage.sum(im, label\_im, range(1, nb\_labels + 1))

Clean up small connect components:

>>> mask\_size = sizes < 1000
>>> remove\_pixel = mask\_size[label\_im]

12.6. Measuring objects properties: ndimage.measurements

243

Scipy lecture notes, Edition 2015.2

>>> remove\_pixel.shape
(256, 256)
>>> label\_im[remove\_pixel] = 0
>>> plt.imshow(label\_im)


Now reassign labels with np.searchsorted:

>>> labels = np.unique(label\_im)
>>> label\_im = np.searchsorted(labels, label\_im)

Find region of interest enclosing object:

>>> slice\_x, slice\_y = ndimage.find\_objects(label\_im==4)[0]
>>> roi = im[slice\_x, slice\_y]
>>> plt.imshow(roi)


Other spatial measures: ndimage.center\_of\_mass, ndimage.maximum\_position, etc.

Can be used outside the limited scope of segmentation applications.

Example: block mean:

>>> from scipy import misc
>>> l = misc.lena()

12.6. Measuring objects properties: ndimage.measurements

244

Scipy lecture notes, Edition 2015.2

>>> sx, sy = l.shape
>>> X, Y = np.ogrid[0:sx, 0:sy]
>>> regions = (sy//6) \* (X//4) + (Y//6) # note that we use broadcasting
>>> block\_mean = ndimage.mean(l, labels=regions, index=np.arange(1,
...
>>> block\_mean.shape = (sx // 4, sy // 6)

regions.max() +1))

When regions are regular blocks, it is more efﬁcient to use stride tricks (Example: fake dimensions with strides).

Non-regularly-spaced blocks: radial mean:

>>> sx, sy = l.shape
>>> X, Y = np.ogrid[0:sx, 0:sy]
>>> r = np.hypot(X - sx/2, Y - sy/2)
>>> rbin = (20\* r/r.max()).astype(np.int)
>>> radial\_mean = ndimage.mean(l, labels=rbin, index=np.arange(1, rbin.max() +1))

• Other measures

Correlation function, Fourier/wavelet spectrum, etc.

One example with mathematical morphology: granulometry

struct = np.zeros((2 \* n + 1, 2 \* n + 1))
x, y = np.indices((2 \* n + 1, 2 \* n + 1))
mask = (x - n)\*\*2 + (y - n)\*\*2 <= n\*\*2
struct[mask] = 1
return struct.astype(np.bool)

>>> def disk\_structure(n):
...
...
...
...
...
...
>>>
>>> def granulometry(data, sizes=None):
...
...
...
...
...
...
...
>>>

s = max(data.shape)
if sizes == None:

granulo = [ndimage.binary\_opening(data, \

sizes = range(1, s/2, 2)

return granulo

structure=disk\_structure(n)).sum() for n in sizes]

12.6. Measuring objects properties: ndimage.measurements

245

Scipy lecture notes, Edition 2015.2

>>> np.random.seed(1)
>>> n = 10
>>> l = 256
>>> im = np.zeros((l, l))
>>> points = l\*np.random.random((2, n\*\*2))
>>> im[(points[0]).astype(np.int), (points[1]).astype(np.int)] = 1
>>> im = ndimage.gaussian\_filter(im, sigma=l/(4.\*n))
>>>
>>> mask = im > im.mean()
>>>
>>> granulo = granulometry(mask, sizes=np.arange(2, 19, 4))

See also:

More on image-processing:

• The chapter on Scikit-image

12.6. Measuring objects properties: ndimage.measurements

246

• Other, more powerful and complete modules: OpenCV (Python bindings), CellProﬁler, ITK with Python

bindings

Scipy lecture notes, Edition 2015.2

12.6. Measuring objects properties: ndimage.measurements

247

CHAPTER 13

Mathematical optimization: finding minima of functions

Authors: Gaël Varoquaux

Mathematical optimization deals with the problem of ﬁnding numerically minimums (or maximums or zeros)
of a function. In this context, the function is called cost function, or objective function, or energy.
Here, we are interested in using scipy.optimize for black-box optimization: we do not rely on the mathe-
matical expression of the function that we are optimizing. Note that this expression can often be used for more
efﬁcient, non black-box, optimization.

Prerequisites

• Numpy, Scipy
• IPython
• matplotlib

References

Mathematical optimization is very ... mathematical. If you want performance, it really pays to read the
books:

• Convex Optimization by Boyd and Vandenberghe (pdf available free online).
• Numerical Optimization, by Nocedal and Wright. Detailed reference on gradient descent methods.
• Practical Methods of Optimization by Fletcher: good at hand-waving explainations.

248

Scipy lecture notes, Edition 2015.2

Chapters contents

• Knowing your problem

– Convex versus non-convex optimization
– Smooth and non-smooth problems
– Noisy versus exact cost functions
– Constraints

• A review of the different optimizers

– Getting started: 1D optimization
– Gradient based methods
– Newton and quasi-newton methods
– Gradient-less methods
– Global optimizers

• Practical guide to optimization with scipy

– Choosing a method
– Making your optimizer faster
– Computing gradients
– Synthetic exercices

• Special case: non-linear least-squares

– Minimizing the norm of a vector function
– Curve ﬁtting

• Optimization with constraints

– Box bounds
– General constraints

13.1 Knowing your problem

Not all optimization problems are equal. Knowing your problem enables you to choose the right tool.

Dimensionality of the problem

The scale of an optimization problem is pretty much set by the dimensionality of the problem, i.e. the
number of scalar variables on which the search is performed.

13.1. Knowing your problem

249

13.1.1 Convex versus non-convex optimization

Scipy lecture notes, Edition 2015.2

A convex function:

• f is above all its tangents.
• equivalently, for two point A, B, f(C) lies below

the segment [f(A), f(B])], if A < C < B

A non-convex function

Optimizing convex functions is easy. Optimizing non-convex functions can be very hard.

It can be proven that for a convex function a local minimum is also a global minimum. Then, in some sense,
the minimum is unique.

13.1.2 Smooth and non-smooth problems

A smooth function:
The gradient is deﬁned everywhere, and is a continuous
function

A non-smooth function

Optimizing smooth functions is easier (true in the context of black-box optimization, otherwise Linear Pro-
gramming is an example of methods which deal very efﬁciently with piece-wise linear functions).

13.1. Knowing your problem

250

13.1.3 Noisy versus exact cost functions

Scipy lecture notes, Edition 2015.2

Noisy (blue) and non-noisy (green) functions

Noisy gradients

Many optimization methods rely on gradients of the objective function. If the gradient function is not
given, they are computed numerically, which induces errors. In such situation, even if the objective
function is not noisy,

13.1.4 Constraints

Optimizations under constraints
Here:
−1 < x1 < 1
−1 < x2 < 1

13.2 A review of the different optimizers

13.2.1 Getting started: 1D optimization

Use scipy.optimize.brent() to minimize 1D functions. It combines a bracketing strategy with a parabolic
approximation.

13.2. A review of the different optimizers

251

Scipy lecture notes, Edition 2015.2

Brent’s method on a quadratic function: it converges
in 3 iterations, as the quadratic approximation is then
exact.

Brent’s method on a non-convex function: note that
the fact that the optimizer avoided the local minimum
is a matter of luck.

return -np.exp(-(x - .7)\*\*2)

>>> from scipy import optimize
>>> def f(x):
...
>>> x\_min = optimize.brent(f) # It actually converges in 9 iterations!
>>> x\_min
0.699999999...
>>> x\_min - .7
-2.1605...e-10

Brent’s method
scipy.optimize.fminbound()

also

can

be

used

for

optimization

constrained

to

an

interval

using

In scipy 0.11, scipy.optimize.minimize\_scalar() gives a generic interface to 1D scalar minimization

13.2.2 Gradient based methods

Some intuitions about gradient descent

Here we focus on intuitions, not code. Code will follow.

Gradient descent basically consists in taking small steps in the direction of the gradient, that is the direction of
the steepest descent.

Table 13.1: Fixed step gradient descent

A well-conditionned quadratic function.

An ill-conditionned quadratic function.
The core problem of gradient-methods on ill-conditioned
problems is that the gradient tends not to point in the
direction of the minimum.

We can see that very anisotropic (ill-conditionned) functions are harder to optimize.

13.2. A review of the different optimizers

252

Scipy lecture notes, Edition 2015.2

Take home message: conditioning number and preconditioning

If you know natural scaling for your variables, prescale them so that they behave similarly. This is related
to preconditioning.

Also, it clearly can be advantageous to take bigger steps. This is done in gradient descent code using a line
search.

Table 13.2: Adaptive step gradient descent

A well-conditionned quadratic
function.

An ill-conditionned quadratic
function.

An ill-conditionned
non-quadratic function.

An ill-conditionned very
non-quadratic function.

The more a function looks like a quadratic function (elliptic iso-curves), the easier it is to optimize.

Conjugate gradient descent

The gradient descent algorithms above are toys not to be used on real problems.

As can be seen from the above experiments, one of the problems of the simple gradient descent algorithms, is
that it tends to oscillate across a valley, each time following the direction of the gradient, that makes it cross

13.2. A review of the different optimizers

253

Scipy lecture notes, Edition 2015.2

the valley. The conjugate gradient solves this problem by adding a friction term: each step depends on the two
last values of the gradient and sharp turns are reduced.

Table 13.3: Conjugate gradient descent

An ill-conditionned
non-quadratic function.

An ill-conditionned very
non-quadratic function.

Methods based on conjugate gradient are named with ‘cg’ in scipy. The simple conjugate gradient method to
minimize a function is scipy.optimize.fmin\_cg():

# The rosenbrock function

>>> def f(x):
...
>>> optimize.fmin\_cg(f, [2, 2])
Optimization terminated successfully.

return .5\*(1 - x[0])\*\*2 + (x[1] - x[0]\*\*2)\*\*2

Current function value: 0.000000
Iterations: 13
Function evaluations: 120
Gradient evaluations: 30

array([ 0.99998968,

0.99997855])

These methods need the gradient of the function. They can compute it, but will perform better if you can pass
them the gradient:

>>> def fprime(x):
...
>>> optimize.fmin\_cg(f, [2, 2], fprime=fprime)
Optimization terminated successfully.

return np.array((-2\*.5\*(1 - x[0]) - 4\*x[0]\*(x[1] - x[0]\*\*2), 2\*(x[1] - x[0]\*\*2)))

Current function value: 0.000000
Iterations: 13
Function evaluations: 30
Gradient evaluations: 30

array([ 0.99999199,

0.99998336])

Note that the function has only been evaluated 30 times, compared to 120 without the gradient.

13.2.3 Newton and quasi-newton methods

Newton methods: using the Hessian (2nd differential)

Newton methods use a local quadratic approximation to compute the jump direction. For this purpose, they
rely on the 2 ﬁrst derivative of the function: the gradient and the Hessian.

13.2. A review of the different optimizers

254

Scipy lecture notes, Edition 2015.2

An ill-conditionned quadratic function:
Note that, as the quadratic approximation is exact, the
Newton method is blazing fast

An ill-conditionned non-quadratic function:
Here we are optimizing a Gaussian, which is always below its
quadratic approximation. As a result, the Newton method
overshoots and leads to oscillations.

An ill-conditionned very non-quadratic function:

In scipy, the Newton method for optimization is implemented in scipy.optimize.fmin\_ncg() (cg here
refers to that fact that an inner operation, the inversion of the Hessian, is performed by conjugate gradient).
scipy.optimize.fmin\_tnc() can be use for constraint problems, although it is less versatile:

return .5\*(1 - x[0])\*\*2 + (x[1] - x[0]\*\*2)\*\*2

# The rosenbrock function

>>> def f(x):
...
>>> def fprime(x):
...
>>> optimize.fmin\_ncg(f, [2, 2], fprime=fprime)
Optimization terminated successfully.

return np.array((-2\*.5\*(1 - x[0]) - 4\*x[0]\*(x[1] - x[0]\*\*2), 2\*(x[1] - x[0]\*\*2)))

Current function value: 0.000000
Iterations: 9
Function evaluations: 11
Gradient evaluations: 51
Hessian evaluations: 0

array([ 1.,

1.])

Note that compared to a conjugate gradient (above), Newton’s method has required less function evaluations,
but more gradient evaluations, as it uses it to approximate the Hessian. Let’s compute the Hessian and pass it
to the algorithm:

>>> def hessian(x): # Computed with sympy
...
>>> optimize.fmin\_ncg(f, [2, 2], fprime=fprime, fhess=hessian)
Optimization terminated successfully.

return np.array(((1 - 4\*x[1] + 12\*x[0]\*\*2, -4\*x[0]), (-4\*x[0], 2)))

Current function value: 0.000000
Iterations: 9
Function evaluations: 11
Gradient evaluations: 19
Hessian evaluations: 9

array([ 1.,

1.])

At very high-dimension, the inversion of the Hessian can be costly and unstable (large scale > 250).

Newton optimizers should not to be confused with Newton’s root ﬁnding method, based on the same princi-
ples, scipy.optimize.newton().

13.2. A review of the different optimizers

255

Scipy lecture notes, Edition 2015.2

Quasi-Newton methods: approximating the Hessian on the fly

BFGS: BFGS (Broyden-Fletcher-Goldfarb-Shanno algorithm) reﬁnes at each step an approximation of the Hes-
sian.

An ill-conditionned quadratic function:
On a exactly quadratic function, BFGS is not as fast as
Newton’s method, but still very fast.

An ill-conditionned non-quadratic function:
Here BFGS does better than Newton, as its empirical estimate
of the curvature is better than that given by the Hessian.

An ill-conditionned very non-quadratic function:

return .5\*(1 - x[0])\*\*2 + (x[1] - x[0]\*\*2)\*\*2

# The rosenbrock function

>>> def f(x):
...
>>> def fprime(x):
...
>>> optimize.fmin\_bfgs(f, [2, 2], fprime=fprime)
Optimization terminated successfully.

return np.array((-2\*.5\*(1 - x[0]) - 4\*x[0]\*(x[1] - x[0]\*\*2), 2\*(x[1] - x[0]\*\*2)))

Current function value: 0.000000
Iterations: 16
Function evaluations: 24
Gradient evaluations: 24
1.00000026])

array([ 1.00000017,

L-BFGS: Limited-memory BFGS Sits between BFGS and conjugate gradient: in very high dimensions (> 250)
the Hessian matrix is too costly to compute and invert. L-BFGS keeps a low-rank version. In addition, the scipy
version, scipy.optimize.fmin\_l\_bfgs\_b(), includes box bounds:

# The rosenbrock function

return .5\*(1 - x[0])\*\*2 + (x[1] - x[0]\*\*2)\*\*2

>>> def f(x):
...
>>> def fprime(x):
...
>>> optimize.fmin\_l\_bfgs\_b(f, [2, 2], fprime=fprime)
(array([ 1.00000005,

1.00000009]), 1.4417677473011859e-15, {...})

return np.array((-2\*.5\*(1 - x[0]) - 4\*x[0]\*(x[1] - x[0]\*\*2), 2\*(x[1] - x[0]\*\*2)))

If you do not specify the gradient to the L-BFGS solver, you need to add approx\_grad=1

13.2.4 Gradient-less methods

A shooting method: the Powell algorithm

Almost a gradient approach

13.2. A review of the different optimizers

256

Scipy lecture notes, Edition 2015.2

An ill-conditionned quadratic function:
Powell’s method isn’t too sensitive to local
ill-conditionning in low dimensions

An ill-conditionned very non-quadratic function:

Simplex method: the Nelder-Mead

The Nelder-Mead algorithms is a generalization of dichotomy approaches to high-dimensional spaces. The
algorithm works by reﬁning a simplex, the generalization of intervals and triangles to high-dimensional spaces,
to bracket the minimum.

Strong points: it is robust to noise, as it does not rely on computing gradients. Thus it can work on functions
that are not locally smooth such as experimental data points, as long as they display a large-scale bell-shape
behavior. However it is slower than gradient-based methods on smooth, non-noisy functions.

An ill-conditionned
non-quadratic function:

An ill-conditionned very
non-quadratic function:

In scipy, scipy.optimize.fmin() implements the Nelder-Mead approach:

# The rosenbrock function

>>> def f(x):
...
>>> optimize.fmin(f, [2, 2])
Optimization terminated successfully.

return .5\*(1 - x[0])\*\*2 + (x[1] - x[0]\*\*2)\*\*2

Current function value: 0.000000
Iterations: 46
Function evaluations: 91
0.99996682])

array([ 0.99998568,

13.2. A review of the different optimizers

257

Scipy lecture notes, Edition 2015.2

13.2.5 Global optimizers

If your problem does not admit a unique local minimum (which can be hard to test unless the function is
convex), and you do not have prior information to initialize the optimization close to the solution, you may
need a global optimizer.

Brute force: a grid search

scipy.optimize.brute() evaluates the function on a given grid of parameters and returns the parameters
corresponding to the minimum value. The parameters are speciﬁed with ranges given to numpy.mgrid. By
default, 20 steps are taken in each direction:

# The rosenbrock function

>>> def f(x):
...
>>> optimize.brute(f, ((-1, 2), (-1, 2)))
array([ 1.00001462,

1.00001547])

return .5\*(1 - x[0])\*\*2 + (x[1] - x[0]\*\*2)\*\*2

13.3 Practical guide to optimization with scipy

13.3.1 Choosing a method

Without knowledge of the gradient

• In

general,

L-BFGS
(scipy.optimize.fmin\_l\_bfgs\_b()), even if you have to approximate numeri-
cally gradients

(scipy.optimize.fmin\_bfgs())

prefer

BFGS

or

• On well-conditioned problems, Powell

(scipy.optimize.fmin\_powell()) and
Nelder-Mead (scipy.optimize.fmin()), both gradient-free methods, work well in
high dimension, but they collapse for ill-conditioned problems.

With knowledge of the gradient

• BFGS (scipy.optimize.fmin\_bfgs()) or L-BFGS (scipy.optimize.fmin\_l\_bfgs\_b()).

• Computational overhead of BFGS is larger than that L-BFGS, itself larger than that of
conjugate gradient. On the other side, BFGS usually needs less function evaluations than
CG. Thus conjugate gradient method is better than BFGS at optimizing computationally
cheap functions.

With the Hessian

• If

you

can

compute

the

Hessian,

prefer

the

Newton method

(scipy.optimize.fmin\_ncg()).

13.3. Practical guide to optimization with scipy

258

If you have noisy measurements

Scipy lecture notes, Edition 2015.2

• Use

Nelder-Mead
(scipy.optimize.fmin\_powell()).

(scipy.optimize.fmin())

or

Powell

13.3.2 Making your optimizer faster

• Choose the right method (see above), do compute analytically the gradient and Hessian, if you can.

• Use preconditionning when possible.

• Choose your initialization points wisely. For instance, if you are running many similar optimizations,

warm-restart one with the results of another.

• Relax the tolerance if you don’t need precision

13.3.3 Computing gradients

Computing gradients, and even more Hessians, is very tedious but worth the effort. Symbolic computation
with Sympy may come in handy.

(cid:66)

A very common source of optimization not converging well is human error in the computation of the gradient.
You can use scipy.optimize.check\_grad() to check that your gradient is correct. It returns the norm of the
different between the gradient given, and a gradient computed numerically:

>>> optimize.check\_grad(f, fprime, [2, 2])
2.384185791015625e-07
See also scipy.optimize.approx\_fprime() to ﬁnd your errors.

13.3.4 Synthetic exercices

Exercice: A simple (?) quadratic function

Optimize the following function, using K[0] as a starting point:

np.random.seed(0)
K = np.random.normal(size=(100, 100))

def f(x):

return np.sum((np.dot(K, x - 1))\*\*2) + np.sum(x\*\*2)\*\*2

Time your approach. Find the fastest approach. Why is BFGS not working well?

13.3. Practical guide to optimization with scipy

259

Scipy lecture notes, Edition 2015.2

Exercice: A locally ﬂat minimum
Consider the function exp(-1/(.1\*x\*\*2 + y\*\*2). This function admits a minimum in (0, 0). Starting
from an initialization at (1, 1), try to get within 1e-8 of this minimum point.

13.4 Special case: non-linear least-squares

13.4.1 Minimizing the norm of a vector function

Least square problems, minimizing the norm of a vector function, have a speciﬁc structure that can be used in
the Levenberg–Marquardt algorithm implemented in scipy.optimize.leastsq().

Lets try to minimize the norm of the following vectorial function:

>>> def f(x):
...

return np.arctan(x) - np.arctan(np.linspace(0, 1, len(x)))

>>> x0 = np.zeros(10)
>>> optimize.leastsq(f, x0)
(array([ 0.

,

0.11111111,

0.22222222,

0.33333333,

0.44444444,

0.55555556,

0.66666667,

0.77777778,

0.88888889,

1.

]), 2)

This took 67 function evaluations (check it with ‘full\_output=1’). What if we compute the norm ourselves and
use a good generic optimizer (BFGS):

>>> def g(x):
return np.sum(f(x)\*\*2)
...
>>> optimize.fmin\_bfgs(g, x0)
Optimization terminated successfully.

Current function value: 0.000000
Iterations: 11
Function evaluations: 144
Gradient evaluations: 12
1.1...e-01,

array([ -7.4...-09,

2.2...e-01,

3.3...e-01,
6.6...e-01,
1.0...e+00])

4.4...e-01,
7.7...e-01,

5.5...e-01,
8.8...e-01,

BFGS needs more function calls, and gives a less precise result.

leastsq is interesting compared to BFGS only if the dimensionality of the output vector is large, and larger
than the number of parameters to optimize.

(cid:66)

If the function is linear, this is a linear-algebra problem, and should be solved with scipy.linalg.lstsq().

13.4. Special case: non-linear least-squares

260

13.4.2 Curve fitting

Scipy lecture notes, Edition 2015.2

Least square problems occur often when ﬁtting a non-
linear to data. While it is possible to construct our optimization problem ourselves, scipy provides a helper
function for this purpose: scipy.optimize.curve\_fit():

>>> def f(t, omega, phi):
...

return np.cos(omega \* t + phi)

>>> x = np.linspace(0, 3, 50)
>>> y = f(x, 1.5, 1) + .1\*np.random.normal(size=50)

>>> optimize.curve\_fit(f, x, y)
(array([ 1.51854577,
[-0.00056796,

0.92665541]), array([[ 0.00037994, -0.00056796],
0.00123978]]))

Exercise

Do the same with omega = 3. What is the difﬁculty?

13.5 Optimization with constraints

13.5.1 Box bounds

Box bounds correspond to limiting each of the individual parameters of the optimization. Note that some
problems that are not originally written as box bounds can be rewritten as such via change of variables.

• scipy.optimize.fminbound() for 1D-optimization
• scipy.optimize.fmin\_l\_bfgs\_b() a quasi-Newton method with bound constraints:

13.5. Optimization with constraints

261

Scipy lecture notes, Edition 2015.2

>>> def f(x):
...
>>> optimize.fmin\_l\_bfgs\_b(f, np.array([0, 0]), approx\_grad=1, bounds=((-1.5, 1.5), (-1.5, 1.5)))
(array([ 1.5,

return np.sqrt((x[0] - 3)\*\*2 + (x[1] - 2)\*\*2)

1.5]), 1.5811388300841898, {...})

13.5.2 General constraints

Equality and inequality constraints speciﬁed as functions: f(x) = 0 and g(x)< 0.

• scipy.optimize.fmin\_slsqp() Sequential least square programming: equality and inequality con-

straints:

>>> def f(x):
...

return np.sqrt((x[0] - 3)\*\*2 + (x[1] - 2)\*\*2)

>>> def constraint(x):
...

return np.atleast\_1d(1.5 - np.sum(np.abs(x)))

>>> optimize.fmin\_slsqp(f, np.array([0, 0]), ieqcons=[constraint, ])
Optimization terminated successfully.

(Exit mode 0)

Current function value: 2.47487373504
Iterations: 5
Function evaluations: 20
Gradient evaluations: 5

array([ 1.25004696,

0.24995304])

• scipy.optimize.fmin\_cobyla() Constraints optimization by linear approximation: inequality con-

straints only:

>>> optimize.fmin\_cobyla(f, np.array([0, 0]), cons=constraint)
array([ 1.25009622,

0.24990378])

(cid:66)

The above problem is known as the Lasso problem in statistics, and there exists very efﬁcient solvers for it (for
instance in scikit-learn). In general do not use generic solvers when speciﬁc ones exist.

Lagrange multipliers

If you are ready to do a bit of math, many constrained optimization problems can be converted to non-
constrained optimization problems using a mathematical trick known as Lagrange multipliers.

13.5. Optimization with constraints

262

CHAPTER 14

Interfacing with C

Author: Valentin Haenel

This chapter contains an introduction to the many different routes for making your native code (primarily
C/C++) available from Python, a process commonly referred to wrapping. The goal of this chapter is to give
you a ﬂavour of what technologies exist and what their respective merits and shortcomings are, so that you
can select the appropriate one for your speciﬁc needs. In any case, once you do start wrapping, you almost
certainly will want to consult the respective documentation for your selected technique.

Chapters contents

• Introduction
• Python-C-Api
• Ctypes
• SWIG
• Cython
• Summary
• Further Reading and References
• Exercises

14.1 Introduction

This chapter covers the following techniques:

• Python-C-Api

• Ctypes

• SWIG (Simpliﬁed Wrapper and Interface Generator)

• Cython

These four techniques are perhaps the most well known ones, of which Cython is probably the most advanced
one and the one you should consider using ﬁrst. The others are also important, if you want to understand the
wrapping problem from different angles. Having said that, there are other alternatives out there, but having
understood the basics of the ones above, you will be in a position to evaluate the technique of your choice to
see if it ﬁts your needs.

The following criteria may be useful when evaluating a technology:

• Are additional libraries required?

• Is the code autogenerated?

• Does it need to be compiled?

• Is there good support for interacting with Numpy arrays?

263

Scipy lecture notes, Edition 2015.2

• Does it support C++?

Before you set out, you should consider your use case. When interfacing with native code, there are usually
two use-cases that come up:

• Existing code in C/C++ that needs to be leveraged, either because it already exists, or because it is faster.

• Python code too slow, push inner loops to native code

Each technology is demonstrated by wrapping the cos function from math.h. While this is a mostly a trivial
example, it should serve us well to demonstrate the basics of the wrapping solution. Since each technique
also includes some form of Numpy support, this is also demonstrated using an example where the cosine is
computed on some kind of array.

Last but not least, two small warnings:

• All of these techniques may crash (segmentation fault) the Python interpreter, which is (usually) due to

bugs in the C code.

• All the examples have been done on Linux, they should be possible on other operating systems.

• You will need a C compiler for most of the examples.

14.2 Python-C-Api

The Python-C-API is the backbone of the standard Python interpreter (a.k.a CPython). Using this API it is
possible to write Python extension module in C and C++. Obviously, these extension modules can, by virtue of
language compatibility, call any function written in C or C++.

When using the Python-C-API, one usually writes much boilerplate code, ﬁrst to parse the arguments that were
given to a function, and later to construct the return type.

Advantages

• Requires no additional libraries

• Lots of low-level control

• Entirely usable from C++

Disadvantages

• May require a substantial amount of effort

• Much overhead in the code

• Must be compiled

• High maintenance cost

• No forward compatibility across Python versions as C-API changes

• Reference count bugs are easy to create and very hard to track down.

The Python-C-Api example here serves mainly for didactic reasons. Many of the other techniques actually
depend on this, so it is good to have a high-level understanding of how it works. In 99% of the use-cases you
will be better off, using an alternative technique.

Since refernce counting bugs are easy to create and hard to track down, anyone really needing to use the
Python C-API should read the section about objects, types and reference counts from the ofﬁcial python doc-
umentation. Additionally, there is a tool by the name of cpychecker which can help discover common errors
with reference counting.

14.2. Python-C-Api

264

Scipy lecture notes, Edition 2015.2

14.2.1 Example

The following C-extension module, make the cos function from the standard math library available to Python:

/\*

Example of wrapping cos function from math.h with the Python-C-API. \*/

# include 
# include 

wrapped cosine function \*/

/\*
static PyObject\* cos\_func(PyObject\* self, PyObject\* args)
{

double value;
double answer;

parse the input, from python float to c double \*/

/\*
if (!PyArg\_ParseTuple(args, "d", &value))

return NULL;

/\* if the above function returns -1, an appropriate Python exception will

\* have been set, and the function simply returns NULL
\*/

/\* call cos from libm \*/
answer = cos(value);

construct the output from cos, from c double to python float \*/

/\*
return Py\_BuildValue("f", answer);

}

/\*
define functions in module \*/
static PyMethodDef CosMethods[] =
{

{"cos\_func", cos\_func, METH\_VARARGS, "evaluate the cosine"},
{NULL, NULL, 0, NULL}

};

/\* module initialization \*/
PyMODINIT\_FUNC

initcos\_module(void)
{

(void) Py\_InitModule("cos\_module", CosMethods);

}

As you can see, there is much boilerplate, both to «massage» the arguments and return types into place and for
the module initialisation. Although some of this is amortised, as the extension grows, the boilerplate required
for each function(s) remains.
The standard python build system distutils supports compiling C-extensions from a setup.py, which is
rather convenient:

from distutils.core import setup, Extension

# define the extension module
cos\_module = Extension('cos\_module', sources=['cos\_module.c'])

# run the setup
setup(ext\_modules=[cos\_module])

This can be compiled:

$ cd advanced/interfacing\_with\_c/python\_c\_api

$ ls

14.2. Python-C-Api

265

Scipy lecture notes, Edition 2015.2

cos\_module.c setup.py

$ python setup.py build\_ext --inplace
running build\_ext
building 'cos\_module' extension
creating build
creating build/temp.linux-x86\_64-2.7
gcc -pthread -fno-strict-aliasing -g -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/home/esc/anaconda/include/python2.7 -c cos\_module.c -o build/temp.linux-x86\_64-2.7/cos\_module.o
gcc -pthread -shared build/temp.linux-x86\_64-2.7/cos\_module.o -L/home/esc/anaconda/lib -lpython2.7 -o /home/esc/git-working/scipy-lecture-notes/advanced/interfacing\_with\_c/python\_c\_api/cos\_module.so

$ ls
build/

cos\_module.c

cos\_module.so

setup.py

• build\_ext is to build extension modules
• --inplace will output the compiled extension module into the current directory

The ﬁle cos\_module.so contains the compiled extension, which we can now load in the IPython interpreter:

In [1]: import cos\_module

In [2]: cos\_module?
Type:
module
String Form:
File:
Docstring:

/home/esc/git-working/scipy-lecture-notes/advanced/interfacing\_with\_c/python\_c\_api/cos\_module.so


In [3]: dir(cos\_module)
Out[3]: ['\_\_doc\_\_', '\_\_file\_\_', '\_\_name\_\_', '\_\_package\_\_', 'cos\_func']

In [4]: cos\_module.cos\_func(1.0)
Out[4]: 0.5403023058681398

In [5]: cos\_module.cos\_func(0.0)
Out[5]: 1.0

In [6]: cos\_module.cos\_func(3.14159265359)
Out[7]: -1.0

Now let’s see how robust this is:

In [10]: cos\_module.cos\_func('foo')
---------------------------------------------------------------------------
TypeError
Traceback (most recent call last)
 in ()
----> 1 cos\_module.cos\_func('foo')

TypeError: a float is required

14.2.2 Numpy Support

Analog to the Python-C-API, Numpy, which is itself implemented as a C-extension, comes with the Numpy-C-
API. This API can be used to create and manipulate Numpy arrays from C, when writing a custom C-extension.
See also: :ref:‘advanced\_numpy‘\_.

If you do ever need to use the Numpy C-API refer to the documentation about Arrays and Iterators.

The following example shows how to pass Numpy arrays as arguments to functions and how to iterate over
Numpy arrays using the (old) Numpy-C-API. It simply takes an array as argument applies the cosine function
from the math.h and returns a resulting new array.

/\*

Example of wrapping the cos function from math.h using the Numpy-C-API. \*/

14.2. Python-C-Api

266

Scipy lecture notes, Edition 2015.2

# include 
# include 
# include 

wrapped cosine function \*/

/\*
static PyObject\* cos\_func\_np(PyObject\* self, PyObject\* args)
{

\*out\_array;

PyArrayObject \*in\_array;
PyObject
NpyIter \*in\_iter;
NpyIter \*out\_iter;
NpyIter\_IterNextFunc \*in\_iternext;
NpyIter\_IterNextFunc \*out\_iternext;

parse single numpy array argument \*/

/\*
if (!PyArg\_ParseTuple(args, "O!", &PyArray\_Type, ∈\_array))

return NULL;

construct the output array, like the input array \*/

/\*
out\_array = PyArray\_NewLikeArray(in\_array, NPY\_ANYORDER, NULL, 0);
if (out\_array == NULL)
return NULL;

create the iterators \*/

/\*
in\_iter = NpyIter\_New(in\_array, NPY\_ITER\_READONLY, NPY\_KEEPORDER,

NPY\_NO\_CASTING, NULL);

if (in\_iter == NULL)
goto fail;

out\_iter = NpyIter\_New((PyArrayObject \*)out\_array, NPY\_ITER\_READWRITE,

NPY\_KEEPORDER, NPY\_NO\_CASTING, NULL);

if (out\_iter == NULL) {

NpyIter\_Deallocate(in\_iter);
goto fail;

}

in\_iternext = NpyIter\_GetIterNext(in\_iter, NULL);
out\_iternext = NpyIter\_GetIterNext(out\_iter, NULL);
if (in\_iternext == NULL || out\_iternext == NULL) {

NpyIter\_Deallocate(in\_iter);
NpyIter\_Deallocate(out\_iter);
goto fail;

}
double \*\* in\_dataptr = (double \*\*) NpyIter\_GetDataPtrArray(in\_iter);
double \*\* out\_dataptr = (double \*\*) NpyIter\_GetDataPtrArray(out\_iter);

iterate over the arrays \*/

/\*
do {

\*\*out\_dataptr = cos(\*\*in\_dataptr);

} while(in\_iternext(in\_iter) && out\_iternext(out\_iter));

clean up and return the result \*/

/\*
NpyIter\_Deallocate(in\_iter);
NpyIter\_Deallocate(out\_iter);
Py\_INCREF(out\_array);
return out\_array;

in case bad things happen \*/

/\*
fail:

Py\_XDECREF(out\_array);
return NULL;

}

14.2. Python-C-Api

267

Scipy lecture notes, Edition 2015.2

define functions in module \*/
/\*
static PyMethodDef CosMethods[] =
{

{"cos\_func\_np", cos\_func\_np, METH\_VARARGS,

"evaluate the cosine on a numpy array"},

{NULL, NULL, 0, NULL}

};

/\* module initialization \*/
PyMODINIT\_FUNC
initcos\_module\_np(void)
{

(void) Py\_InitModule("cos\_module\_np", CosMethods);
/\* IMPORTANT: this must be called \*/
import\_array();

}

To compile this we can use distutils again. However we need to be sure to include the Numpy headers by using
:func:numpy.get\_include.

from distutils.core import setup, Extension
import numpy

# define the extension module
cos\_module\_np = Extension('cos\_module\_np', sources=['cos\_module\_np.c'],

include\_dirs=[numpy.get\_include()])

# run the setup
setup(ext\_modules=[cos\_module\_np])

To convince ourselves if this does actually works, we run the following test script:

import cos\_module\_np
import numpy as np
import pylab

x = np.arange(0, 2 \* np.pi, 0.1)
y = cos\_module\_np.cos\_func\_np(x)
pylab.plot(x, y)
pylab.show()

And this should result in the following ﬁgure:

14.3 Ctypes

Ctypes is a foreign function library for Python. It provides C compatible data types, and allows calling functions
in DLLs or shared libraries. It can be used to wrap these libraries in pure Python.

Advantages

• Part of the Python standard library

• Does not need to be compiled

• Wrapping code entirely in Python

14.3. Ctypes

268

Scipy lecture notes, Edition 2015.2

Disadvantages

• Requires code to be wrapped to be available as a shared library (roughly speaking \*.dll in Windows

\*.so in Linux and \*.dylib in Mac OSX.)

• No good support for C++

14.3.1 Example

As advertised, the wrapper code is in pure Python.

""" Example of wrapping cos function from math.h using ctypes. """

import ctypes
from ctypes.util import find\_library

# find and load the library
libm = ctypes.cdll.LoadLibrary(find\_library('m'))
# set the argument type
libm.cos.argtypes = [ctypes.c\_double]
# set the return type
libm.cos.restype = ctypes.c\_double

def cos\_func(arg):

''' Wrapper for cos from math.h '''
return libm.cos(arg)

• Finding and loading the library may vary depending on your operating system, check the documentation

for details

• This may be somewhat deceptive, since the math library exists in compiled form on the system already.
If you were to wrap a in-house library, you would have to compile it ﬁrst, which may or may not require
some additional effort.

We may now use this, as before:

In [1]: import cos\_module

In [2]: cos\_module?
Type:
module
String Form:
File:
Docstring:

/home/esc/git-working/scipy-lecture-notes/advanced/interfacing\_with\_c/ctypes/cos\_module.py


In [3]: dir(cos\_module)
Out[3]:
['\_\_builtins\_\_',

'\_\_doc\_\_',
'\_\_file\_\_',
'\_\_name\_\_',
'\_\_package\_\_',
'cos\_func',
'ctypes',
'find\_library',
'libm']

In [4]: cos\_module.cos\_func(1.0)
Out[4]: 0.5403023058681398

In [5]: cos\_module.cos\_func(0.0)
Out[5]: 1.0

14.3. Ctypes

269

Scipy lecture notes, Edition 2015.2

In [6]: cos\_module.cos\_func(3.14159265359)
Out[6]: -1.0

As with the previous example, this code is somewhat robust, although the error message is not quite as helpful,
since it does not tell us what the type should be.

In [7]: cos\_module.cos\_func('foo')
---------------------------------------------------------------------------
ArgumentError
Traceback (most recent call last)
 in ()
----> 1 cos\_module.cos\_func('foo')

/home/esc/git-working/scipy-lecture-notes/advanced/interfacing\_with\_c/ctypes/cos\_module.py in cos\_func(arg)

12 def cos\_func(arg):
13
---> 14

''' Wrapper for cos from math.h '''
return libm.cos(arg)

ArgumentError: argument 1: : wrong type

14.3.2 Numpy Support

Numpy contains some support for interfacing with ctypes. In particular there is support for exporting certain
attributes of a Numpy array as ctypes data-types and there are functions to convert from C arrays to Numpy
arrays and back.

For more information, consult the corresponding section in the Numpy Cookbook and the API documentation
for numpy.ndarray.ctypes and numpy.ctypeslib.

For the following example, let’s consider a C function in a library that takes an input and an output array,
computes the cosine of the input array and stores the result in the output array.

The library consists of the following header ﬁle (although this is not strictly needed for this example, we list it
for completeness):

void cos\_doubles(double \* in\_array, double \* out\_array, int size);

The function implementation resides in the following C source ﬁle:

# include 

Compute the cosine of each element in in\_array, storing the result in
out\_array. \*/

/\*
\*
void cos\_doubles(double \* in\_array, double \* out\_array, int size){

int i;
for(i=0;i

double cos\_func(double arg){

return cos(arg);

}

and the header ﬁle cos\_module.h:

double cos\_func(double arg);

And our goal is to expose the cos\_func to Python. To achieve this with SWIG, we must write an interface ﬁle
which contains the instructions for SWIG.

/\*

Example of wrapping cos function from math.h using SWIG. \*/

%module cos\_module
%{

/\* the resulting C file should be built as a python extension \*/
# define SWIG\_FILE\_WITH\_INIT
/\*
# include "cos\_module.h"

Includes the header in the wrapper code \*/

%}
/\*
%include "cos\_module.h"

Parse the header file to generate wrappers \*/

As you can see, not too much code is needed here. For this simple example it is enough to simply include
the header ﬁle in the interface ﬁle, to expose the function to Python. However, SWIG does allow for more ﬁne
grained inclusion/exclusion of functions found in header ﬁles, check the documentation for details.

Generating the compiled wrappers is a two stage process:

1. Run the swig executable on the interface ﬁle to generate the ﬁles cos\_module\_wrap.c, which is the
source ﬁle for the autogenerated Python C-extension and cos\_module.py, which is the autogenerated
pure python module.

14.4. SWIG

272

2. Compile the cos\_module\_wrap.c into the \_cos\_module.so. Luckily, distutils knows how to handle

SWIG interface ﬁles, so that our setup.py is simply:

Scipy lecture notes, Edition 2015.2

from distutils.core import setup, Extension

setup(ext\_modules=[Extension("\_cos\_module",

sources=["cos\_module.c", "cos\_module.i"])])

$ cd advanced/interfacing\_with\_c/swig

$ ls
cos\_module.c cos\_module.h

cos\_module.i setup.py

$ python setup.py build\_ext --inplace
running build\_ext
building '\_cos\_module' extension
swigging cos\_module.i to cos\_module\_wrap.c
swig -python -o cos\_module\_wrap.c cos\_module.i
creating build
creating build/temp.linux-x86\_64-2.7
gcc -pthread -fno-strict-aliasing -g -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/home/esc/anaconda/include/python2.7 -c cos\_module.c -o build/temp.linux-x86\_64-2.7/cos\_module.o
gcc -pthread -fno-strict-aliasing -g -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/home/esc/anaconda/include/python2.7 -c cos\_module\_wrap.c -o build/temp.linux-x86\_64-2.7/cos\_module\_wrap.o
gcc -pthread -shared build/temp.linux-x86\_64-2.7/cos\_module.o build/temp.linux-x86\_64-2.7/cos\_module\_wrap.o -L/home/esc/anaconda/lib -lpython2.7 -o /home/esc/git-working/scipy-lecture-notes/advanced/interfacing\_with\_c/swig/\_cos\_module.so

$ ls
build/

cos\_module.c

cos\_module.h

cos\_module.i

cos\_module.py

\_cos\_module.so\*

cos\_module\_wrap.c

setup.py

We can now load and execute the cos\_module as we have done in the previous examples:

In [1]: import cos\_module

In [2]: cos\_module?
Type:
module
String Form:
File:
Docstring:

/home/esc/git-working/scipy-lecture-notes/advanced/interfacing\_with\_c/swig/cos\_module.py


In [3]: dir(cos\_module)
Out[3]:
['\_\_builtins\_\_',

'\_\_doc\_\_',
'\_\_file\_\_',
'\_\_name\_\_',
'\_\_package\_\_',
'\_cos\_module',
'\_newclass',
'\_object',
'\_swig\_getattr',
'\_swig\_property',
'\_swig\_repr',
'\_swig\_setattr',
'\_swig\_setattr\_nondynamic',
'cos\_func']

In [4]: cos\_module.cos\_func(1.0)
Out[4]: 0.5403023058681398

In [5]: cos\_module.cos\_func(0.0)
Out[5]: 1.0

In [6]: cos\_module.cos\_func(3.14159265359)
Out[6]: -1.0

Again we test for robustness, and we see that we get a better error message (although, strictly speaking in

14.4. SWIG

273

Scipy lecture notes, Edition 2015.2

Python there is no double type):

In [7]: cos\_module.cos\_func('foo')
---------------------------------------------------------------------------
TypeError
Traceback (most recent call last)
 in ()
----> 1 cos\_module.cos\_func('foo')

TypeError: in method 'cos\_func', argument 1 of type 'double'

14.4.2 Numpy Support

Numpy provides support for SWIG with the numpy.i ﬁle. This interface ﬁle deﬁnes various so-called typemaps
which support conversion between Numpy arrays and C-Arrays. In the following example we will take a quick
look at how such typemaps work in practice.
We have the same cos\_doubles function as in the ctypes example:

void cos\_doubles(double \* in\_array, double \* out\_array, int size);

# include 

Compute the cosine of each element in in\_array, storing the result in
out\_array. \*/

/\*
\*
void cos\_doubles(double \* in\_array, double \* out\_array, int size){

int i;
for(i=0;i
File:
Docstring:

/home/esc/git-working/scipy-lecture-notes/advanced/interfacing\_with\_c/cython/cos\_module.so


In [3]: dir(cos\_module)
Out[3]:
['\_\_builtins\_\_',

'\_\_doc\_\_',
'\_\_file\_\_',
'\_\_name\_\_',
'\_\_package\_\_',
'\_\_test\_\_',
'cos\_func']

In [4]: cos\_module.cos\_func(1.0)
Out[4]: 0.5403023058681398

In [5]: cos\_module.cos\_func(0.0)
Out[5]: 1.0

In [6]: cos\_module.cos\_func(3.14159265359)
Out[6]: -1.0

And, testing a little for robustness, we can see that we get good error messages:

In [7]: cos\_module.cos\_func('foo')
---------------------------------------------------------------------------
TypeError
Traceback (most recent call last)
 in ()
----> 1 cos\_module.cos\_func('foo')

/home/esc/git-working/scipy-lecture-notes/advanced/interfacing\_with\_c/cython/cos\_module.so in cos\_module.cos\_func (cos\_module.c:506)()

TypeError: a float is required

14.5. Cython

277

Scipy lecture notes, Edition 2015.2

Additionally, it is worth noting that Cython ships with complete declarations for the C math library, which
simpliﬁes the code above to become:

""" Simpler example of wrapping cos function from math.h using Cython. """

from libc.math cimport cos

def cos\_func(arg):
return cos(arg)

In this case the cimport statement is used to import the cos function.

14.5.2 Numpy Support

I.e.

Cython has support for Numpy via the numpy.pyx ﬁle which allows you to add the Numpy array type to your
like specifying that variable i is of type int, you can specify that variable a is of type
Cython code.
numpy.ndarray with a given dtype. Also, certain optimizations such as bounds checking are supported. Look
at the corresponding section in the Cython documentation. In case you want to pass Numpy arrays as C arrays
to your Cython wrapped C functions, there is a section about this in the Cython wiki.
In the following example, we will show how to wrap the familiar cos\_doubles function using Cython.

void cos\_doubles(double \* in\_array, double \* out\_array, int size);

# include 

Compute the cosine of each element in in\_array, storing the result in
out\_array. \*/

/\*
\*
void cos\_doubles(double \* in\_array, double \* out\_array, int size){

int i;
for(i=0;i np.PyArray\_DATA(in\_array),

 np.PyArray\_DATA(out\_array),
in\_array.shape[0])

And can be compiled using distutils:

from distutils.core import setup, Extension
import numpy
from Cython.Distutils import build\_ext

14.5. Cython

278

Scipy lecture notes, Edition 2015.2

setup(

cmdclass={'build\_ext': build\_ext},
ext\_modules=[Extension("cos\_doubles",

sources=["\_cos\_doubles.pyx", "cos\_doubles.c"],
include\_dirs=[numpy.get\_include()])],

)

• As with the previous compiled Numpy examples, we need the include\_dirs option.

setup.py

cos\_doubles.h

\_cos\_doubles.pyx

$ ls
cos\_doubles.c
$ python setup.py build\_ext -i
running build\_ext
cythoning \_cos\_doubles.pyx to \_cos\_doubles.c
building 'cos\_doubles' extension
creating build
creating build/temp.linux-x86\_64-2.7
gcc -pthread -fno-strict-aliasing -g -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include -I/home/esc/anaconda/include/python2.7 -c \_cos\_doubles.c -o build/temp.linux-x86\_64-2.7/\_cos\_doubles.o
In file included from /home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include/numpy/ndarraytypes.h:1722,

test\_cos\_doubles.py

from /home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include/numpy/ndarrayobject.h:17,
from /home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include/numpy/arrayobject.h:15,
from \_cos\_doubles.c:253:

/home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include/numpy/npy\_deprecated\_api.h:11:2: warning: #warning "Using deprecated NumPy API, disable it by #defining NPY\_NO\_DEPRECATED\_API NPY\_1\_7\_API\_VERSION"
/home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include/numpy/\_\_ufunc\_api.h:236: warning: ‘\_import\_umath’ defined but not used
gcc -pthread -fno-strict-aliasing -g -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include -I/home/esc/anaconda/include/python2.7 -c cos\_doubles.c -o build/temp.linux-x86\_64-2.7/cos\_doubles.o
gcc -pthread -shared build/temp.linux-x86\_64-2.7/\_cos\_doubles.o build/temp.linux-x86\_64-2.7/cos\_doubles.o -L/home/esc/anaconda/lib -lpython2.7 -o /home/esc/git-working/scipy-lecture-notes/advanced/interfacing\_with\_c/cython\_numpy/cos\_doubles.so
$ ls
build/

cos\_doubles.c cos\_doubles.h

test\_cos\_doubles.py

\_cos\_doubles.pyx

cos\_doubles.so\*

\_cos\_doubles.c

setup.py

And, as before, we convince ourselves that it worked:

import numpy as np
import pylab
import cos\_doubles

x = np.arange(0, 2 \* np.pi, 0.1)
y = np.empty\_like(x)

cos\_doubles.cos\_doubles\_func(x, y)
pylab.plot(x, y)
pylab.show()

14.6 Summary

In this section four different techniques for interfacing with native code have been presented. The table below
roughly summarizes some of the aspects of the techniques.

x
Python-C-API
Ctypes
Swig
Cython

Part of CPython
True
True
False
False

Compiled
True
False
True
True

Autogenerated
False
False
True
True

Numpy Support
True
True
True
True

14.6. Summary

279

Scipy lecture notes, Edition 2015.2

Of all three presented techniques, Cython is the most modern and advanced. In particular, the ability to opti-
mize code incrementally by adding types to your Python code is unique.

14.7 Further Reading and References

• Gaël Varoquaux’s blog post about avoiding data copies provides some insight on how to handle memory
management cleverly. If you ever run into issues with large datasets, this is a reference to come back to
for some inspiration.

14.8 Exercises

Since this is a brand new section, the exercises are considered more as pointers as to what to look at next, so
pick the ones that you ﬁnd more interesting. If you have good ideas for exercises, please let us know!

1. Download the source code for each example and compile and run them on your machine.
2. Make trivial changes to each example and convince yourself that this works. ( E.g. change cos for sin.)

3. Most of the examples, especially the ones involving Numpy may still be fragile and respond badly to
input errors. Look for ways to crash the examples, ﬁgure what the problem is and devise a potential
solution. Here are some ideas:

(a) Numerical overﬂow.

(b) Input and output arrays that have different lengths.

(c) Multidimensional array.

(d) Empty array
(e) Arrays with non-double types

4. Use the %timeit IPython magic to measure the execution time of the various solutions

14.8.1 Python-C-API

1. Modify the Numpy example such that the function takes two input arguments, where the second is the

preallocated output array, making it similar to the other Numpy examples.

2. Modify the example such that the function only takes a single input array and modiﬁes this in place.

3. Try to ﬁx the example to use the new Numpy iterator protocol. If you manage to obtain a working solu-

tion, please submit a pull-request on github.

4. You may have noticed, that the Numpy-C-API example is the only Numpy example that does not wrap
cos\_doubles but instead applies the cos function directly to the elements of the Numpy array. Does
this have any advantages over the other techniques.

5. Can you wrap cos\_doubles using only the Numpy-C-API. You may need to ensure that the arrays have

the correct type, are one dimensional and contiguous in memory.

14.8.2 Ctypes

1. Modify the Numpy example such that cos\_doubles\_func handles the preallocation for you, thus mak-

ing it more like the Numpy-C-API example.

14.7. Further Reading and References

280

Scipy lecture notes, Edition 2015.2

14.8.3 SWIG

1. Look at the code that SWIG autogenerates, how much of it do you understand?
2. Modify the Numpy example such that cos\_doubles\_func handles the preallocation for you, thus mak-

ing it more like the Numpy-C-API example.

3. Modify the cos\_doubles C function so that it returns an allocated array. Can you wrap this using SWIG
typemaps? If not, why not? Is there a workaround for this speciﬁc situation? (Hint: you know the size of
the output array, so it may be possible to construct a Numpy array from the returned double \*.)

14.8.4 Cython

1. Look at the code that Cython autogenerates. Take a closer look at some of the comments that Cython

inserts. What do you see?

2. Look at the section Working with Numpy from the Cython documentation to learn how to incrementally

optimize a pure python script that uses Numpy.

3. Modify the Numpy example such that cos\_doubles\_func handles the preallocation for you, thus mak-

ing it more like the Numpy-C-API example.

14.8. Exercises

281

Part III

Packages and applications

282

This part of the Scipy lecture notes is dedicated to various scientiﬁc packages useful for extended needs.

Scipy lecture notes, Edition 2015.2

283

CHAPTER 15

Statistics in Python

Author: Gaël Varoquaux

Requirements

• Standard scientiﬁc Python environment (numpy, scipy, matplotlib)
• Pandas
• Statsmodels
• Seaborn

To install Python and these dependencies, we recommend that you download Anaconda Python or En-
thought Canopy, or preferably use the package manager if you are under Ubuntu or other linux.

See also:

Bayesian statistics in Python

This chapter does not cover tools for Bayesian statistics. Of particular interest for Bayesian modelling is PyMC,
which implements a probabilistic programming language in Python.

Why Python for statistics?
R is a language dedicated to statistics. Python is a general-purpose language with statistics modules. R has
more statistical analysis features than Python, and specialized syntaxes. However, when it comes to building
complex analysis pipelines that mix statistics with e.g. image analysis, text mining, or control of a physical
experiment, the richness of Python is an invaluable asset.

284

Scipy lecture notes, Edition 2015.2

Contents

• Data representation and interaction

– Data as a table
– The panda data-frame

• Hypothesis testing: comparing two groups

– Student’s t-test: the simplest statistical test
– Paired tests: repeated measurements on the same indivuals

• Linear models, multiple factors, and analysis of variance

– “formulas” to specify statistical models in Python
– Multiple Regression: including multiple factors
– Post-hoc hypothesis testing: analysis of variance (ANOVA)

• More visualization: seaborn for statistical exploration

– Pairplot: scatter matrices
– lmplot: plotting a univariate regression

• Testing for interactions

In this document, the Python inputs are represented with the sign “>>>”.

Disclaimer: Gender questions
Some of the examples of this tutorial are chosen around gender questions. The reason is that on such questions
controlling the truth of a claim actually matters to many people.

15.1 Data representation and interaction

15.1.1 Data as a table

The setting that we consider for statistical analysis is that of multiple observations or samples described by
a set of different attributes or features. The data can than be seen as a 2D table, or matrix, with columns
giving the different attributes of the data, and rows the observations. For instance, the data contained in
examples/brain\_size.csv:

"";"Gender";"FSIQ";"VIQ";"PIQ";"Weight";"Height";"MRI\_Count"
"1";"Female";133;132;124;"118";"64.5";816932
"2";"Male";140;150;124;".";"72.5";1001121
"3";"Male";139;123;150;"143";"73.3";1038437
"4";"Male";133;129;128;"172";"68.8";965353
"5";"Female";137;132;134;"147";"65.0";951545

15.1.2 The panda data-frame

We will store and manipulate this data in a pandas.DataFrame, from the pandas module. It is the Python
equivalent of the spreadsheet table. It is different from a 2D numpy array as it has named columns, can contain
a mixture of different data types by column, and has elaborate selection and pivotal mechanisms.

Creating dataframes: reading data files or converting arrays

Separator

It is a CSV ﬁle, but the separator is ”;”

15.1. Data representation and interaction

285

Scipy lecture notes, Edition 2015.2

Reading from a CSV ﬁle: Using the above CSV ﬁle that gives observations of brain size and weight and IQ
(Willerman et al. 1991), the data are a mixture of numerical and categorical values:

>>> import pandas
>>> data = pandas.read\_csv('examples/brain\_size.csv', sep=';', na\_values=".")
>>> data

Unnamed: 0
1
2
3
4
5

Gender
Female
Male
Male
Male
Female

FSIQ
133
140
139
133
137

VIQ
132
150
123
129
132

PIQ
124
124
150
128
134

Weight
118
NaN
143
172
147

Height
64.5
72.5
73.3
68.8
65.0

MRI\_Count
816932
1001121
1038437
965353
951545

0
1
2
3
4
...

(cid:66)

Missing values
The weight of the second individual is missing in the CSV ﬁle. If we don’t specify the missing value (NA = not
available) marker, we will not be able to do statistical analysis.

Creating from arrays: A pandas.DataFrame can also be seen as a dictionary of 1D ‘series’, eg arrays or lists. If
we have 3 numpy arrays:

>>> import numpy as np
>>> t = np.linspace(-6, 6, 20)
>>> sin\_t = np.sin(t)
>>> cos\_t = np.cos(t)

We can expose them as a pandas.DataFrame:

>>> pandas.DataFrame({'t': t, 'sin': sin\_t, 'cos': cos\_t})

sin

t
cos
0.279415 -6.000000
0.960170
0.792419 -5.368421
0.609977
0.999701 -4.736842
0.024451
0.821291 -4.105263
-0.570509
-0.945363
0.326021 -3.473684
-0.955488 -0.295030 -2.842105
-0.596979 -0.802257 -2.210526
-0.008151 -0.999967 -1.578947
0.583822 -0.811882 -0.947368

0
1
2
3
4
5
6
7
8
...

Other inputs: pandas can input data from SQL, excel ﬁles, or other formats. See the pandas documentation.

Manipulating data

data is a pandas.DataFrame, that resembles R’s dataframe:

>>> data.shape
(40, 8)

# 40 rows and 8 columns

15.1. Data representation and interaction

286

>>> data.columns # It has columns
Index([u'Unnamed: 0', u'Gender', u'FSIQ', u'VIQ', u'PIQ', u'Weight', u'Height', u'MRI\_Count'], dtype='object')

Scipy lecture notes, Edition 2015.2

>>> print(data['Gender']) # Columns can be addressed by name
0
1
2
3
4
...

Female
Male
Male
Male
Female

>>> # Simpler selector
>>> data[data['Gender'] == 'Female']['VIQ'].mean()
109.45

For a quick view on a large dataframe, use its describe method: pandas.DataFrame.describe().

groupby: splitting a dataframe on values of categorical variables:

>>> groupby\_gender = data.groupby('Gender')
>>> for gender, value in groupby\_gender['VIQ']:
print((gender, value.mean()))
...
('Female', 109.45)
('Male', 115.25)

groupby\_gender is a powerful object that exposes many operations on the resulting group of dataframes:

>>> groupby\_gender.mean()
FSIQ
Unnamed: 0

VIQ

PIQ

Weight

Height

MRI\_Count

Gender
Female
Male

19.65
21.35

111.9
115.0

109.45
115.25

110.45
111.60

137.200000
166.444444

65.765000
71.431579

862654.6
954855.4

Use tab-completion on groupby\_gender to ﬁnd more. Other common grouping functions are median, count
(useful for checking to see the amount of missing values in different subsets) or sum. Groupby evaluation is
lazy, no work is done until an aggregation function is applied.

15.1. Data representation and interaction

287

Scipy lecture notes, Edition 2015.2

Exercise

• What is the mean value for VIQ for the full population?
• How many males/females were included in this study?

Hint use ‘tab completion’ to ﬁnd out the methods that can be called, instead of ‘mean’ in the above
example.

• What is the average value of MRI counts expressed in log units, for males and females?

groupby\_gender.boxplot is used for the plots above (see this example).

Plotting data

Pandas comes with some plotting tools (pandas.tools.plotting, using matplotlib behind the scene) to dis-
play statistics of the data in dataframes:

Scatter matrices:

>>> from pandas.tools import plotting
>>> plotting.scatter\_matrix(data[['Weight', 'Height', 'MRI\_Count']])

>>> plotting.scatter\_matrix(data[['PIQ', 'VIQ', 'FSIQ']])

Two populations

The IQ metrics are bimodal, as if there are 2 sub-populations.

15.1. Data representation and interaction

288

Scipy lecture notes, Edition 2015.2

Exercise

Plot the scatter matrix for males only, and for females only. Do you think that the 2 sub-populations
correspond to gender?

15.2 Hypothesis testing: comparing two groups

For simple statistical tests, we will use the scipy.stats sub-module of scipy:

>>> from scipy import stats

See also:

Scipy is a vast library. For a quick summary to the whole library, see the scipy chapter.

15.2. Hypothesis testing: comparing two groups

289

Scipy lecture notes, Edition 2015.2

15.2.1 Student’s t-test: the simplest statistical test

1-sample t-test: testing the value of a population mean

scipy.stats.ttest\_1samp() tests if the population mean of data is likely to be equal to a given value (tech-
nically if observations are drawn from a Gaussian distributions of given population mean). It returns the T
statistic, and the p-value (see the function’s help):

>>> stats.ttest\_1samp(data['VIQ'], 0)
(...30.088099970..., 1.32891964...e-28)

With a p-value of 10^-28 we can claim that the population mean for the IQ (VIQ measure) is not 0.

2-sample t-test: testing for difference across populations

We have seen above that the mean VIQ in the male and female populations were different. To test if this is
signiﬁcant, we do a 2-sample t-test with scipy.stats.ttest\_ind():

>>> female\_viq = data[data['Gender'] == 'Female']['VIQ']
>>> male\_viq = data[data['Gender'] == 'Male']['VIQ']
>>> stats.ttest\_ind(female\_viq, male\_viq)
(...-0.77261617232..., 0.4445287677858...)

15.2. Hypothesis testing: comparing two groups

290

15.2.2 Paired tests: repeated measurements on the same indivuals

Scipy lecture notes, Edition 2015.2

and PIQ are signiﬁcantly different. We can use a 2 sample test:

>>> stats.ttest\_ind(data['FSIQ'], data['PIQ'])
(...0.46563759638..., 0.64277250...)

PIQ, VIQ, and FSIQ give 3 measures of IQ. Let us test if FISQ

The problem with this approach is that it forgets that there are links between observations: FSIQ and PIQ are
measured on the same individuals. Thus the variance due to inter-subject variability is confounding, and can
be removed, using a “paired test”, or “repeated measures test”:

>>> stats.ttest\_rel(data['FSIQ'], data['PIQ'])
(...1.784201940..., 0.082172638183...)

>>> stats.ttest\_1samp(data['FSIQ'] - data['PIQ'], 0)
(...1.784201940..., 0.082172638...)

This is equivalent to a 1-sample test on the difference:

T-tests assume Gaussian errors. We can use a Wilcoxon signed-rank test, that relaxes this assumption:

>>> stats.wilcoxon(data['FSIQ'], data['PIQ'])
(274.5, 0.106594927...)

The corresponding test in the non paired case is the Mann–Whitney U test, scipy.stats.mannwhitneyu().

Exercice

• Test the difference between weights in males and females.
• Use non parametric statistics to test the difference between VIQ in males and females.

Conclusion: we ﬁnd that the data does not support the hypothesis that males and females have different
VIQ.

15.2. Hypothesis testing: comparing two groups

291

Scipy lecture notes, Edition 2015.2

15.3 Linear models, multiple factors, and analysis of variance

15.3.1 “formulas” to specify statistical models in Python

A simple linear regression

the hypothesis that y is a linear function of x. In other terms:

Given two set of observations, x and y, we want to test

y = x ∗ coe f + i nt er cept + e

where e is observation noise. We will use the statmodels module to:

1. Fit a linear model. We will use the simplest strategy, ordinary least squares (OLS).
2. Test that coef is non zero.

First, we generate simulated data according to the model:

>>> import numpy as np
>>> x = np.linspace(-5, 5, 20)
>>> np.random.seed(1)
>>> # normal distributed noise
>>> y = -5 + 3\*x + 4 \* np.random.normal(size=x.shape)
>>> # Create a data frame containing all the relevant variables
>>> data = pandas.DataFrame({'x': x, 'y': y})

“formulas” for statistics in Python

See the statsmodels documentation

Then we specify an OLS model and ﬁt it:

15.3. Linear models, multiple factors, and analysis of variance

292

Scipy lecture notes, Edition 2015.2

>>> from statsmodels.formula.api import ols
>>> model = ols("y ~ x", data).fit()

We can inspect the various statistics derived from the ﬁt:

>>> print(model.summary())

OLS Regression Results

==========================...
Dep. Variable:
Model:
Method:
Date:
Time:
No. Observations:
Df Residuals:
Df Model:
==========================...

...

y
OLS
Least Squares

...

20
18
1

R-squared:
Adj. R-squared:
F-statistic:
Prob (F-statistic):
Log-Likelihood:
AIC:
BIC:

0.804
0.794
74.03
8.56e-08
-57.988
120.0
122.0

coef

std err

t

P>|t|

[95.0% Conf. Int.]

1.036
0.341

-5.5335
2.9369

------------------------------------------...
Intercept
x
==========================...
Omnibus:
Prob(Omnibus):
Skew:
Kurtosis:
==========================...

0.100
0.951
-0.058
2.390

-5.342
8.604

Durbin-Watson:
Jarque-Bera (JB):
Prob(JB):
Cond. No.

0.000
0.000

-7.710
2.220

-3.357
3.654

2.956
0.322
0.851
3.03

Terminology:
Statsmodel uses a statistical terminology: the y variable in statsmodel is called ‘endogenous’ while the x
variable is called exogenous. This is discussed in more detail here.
To simplify, y (endogenous) is the value you are trying to predict, while x (exogenous) represents the
features you are using to make the prediction.

Exercise

Retrieve the estimated parameters from the model above. Hint: use tab-completion to ﬁnd the relevent
attribute.

Categorical variables: comparing groups or multiple categories

Let us go back the data on brain size:

>>> data = pandas.read\_csv('examples/brain\_size.csv', sep=';', na\_values=".")

We can write a comparison between IQ of male and female using a linear model:

>>> model = ols("VIQ ~ Gender + 1", data).fit()
>>> print(model.summary())

OLS Regression Results

==========================...
Dep. Variable:
Model:
Method:

VIQ
OLS
Least Squares

R-squared:
Adj. R-squared:
F-statistic:

0.015
-0.010
0.5969

15.3. Linear models, multiple factors, and analysis of variance

293

Scipy lecture notes, Edition 2015.2

...

Date:
Time:
No. Observations:
Df Residuals:
Df Model:
==========================...

...

40
38
1

Prob (F-statistic):
Log-Likelihood:
AIC:
BIC:

0.445
-182.42
368.8
372.2

coef

std err

t

P>|t|

[95.0% Conf. Int.]

5.308
7.507

109.4500
5.8000

-----------------------------------------------------------------------...
Intercept
Gender[T.Male]
==========================...
Omnibus:
Prob(Omnibus):
Skew:
Kurtosis:
==========================...

Durbin-Watson:
Jarque-Bera (JB):
Prob(JB):
Cond. No.

26.188
0.000
0.010
1.510

20.619
0.773

98.704
-9.397

0.000
0.445

120.196
20.997

1.709
3.703
0.157
2.62

Tips on specifying model

Forcing categorical: the ‘Gender’ is automatical detected as a categorical variable, and thus each of its
different values are treated as different entities.
An integer column can be forced to be treated as categorical using:

>>> model = ols('VIQ ~ C(Gender)', data).fit()
Intercept: We can remove the intercept using - 1 in the formula, or force the use of an intercept using +
1.
By default, statsmodel treats a categorical variable with K possible values as K-1 ‘dummy’ boolean
variables (the last level being absorbed into the intercept term). This is almost always a good
default choice - however,
it is possible to specify different encodings for categorical variables
(http://statsmodels.sourceforge.net/devel/contrasts.html).

15.3. Linear models, multiple factors, and analysis of variance

294

Scipy lecture notes, Edition 2015.2

Link to t-tests between different FSIQ and PIQ

To compare different type of IQ, we need to create a “long-form” table, listing IQs, where the type of IQ is
indicated by a categorical variable:

>>> data\_fisq = pandas.DataFrame({'iq': data['FSIQ'], 'type': 'fsiq'})
>>> data\_piq = pandas.DataFrame({'iq': data['PIQ'], 'type': 'piq'})
>>> data\_long = pandas.concat((data\_fisq, data\_piq))
>>> print(data\_long)
iq
133
140
139

type
fsiq
fsiq
fsiq

0
1
2
...
31
32
33
...

137
110
86

piq
piq
piq

>>> model = ols("iq ~ type", data\_long).fit()
>>> print(model.summary())

OLS Regression Results

...
==========================...

coef

std err

t

P>|t|

[95.0% Conf. Int.]

------------------------------------------...
Intercept
type[T.piq]
...

113.4500
-2.4250

30.807
-0.466

3.683
5.208

0.000
0.643

106.119
-12.793

120.781
7.943

We can see that we retrieve the same values for t-test and corresponding p-values for the effect of the
type of iq than the previous t-test:

>>> stats.ttest\_ind(data['FSIQ'], data['PIQ'])
(...0.46563759638..., 0.64277250...)

15.3.2 Multiple Regression: including multiple factors

Consider a linear model explaining a variable z (the dependent variable) with 2 variables x and y:

z = x c1 + y c2 + i + e

Such a model can be seen in 3D as ﬁtting a plane to a cloud of (x, y, z) points.

15.3. Linear models, multiple factors, and analysis of variance

295

Scipy lecture notes, Edition 2015.2

Example: the iris data (examples/iris.csv)

Sepal and petal size tend to be related: bigger ﬂowers are bigger! But is there in addition a systematic effect of
species?

>>> data = pandas.read\_csv('examples/iris.csv')
>>> model = ols('sepal\_width ~ name + petal\_length', data).fit()
>>> print(model.summary())

OLS Regression Results

==========================...
Dep. Variable:
Model:
Method:
Date:
Time:
No. Observations:
Df Residuals:
Df Model:
==========================...
coef

...

sepal\_width
OLS
Least Squares

...

150
146
3

R-squared:
Adj. R-squared:
F-statistic:
Prob (F-statistic):
Log-Likelihood:
AIC:
BIC:

0.478
0.468
44.63
1.58e-20
-38.185
84.37
96.41

std err

t

P>|t|

[95.0% Conf. Int.]

------------------------------------------...
2.9813
Intercept
-1.4821
name[T.versicolor]
-1.6635
name[T.virginica]
petal\_length
0.2983
==========================...
Omnibus:
Prob(Omnibus):
Skew:
Kurtosis:
==========================...

2.868
0.238
-0.082
3.659

0.099
0.181
0.256
0.061

29.989
-8.190
-6.502
4.920

0.000
0.000
0.000
0.000

2.785
-1.840
-2.169
0.178

3.178
-1.124
-1.158
0.418

Durbin-Watson:
Jarque-Bera (JB):
Prob(JB):
Cond. No.

1.753
2.885
0.236
54.0

15.3. Linear models, multiple factors, and analysis of variance

296

Scipy lecture notes, Edition 2015.2

15.3.3 Post-hoc hypothesis testing: analysis of variance (ANOVA)

In the above iris example, we wish to test if the petal length is different between versicolor and virginica, after
removing the effect of sepal width. This can be formulated as testing the difference between the coefﬁcient as-
sociated to versicolor and virginica in the linear model estimated above (it is an Analysis of Variance, ANOVA).
For this, we write a vector of ‘contrast’ on the parameters estimated: we want to test "name[T.versicolor]
- name[T.virginica]", with an F-test:

>>> print(model.f\_test([0, 1, -1, 0]))


Is this difference signiﬁcant?

Exercice

Going back to the brain size + IQ data, test if the VIQ of male and female are different after removing the
effect of brain size, height and weight.

15.4 More visualization: seaborn for statistical exploration

Seaborn combines simple statistical ﬁts with plotting on pandas dataframes.

Let us consider a data giving wages and many other personal information on 500 individuals (Berndt, ER. The
Practice of Econometrics. 1991. NY: Addison-Wesley).

The full code loading and plotting of the wages data is found in corresponding example.

>>> print data
EDUCATION
8
9
12
12

0
1
2
3
...

SOUTH
0
0
0
0

SEX
1
1
0
0

EXPERIENCE
21
42
1
4

UNION
0
0
0
0

WAGE
0.707570
0.694605
0.824126
0.602060

AGE
35
57
19
22

RACE
2
3
3
3

\

15.4.1 Pairplot: scatter matrices

We can easily have an intuition on the interactions between continuous variables using seaborn.pairplot()
to display a scatter matrix:

>>> import seaborn
>>> seaborn.pairplot(data, vars=['WAGE', 'AGE', 'EDUCATION'],
...

kind='reg')

15.4. More visualization: seaborn for statistical exploration

297

Scipy lecture notes, Edition 2015.2

hue:

>>> seaborn.pairplot(data, vars=['WAGE', 'AGE', 'EDUCATION'],
...

kind='reg', hue='SEX')

Categorical variables can be plotted as the

Look and feel and matplotlib settings

Seaborn changes the default of matplotlib ﬁgures to achieve a more “modern”, “excel-like” look. It does
that upon import. You can reset the default using:

>>> from matplotlib import pyplot as plt
>>> plt.rcdefaults()

To switch back to seaborn settings, or understand better styling in seaborn, see the relevent section of
the seaborn documentation.

15.4. More visualization: seaborn for statistical exploration

298

Scipy lecture notes, Edition 2015.2

15.4.2 lmplot: plotting a univariate regression

A regression capturing the relation between one variable and another, eg wage and eduction, can be plotted
using seaborn.lmplot():

>>> seaborn.lmplot(y='WAGE', x='EDUCATION', data=data)

Robust regression

Given that, in the above plot, there seems to be a couple of data points that are outside of the main cloud
to the right, they might be outliers, not representative of the population, but driving the regression.
To compute a regression that is less sentive to outliers, one must use a robust model. This is done in
seaborn using robust=True in the plotting functions, or in statsmodels by replacing the use of the OLS
by a “Robust Linear Model”, statsmodels.formula.api.rlm().

15.5 Testing for interactions

males than females?

Do wages increase more with education for

15.5. Testing for interactions

299

Scipy lecture notes, Edition 2015.2

The plot above is made of two different ﬁts. We need to formulate a single model that tests for a variance of
slope across the to population. This is done via an “interaction”.

>>> result = sm.ols(formula='wage ~ education + gender + education \* gender',
...
>>> print(result.summary())
...

data=data).fit()

t

coef

[95.0% Conf. Int.]
std err
------------------------------------------------------------------------------
0.072
Intercept
0.093
gender[T.male]
0.005
education
education:gender[T.male]
0.007
==========================...
...

0.2998
0.2750
0.0415
-0.0134

0.159
0.093
0.031
-0.027

4.173
2.972
7.647
-1.919

0.000
0.003
0.000
0.056

0.441
0.457
0.052
0.000

P>|t|

Can we conclude that education beneﬁts males more than females?

Take home messages

• Hypothesis testing and p-value give you the signiﬁcance of an effect / difference
• Formulas (with categorical variables) enable you to express rich links in your data
• Visualizing your data and simple model ﬁts matters!
• Conditionning (adding factors that can explain all or part of the variation) is important modeling

aspect that changes the interpretation.

15.5. Testing for interactions

300

CHAPTER 16

Sympy : Symbolic Mathematics in Python

Author: Fabian Pedregosa

Objectives

1. Evaluate expressions with arbitrary precision.
2. Perform algebraic manipulations on symbolic expressions.
3. Perform basic calculus tasks (limits, differentiation and integration) with symbolic expressions.
4. Solve polynomial and transcendental equations.
5. Solve some differential equations.

What is SymPy? SymPy is a Python library for symbolic mathematics. It aims to be an alternative to systems
such as Mathematica or Maple while keeping the code as simple as possible and easily extensible. SymPy is
written entirely in Python and does not require any external libraries.

Sympy documentation and packages for installation can be found on http://www.sympy.org/

Chapters contents

• First Steps with SymPy

– Using SymPy as a calculator
– Exercises
– Symbols

• Algebraic manipulations

– Expand
– Simplify

• Calculus

– Limits
– Differentiation
– Series expansion
– Integration
– Exercises

• Equation solving

– Exercises
• Linear Algebra
– Matrices
– Differential Equations

301

Scipy lecture notes, Edition 2015.2

16.1 First Steps with SymPy

16.1.1 Using SymPy as a calculator

SymPy deﬁnes three numerical types: Real, Rational and Integer.

The Rational class represents a rational number as a pair of two Integers: the numerator and the denominator,
so Rational(1,2) represents 1/2, Rational(5,2) 5/2 and so on:

>>> from sympy import \*
>>> a = Rational(1,2)

>>> a
1/2

>>> a\*2
1

SymPy uses mpmath in the background, which makes it possible to perform computations using arbitrary-
precision arithmetic. That way, some special constants, like e, pi, oo (Inﬁnity), are treated as symbols and can
be evaluated with arbitrary precision:

>>> pi\*\*2

2

pi

>>> pi.evalf()
3.14159265358979

>>> (pi + exp(1)).evalf()
5.85987448204884

as you see, evalf evaluates the expression to a ﬂoating-point number.
There is also a class representing mathematical inﬁnity, called oo:

>>> oo > 99999
True
>>> oo + 1
oo

16.1.2 Exercises

(cid:112)

1. Calculate

2 with 100 decimals.

2. Calculate 1/2 + 1/3 in rational arithmetic.

16.1.3 Symbols

In contrast to other Computer Algebra Systems, in SymPy you have to declare symbolic variables explicitly:

>>> from sympy import \*
>>> x = Symbol('x')
>>> y = Symbol('y')

Then you can manipulate them:

>>> x + y + x - y
2\*x

>>> (x + y)\*\*2

16.1. First Steps with SymPy

302

Scipy lecture notes, Edition 2015.2

2

(x + y)

Symbols can now be manipulated using some of python operators: +, -, \*, \*\* (arithmetic), &, |, ~ , >>, <<
(boolean).

Printing

Here we use the following setting for printing

>>> sympy.init\_printing(use\_unicode=False, wrap\_line=True)

16.2 Algebraic manipulations

SymPy is capable of performing powerful algebraic manipulations. We’ll take a look into some of the most
frequently used: expand and simplify.

16.2.1 Expand

Use this to expand an algebraic expression. It will try to denest powers and multiplications:

>>> expand((x + y)\*\*3)
3

2

2

3

+ 3\*x \*y + 3\*x\*y

x
>>> 3\*x\*y\*\*2 + 3\*y\*x\*\*2 + x\*\*3 + y\*\*3
2
3

+ y

3

2

x

+ 3\*x \*y + 3\*x\*y

+ y

Further options can be given in form on keywords:

>>> expand(x + y, complex=True)
re(x) + re(y) + I\*im(x) + I\*im(y)
>>> I\*im(x) + I\*im(y) + re(x) + re(y)
re(x) + re(y) + I\*im(x) + I\*im(y)

>>> expand(cos(x + y), trig=True)
-sin(x)\*sin(y) + cos(x)\*cos(y)
>>> cos(x)\*cos(y) - sin(x)\*sin(y)
-sin(x)\*sin(y) + cos(x)\*cos(y)

16.2.2 Simplify

Use simplify if you would like to transform an expression into a simpler form:

>>> simplify((x + x\*y) / x)
y + 1

Simpliﬁcation is a somewhat vague term, and more precises alternatives to simplify exists: powsimp (simpliﬁ-
cation of exponents), trigsimp (for trigonometric expressions) , logcombine, radsimp, together.

Exercises

1. Calculate the expanded form of (x + y)6.
2. Simplify the trigonometric expression sin(x)/ cos(x)

16.2. Algebraic manipulations

303

Scipy lecture notes, Edition 2015.2

16.3 Calculus

16.3.1 Limits

Limits are easy to use in SymPy, they follow the syntax limit(function, variable, point), so to compute the limit
of f (x) as x → 0, you would issue limit(f, x, 0):

>>> limit(sin(x)/x, x, 0)
1

you can also calculate the limit at inﬁnity:

>>> limit(x, x, oo)
oo

>>> limit(1/x, x, oo)
0

>>> limit(x\*\*x, x, 0)
1

16.3.2 Differentiation

You can differentiate any SymPy expression using diff(func, var). Examples:

>>> diff(sin(x), x)
cos(x)
>>> diff(sin(2\*x), x)
2\*cos(2\*x)

>>> diff(tan(x), x)

2

tan (x) + 1

You can check, that it is correct by:

>>> limit((tan(x+y) - tan(x))/y, y, 0)

2

tan (x) + 1

Higher derivatives can be calculated using the diff(func, var, n) method:

>>> diff(sin(2\*x), x, 1)
2\*cos(2\*x)

>>> diff(sin(2\*x), x, 2)
-4\*sin(2\*x)

>>> diff(sin(2\*x), x, 3)
-8\*cos(2\*x)

16.3.3 Series expansion

SymPy also knows how to compute the Taylor series of an expression at a point. Use series(expr, var):

>>> series(cos(x), x)
4

2

x

/ 6\
x
1 - -- + -- + O\x /
24

2

16.3. Calculus

304

>>> series(1/cos(x), x)
4

2

Scipy lecture notes, Edition 2015.2

x

/ 6\
5\*x
1 + -- + ---- + O\x /
24

2

Exercises

1. Calculate limx→0 sin(x)/x
2. Calculate the derivative of l og (x) for x.

16.3.4 Integration

SymPy has support for indeﬁnite and deﬁnite integration of transcendental elementary and special functions
via integrate() facility, which uses powerful extended Risch-Norman algorithm and some heuristics and
pattern matching. You can integrate elementary functions:

>>> integrate(6\*x\*\*5, x)
6

x
>>> integrate(sin(x), x)
-cos(x)
>>> integrate(log(x), x)
x\*log(x) - x
>>> integrate(2\*x + sinh(x), x)
2

x

+ cosh(x)

Also special functions are handled easily:

>>> integrate(exp(-x\*\*2)\*erf(x), x)

\_\_\_\_

2

\/ pi \*erf (x)
--------------
4

It is possible to compute deﬁnite integral:

>>> integrate(x\*\*3, (x, -1, 1))
0
>>> integrate(sin(x), (x, 0, pi/2))
1
>>> integrate(cos(x), (x, -pi/2, pi/2))
2

Also improper integrals are supported as well:

>>> integrate(exp(-x), (x, 0, oo))
1
>>> integrate(exp(-x\*\*2), (x, -oo, oo))

\_\_\_\_

\/ pi

16.3.5 Exercises

16.4 Equation solving

SymPy is able to solve algebraic equations, in one and several variables:

16.4. Equation solving

305

Scipy lecture notes, Edition 2015.2

In [7]: solve(x\*\*4 - 1, x)
Out[7]: [I, 1, -1, -I]

As you can see it takes as ﬁrst argument an expression that is supposed to be equaled to 0. It is able to solve a
large part of polynomial equations, and is also capable of solving multiple equations with respect to multiple
variables giving a tuple as second argument:

In [8]: solve([x + 5\*y - 2, -3\*x + 6\*y - 15], [x, y])
Out[8]: {y: 1, x: -3}

It also has (limited) support for trascendental equations:

In [9]: solve(exp(x) + 1, x)
Out[9]: [pi\*I]

Another alternative in the case of polynomial equations is factor. factor returns the polynomial factorized
into irreducible terms, and is capable of computing the factorization over various domains:

In [10]: f = x\*\*4 - 3\*x\*\*2 + 1
In [11]: factor(f)
Out[11]: (1 + x - x\*\*2)\*(1 - x - x\*\*2)

In [12]: factor(f, modulus=5)
Out[12]: (2 + x)\*\*2\*(2 - x)\*\*2

SymPy is also able to solve boolean equations, that is, to decide if a certain boolean expression is satisﬁable or
not. For this, we use the function satisﬁable:

In [13]: satisfiable(x & y)
Out[13]: {x: True, y: True}

This tells us that (x & y) is True whenever x and y are both True. If an expression cannot be true, i.e. no values
of its arguments can make the expression True, it will return False:

In [14]: satisfiable(x & ~x)
Out[14]: False

16.4.1 Exercises

1. Solve the system of equations x + y = 2, 2 · x + y = 0
2. Are there boolean values x, y that make (~x | y) & (~y | x) true?

16.5 Linear Algebra

16.5.1 Matrices

Matrices are created as instances from the Matrix class:

>>> from sympy import Matrix
>>> Matrix([[1,0], [0,1]])
[1
[
[0

0]
]
1]

unlike a NumPy array, you can also put Symbols in it:

>>> x = Symbol('x')
>>> y = Symbol('y')
>>> A = Matrix([[1,x], [y,1]])

16.5. Linear Algebra

306

Scipy lecture notes, Edition 2015.2

>>> A
x]
[1
]
[
1]
[y

>>> A\*\*2
[x\*y + 1
[
[

2\*y

2\*x

]
]
x\*y + 1]

16.5.2 Differential Equations

SymPy is capable of solving (some) Ordinary Differential. To solve differential equations, use dsolve. First,
create an undeﬁned function by passing cls=Function to the symbols function:

>>> f, g = symbols('f g', cls=Function)

f and g are now undeﬁned functions. We can call f(x), and it will represent an unknown function:

>>> f(x)
f(x)

>>> f(x).diff(x, x) + f(x)

2

d
f(x) + ---(f(x))

2

dx

>>> dsolve(f(x).diff(x, x) + f(x), f(x))
f(x) = C1\*sin(x) + C2\*cos(x)

Keyword arguments can be given to this function in order to help if ﬁnd the best possible resolution system.
For example, if you know that it is a separable equations, you can use keyword hint=’separable’ to force dsolve
to resolve it as a separable equation:

>>> dsolve(sin(x)\*cos(f(x)) + cos(x)\*sin(f(x))\*f(x).diff(x), f(x), hint='separable')

/
|
[f(x) = - asin|
|
\\/

/

/

/

C1

\_\_\_\_\_\_\_\_\_\_\_\_\_\
|

/
|
------- + 1 | + pi, f(x) = asin|
|
\\/

2
cos (x)

|
/

\_\_\_\_\_\_\_\_\_\_\_\_\_\
|

C1

/

/

------- + 1 | + pi,

/

2
cos (x)

|
/

C1

\_\_\_\_\_\_\_\_\_\_\_\_\_\
|

/
|
------- + 1 |, f(x) = asin|
|
\\/

2
cos (x)

|
/

/
|
f(x) = -asin|
|
\\/

/

/

/

Exercises

\_\_\_\_\_\_\_\_\_\_\_\_\_\
|

C1

/

/

------- + 1 |]

/

2
cos (x)

|
/

1. Solve the Bernoulli differential equation

2. Solve the same equation using hint=’Bernoulli’. What do you observe ?

x

d f (x)
x

+ f (x) − f (x)2 = 0

16.5. Linear Algebra

307

CHAPTER 17

Scikit-image: image processing

Author: Emmanuelle Gouillart

scikit-image is a Python package dedicated to image processing, and using natively NumPy arrays as image
objects. This chapter describes how to use scikit-image on various image processing tasks, and insists on
the link with other scientiﬁc Python modules such as NumPy and SciPy.

See also:

For basic image manipulation, such as image cropping or simple ﬁltering, a large number of simple operations
can be realized with NumPy and SciPy only. See Image manipulation and processing using Numpy and Scipy.

Note that you should be familiar with the content of the previous chapter before reading the current one, as
basic operations such as masking and labeling are a prerequisite.

Chapters contents

• Introduction and concepts

– scikit-image and the SciPy ecosystem
– What’s to be found in scikit-image

• Input/output, data types and colorspaces

– Data types
– Colorspaces

• Image preprocessing / enhancement

– Local ﬁlters
– Non-local ﬁlters
– Mathematical morphology

• Image segmentation

– Binary segmentation: foreground + background
– Marker based methods

• Measuring regions’ properties
• Data visualization and interaction
• Feature extraction for computer vision

17.1 Introduction and concepts

Images are NumPy’s arrays np.ndarray

image np.ndarray
pixels array values: a[2, 3]

channels array dimensions
image encoding dtype (np.uint8, np.uint16, np.float)

308

Scipy lecture notes, Edition 2015.2

ﬁlters functions (numpy, skimage, scipy)

>>> import numpy as np
>>> check = np.zeros((9, 9))
>>> check[::2, 1::2] = 1
>>> check[1::2, ::2] = 1
>>> import matplotlib.pyplot as plt
>>> plt.imshow(check, cmap='gray', interpolation='nearest')

17.1.1 scikit-image and the SciPy ecosystem

Recent versions of scikit-image is packaged in most Scientiﬁc Python distributions, such as Anaconda or
Enthought Canopy. It is also packaged for Ubuntu/Debian.

>>> import skimage
>>> from skimage import data # most functions are in subpackages

Most scikit-image functions take NumPy ndarrays as arguments

>>> camera = data.camera()
>>> camera.dtype
dtype('uint8')
>>> camera.shape
(512, 512)
>>> from skimage import restoration
>>> filtered\_camera = restoration.denoise\_bilateral(camera)
>>> type(filtered\_camera)


Other Python packages are available for image processing and work with NumPy arrays:

• scipy.ndimage : for nd-arrays. Basic ﬁltering, mathematical morphology, regions properties

• Mahotas

Also, powerful image processing libraries have Python bindings:

• OpenCV (computer vision)

• ITK (3D images and registration)

17.1.

Introduction and concepts

309

Scipy lecture notes, Edition 2015.2

• and many others

(but they are less Pythonic and NumPy friendly, to a variable extent).

17.1.2 What’s to be found in scikit-image

• Website: http://scikit-image.org/

• Gallery

of

examples

(as

in

matplotlib

or

scikit-learn):

http://scikit-

image.org/docs/stable/auto\_examples/

Different kinds of functions, from boilerplate utility functions to high-level recent algorithms.

• Filters: functions transforming images into other images.

– NumPy machinery

– Common ﬁltering algorithms

• Data reduction functions: computation of image histogram, position of local maxima, of corners, etc.

• Other actions: I/O, visualization, etc.

17.2 Input/output, data types and colorspaces

I/O: skimage.io

>>> from skimage import io

Reading from ﬁles: skimage.io.imread()

>>> import os
>>> filename = os.path.join(skimage.data\_dir, 'camera.png')
>>> camera = io.imread(filename)

Imaging Library (or any other I/O plugin provided to imread with the plugin keyword argument).

Works with all data formats supported by the Python

Also works with URL image paths:

>>> logo = io.imread('http://scikit-image.org/\_static/img/logo.png')

Saving to ﬁles:

17.2.

Input/output, data types and colorspaces

310

Scipy lecture notes, Edition 2015.2

>>> io.imsave('local\_logo.png', logo)

(imsave also uses an external plugin such as PIL)

17.2.1 Data types

Image ndarrays can be represented either by integers

(signed or unsigned) or ﬂoats.

Careful with overﬂows with integer data types

>>> camera = data.camera()
>>> camera.dtype
dtype('uint8')
>>> camera\_multiply = 3 \* camera

Different integer sizes are possible: 8-, 16- or 32-bytes, signed or unsigned.

(cid:66)

An important (if questionable) skimage convention: ﬂoat images are supposed to lie in [-1, 1] (in order to have
comparable contrast for all ﬂoat images)

>>> from skimage import img\_as\_float
>>> camera\_float = img\_as\_float(camera)
>>> camera.max(), camera\_float.max()
(255, 1.0)

Some image processing routines need to work with ﬂoat arrays, and may hence output an array with a different
type and the data range from the input array

from skimage import filters

>>> try:
...
... except ImportError:
...
>>> camera\_sobel = filters.sobel(camera)
>>> camera\_sobel.max()
0.591502...

from skimage import filter as filters

(cid:66)

In the example above, we use the filters submodule of scikit-image, that has been renamed from filter to
filters between versions 0.10 and 0.11, in order to avoid a collision with Python’s built-in name filter.

Utility functions are provided in skimage to convert both the dtype and the data range, following skimage’s
conventions: util.img\_as\_float, util.img\_as\_ubyte, etc.

See the user guide for more details.

17.2.2 Colorspaces

Color images are of shape (N, M, 3) or (N, M, 4) (when an alpha channel encodes transparency)

>>> lena = data.lena()
>>> lena.shape
(512, 512, 3)

17.2.

Input/output, data types and colorspaces

311

Scipy lecture notes, Edition 2015.2

Routines converting between different colorspaces (RGB, HSV, LAB etc.) are available in skimage.color :
color.rgb2hsv, color.lab2rgb, etc. Check the docstring for the expected dtype (and data range) of input
images.

3D images
Most functions of skimage can take 3D images as input arguments. Check the docstring to know if a
function can be used on 3D images (for example MRI or CT images).

Exercise

Open a color image on your disk as a NumPy array.
Find a skimage function computing the histogram of an image and plot the histogram of
each color channel
Convert the image to grayscale and plot its histogram.

17.3 Image preprocessing / enhancement

Goals: denoising, feature (edges) extraction, ...

17.3.1 Local filters

Local ﬁlters replace the value of pixels by a function of the values of neighboring pixels. The function can be
linear or non-linear.

Neighbourhood: square (choose size), disk, or more complicated structuring element.

Example : horizontal Sobel ﬁlter

>>> text = data.text()
>>> hsobel\_text = filters.hsobel(text)

Uses the following linear kernel for computing horizontal gradients:

1
0
-1

2
0
-2

1
0
-1

17.3.

Image preprocessing / enhancement

312

Scipy lecture notes, Edition 2015.2

17.3.2 Non-local filters

Non-local ﬁlters use a large region of the image (or all the image) to transform the value of one pixel:

>>> from skimage import exposure
>>> camera = data.camera()
>>> camera\_equalized = exposure.equalize\_hist(camera)

Enhances contrast in large almost uniform regions.

17.3.3 Mathematical morphology

See wikipedia for an introduction on mathematical morphology.

Probe an image with a simple shape (a structuring element), and modify this image according to how the
shape locally ﬁts or misses the image.

Default structuring element: 4-connectivity of a pixel

>>> from skimage import morphology
>>> morphology.diamond(1)
array([[0, 1, 0],
[1, 1, 1],
[0, 1, 0]], dtype=uint8)

Erosion = minimum ﬁlter. Replace the value of a pixel by the minimal value covered by the structuring ele-
ment.:

>>> a = np.zeros((7,7), dtype=np.int)
>>> a[1:6, 2:5] = 1
>>> a
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])

17.3.

Image preprocessing / enhancement

313

Scipy lecture notes, Edition 2015.2

>>> morphology.binary\_erosion(a, morphology.diamond(1)).astype(np.uint8)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]], dtype=uint8)

>>> #Erosion removes objects smaller than the structure
>>> morphology.binary\_erosion(a, morphology.diamond(2)).astype(np.uint8)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]], dtype=uint8)

Dilation: maximum ﬁlter:

>>> a = np.zeros((5, 5))
>>> a[2, 2] = 1
>>> a
array([[ 0., 0.,
0.,
0.,
0.,
0.,

[ 0.,
[ 0.,
[ 0.,
[ 0.,

0.,
0.,
1.,
0.,
0.,

0.,
0.,
0.,
0.,
0.,

0.],
0.],
0.],
0.],
0.]])

>>> morphology.binary\_dilation(a, morphology.diamond(1)).astype(np.uint8)
array([[0, 0, 0, 0, 0],
[0, 0, 1, 0, 0],
[0, 1, 1, 1, 0],
[0, 0, 1, 0, 0],
[0, 0, 0, 0, 0]], dtype=uint8)

Opening: erosion + dilation:

>>> a = np.zeros((5,5), dtype=np.int)
>>> a[1:4, 1:4] = 1; a[4, 4] = 1
>>> a
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 1]])

>>> morphology.binary\_opening(a, morphology.diamond(1)).astype(np.uint8)
array([[0, 0, 0, 0, 0],
[0, 0, 1, 0, 0],
[0, 1, 1, 1, 0],
[0, 0, 1, 0, 0],
[0, 0, 0, 0, 0]], dtype=uint8)

Opening removes small objects and smoothes corners.

Grayscale mathematical morphology

Mathematical morphology operations are also available for (non-binary) grayscale images (int or ﬂoat
type). Erosion and dilation correspond to minimum (resp. maximum) ﬁlters.

Higher-level mathematical morphology are available: tophat, skeletonization, etc.

See also:

17.3.

Image preprocessing / enhancement

314

Basic mathematical morphology is also implemented in scipy.ndimage.morphology. The scipy.ndimage
implementation works on arbitrary-dimensional arrays.

Scipy lecture notes, Edition 2015.2

Example of ﬁlters comparison: image denoising

>>> from skimage.morphology import disk
>>> coins = data.coins()
>>> coins\_zoom = coins[10:80, 300:370]
>>> median\_coins = filters.rank.median(coins\_zoom, disk(1))
>>> from skimage import restoration
>>> tv\_coins = restoration.denoise\_tv\_chambolle(coins\_zoom, weight=0.1)
>>> gaussian\_coins = filters.gaussian\_filter(coins, sigma=2)

17.4 Image segmentation

Image segmentation is the attribution of different labels to different regions of the image, for example in order
to extract the pixels of an object of interest.

17.4.1 Binary segmentation: foreground + background

Histogram-based method: Otsu thresholding

The Otsu method is a simple heuristic to ﬁnd a threshold to separate the foreground from the background.

Earlier scikit-image versions
skimage.filters is called skimage.filter in earlier versions of scikit-image

from skimage import data
from skimage import filters
camera = data.camera()
val = filters.threshold\_otsu(camera)
mask = camera < val

17.4.

Image segmentation

315

Scipy lecture notes, Edition 2015.2

Labeling connected components of a discrete image

Once you have separated foreground objects, it is use to separate them from each other. For this, we can assign
a different integer labels to each one.

Synthetic data:

>>> n = 20
>>> l = 256
>>> im = np.zeros((l, l))
>>> points = l \* np.random.random((2, n \*\* 2))
>>> im[(points[0]).astype(np.int), (points[1]).astype(np.int)] = 1
>>> im = filters.gaussian\_filter(im, sigma=l / (4. \* n))
>>> blobs = im > im.mean()

Label all connected components:

>>> from skimage import measure
>>> all\_labels = measure.label(blobs)

Label only foreground connected components:

>>> blobs\_labels = measure.label(blobs, background=0)

See also:
scipy.ndimage.find\_objects() is useful to return slices on object in an image.

17.4.2 Marker based methods

If you have markers inside a set of regions, you can use these to segment the regions.

17.4.

Image segmentation

316

Scipy lecture notes, Edition 2015.2

Watershed segmentation

The Watershed (skimage.morphology.watershed()) is a region-growing approach that ﬁlls “basins” in the
image

>>> from skimage.morphology import watershed
>>> from skimage.feature import peak\_local\_max
>>>
>>> # Generate an initial image with two overlapping circles
>>> x, y = np.indices((80, 80))
>>> x1, y1, x2, y2 = 28, 28, 44, 52
>>> r1, r2 = 16, 20
>>> mask\_circle1 = (x - x1) \*\* 2 + (y - y1) \*\* 2 < r1 \*\* 2
>>> mask\_circle2 = (x - x2) \*\* 2 + (y - y2) \*\* 2 < r2 \*\* 2
>>> image = np.logical\_or(mask\_circle1, mask\_circle2)
>>> # Now we want to separate the two objects in image
>>> # Generate the markers as local maxima of the distance
>>> # to the background
>>> from scipy import ndimage
>>> distance = ndimage.distance\_transform\_edt(image)
>>> local\_maxi = peak\_local\_max(distance, indices=False, footprint=np.ones((3, 3)), labels=image)
>>> markers = morphology.label(local\_maxi)
>>> labels\_ws = watershed(-distance, markers, mask=image)

Random walker segmentation

The random walker algorithm (skimage.segmentation.random\_walker()) is similar to the Watershed, but
with a more “probabilistic” approach. It is based on the idea of the diffusion of labels in the image:

>>> from skimage import segmentation
>>> # Transform markers image so that 0-valued pixels are to
>>> # be labelled, and -1-valued pixels represent background
>>> markers[~image] = -1
>>> labels\_rw = segmentation.random\_walker(image, markers)

Postprocessing label images
skimage provides several utility functions that can be used on label
different discrete values identify different regions).
skimage.segmentation.clear\_border(),
skimage.morphology.remove\_small\_objects(), etc.

images (ie images where
Functions names are often self-explaining:
skimage.segmentation.relabel\_from\_one(),

17.4.

Image segmentation

317

Scipy lecture notes, Edition 2015.2

Exercise

• Load the coins image from the data submodule.
• Separate the coins from the background by testing several segmentation methods: Otsu threshold-

ing, adaptive thresholding, and watershed or random walker segmentation.

• If necessary, use a postprocessing function to improve the coins / background segmentation.

17.5 Measuring regions’ properties

>>> from skimage import measure

Example: compute the size and perimeter of the two segmented regions:

>>> properties = measure.regionprops(labels\_rw)
>>> [prop.area for prop in properties]
[770.0, 1168.0]
>>> [prop.perimeter for prop in properties]
[100.91..., 126.81...]

See also:
for some properties, functions are available as well in scipy.ndimage.measurements with a different API (a
list is returned).

Exercise (continued)

• Use the binary image of the coins and background from the previous exercise.
• Compute an image of labels for the different coins.
• Compute the size and eccentricity of all coins.

17.6 Data visualization and interaction

Meaningful visualizations are useful when testing a given processing pipeline.

Some image processing operations:

>>> coins = data.coins()
>>> mask = coins > filters.threshold\_otsu(coins)
>>> clean\_border = segmentation.clear\_border(mask)

Visualize binary result:

>>> plt.figure()

>>> plt.imshow(clean\_border, cmap='gray')


Visualize contour

>>> plt.figure()

>>> plt.imshow(coins, cmap='gray')

>>> plt.contour(clean\_border, [0.5])


17.5. Measuring regions’ properties

318

Use skimage dedicated utility function:

>>> coins\_edges = segmentation.mark\_boundaries(coins, clean\_border.astype(np.int))

Scipy lecture notes, Edition 2015.2

perimental) scikit-image viewer
skimage.viewer = matplotlib-based canvas for displaying images + experimental Qt-based GUI-toolkit

The (ex-

>>> from skimage import viewer
>>> new\_viewer = viewer.ImageViewer(coins)
>>> new\_viewer.show()

Useful for displaying pixel values.

For more interaction, plugins can be added to the viewer:

>>> new\_viewer = viewer.ImageViewer(coins)
>>> from skimage.viewer.plugins import lineprofile
>>> new\_viewer += lineprofile.LineProfile()
>>> new\_viewer.show()

17.6. Data visualization and interaction

319

Scipy lecture notes, Edition 2015.2

17.7 Feature extraction for computer vision

Geometric or textural descriptor can be extracted from images in order to

• classify parts of the image (e.g. sky vs. buildings)

• match parts of different images (e.g. for object detection)

• and many other applications of Computer Vision

17.7. Feature extraction for computer vision

320

Scipy lecture notes, Edition 2015.2

>>> from skimage import feature

Example: detecting corners using Harris detector

from skimage.feature import corner\_harris, corner\_subpix, corner\_peaks
from skimage.transform import warp, AffineTransform

tform = AffineTransform(scale=(1.3, 1.1), rotation=1, shear=0.7,

translation=(210, 50))

image = warp(data.checkerboard(), tform.inverse, output\_shape=(350, 350))

coords = corner\_peaks(corner\_harris(image), min\_distance=5)
coords\_subpix = corner\_subpix(image, coords, window\_size=13)

ample is taken from the plot\_corner example in scikit-image)

Points of interest such as corners can then be used to match objects in different images, as described in the
plot\_matching example of scikit-image.

(this ex-

17.7. Feature extraction for computer vision

321

CHAPTER 18

Traits: building interactive dialogs

Author: Didrik Pinte

The Traits project allows you to simply add validation, initialization, delegation, notiﬁcation and a graphical
user interface to Python object attributes.

In this tutorial we will explore the Traits toolset and learn how to dramatically reduce the amount of boilerplate
code you write, do rapid GUI application development, and understand the ideas which underly other parts
of the Enthought Tool Suite.
Traits and the Enthought Tool Suite are open source projects licensed under a BSD-style license.

Intended Audience

Intermediate to advanced Python programmers

Requirements

• Either wxPython, PyQt or PySide
• Numpy and Scipy
• Enthought Tool Suite
• All required software can be obtained by installing the EPD Free

Tutorial content

• Introduction
• Example
• What are Traits

– Initialisation
– Validation
– Documentation
– Visualization: opening a dialog
– Deferral
– Notiﬁcation
– Some more advanced traits

322

Scipy lecture notes, Edition 2015.2

18.1 Introduction

The Enthought Tool Suite enable the construction of sophisticated application frameworks for data analysis,
2D plotting and 3D visualization. These powerful, reusable components are released under liberal BSD-style
licenses.

The main packages of the Enthought Tool Suite are:

• Traits - component based approach to build our applications.

• Kiva - 2D primitives supporting path based rendering, afﬁne transforms, alpha blending and more.

• Enable - object based 2D drawing canvas.

• Chaco - plotting toolkit for building complex interactive 2D plots.

• Mayavi - 3D visualization of scientiﬁc data based on VTK.

• Envisage - application plugin framework for building scriptable and extensible applications

In this tutorial, we will focus on Traits.

18.2 Example

Throughout this tutorial, we will use an example based on a water resource management simple case. We will
try to model a dam and reservoir system. The reservoir and the dams do have a set of parameters :

• Name

• Minimal and maximal capacity of the reservoir [hm3]

• Height and length of the dam [m]

• Catchment area [km2]

• Hydraulic head [m]

18.1.

Introduction

323

Scipy lecture notes, Edition 2015.2

• Power of the turbines [MW]

• Minimal and maximal release [m3/s]

• Efﬁciency of the turbines

The reservoir has a known behaviour. One part is related to the energy production based on the water released.
A simple formula for approximating electric power production at a hydroelectric plant is P = ρhr g k, where:

• P is Power in watts,

• ρ is the density of water (~1000 kg/m3),

• h is height in meters,

• r is ﬂow rate in cubic meters per second,

• g is acceleration due to gravity of 9.8 m/s2,

• k is a coefﬁcient of efﬁciency ranging from 0 to 1.

Annual electric energy production depends on the available water supply. In some installations the water ﬂow
rate can vary by a factor of 10:1 over the course of a year.

The second part of the behaviour is the state of the storage that depends on controlled and uncontrolled pa-
rameters :

st or ag et +1 = st or ag et + i n f l ow s − r el ease − spi l l ag e − i r r i g at i on

(cid:66)

The data used in this tutorial are not real and might even not have sense in the reality.

18.3 What are Traits

A trait is a type deﬁnition that can be used for normal Python object attributes, giving the attributes some
additional characteristics:

• Standardization:

– Initialization

– Validation

– Deferral

• Notiﬁcation

• Visualization

• Documentation

A class can freely mix trait-based attributes with normal Python attributes, or can opt to allow the use of only
a ﬁxed or open set of trait attributes within the class. Trait attributes deﬁned by a class are automatically
inherited by any subclass derived from the class.

The common way of creating a traits class is by extending from the HasTraits base class and deﬁning class
traits :

from traits.api import HasTraits, Str, Float

class Reservoir(HasTraits):

name = Str
max\_storage = Float

18.3. What are Traits

324

Scipy lecture notes, Edition 2015.2

(cid:66)

For Traits 3.x users
If using Traits 3.x, you need to adapt the namespace of the traits packages:

• traits.api should be enthought.traits.api
• traitsui.api should be enthought.traits.ui.api

Using a traits class like that is as simple as any other Python class. Note that the trait value are passed using
keyword arguments:

reservoir = Reservoir(name='Lac de Vouglans', max\_storage=605)

18.3.1 Initialisation

All the traits do have a default value that initialise the variables. For example, the basic python types do have
the following trait equivalents:

Trait
Bool
Complex
Float
Int
Long
Str
Unicode

Python Type
Boolean
Complex number
Floating point number
Plain integer
Long integer
String
Unicode

Built-in Default Value
False
0+0j
0.0
0
0L
‘’
u’‘

A number of other predeﬁned trait type do exist : Array, Enum, Range, Event, Dict, List, Color, Set, Expression,
Code, Callable, Type, Tuple, etc.

Custom default values can be deﬁned in the code:

from traits.api import HasTraits, Str, Float

class Reservoir(HasTraits):

name = Str
max\_storage = Float(100)

reservoir = Reservoir(name='Lac de Vouglans')

Complex initialisation

When a complex initialisation is required for a trait, a \_XXX\_default magic method can be implemented.
It will be lazily called when trying to access the XXX trait. For example:

def \_name\_default(self):

""" Complex initialisation of the reservoir name. """

return 'Undefined'

18.3.2 Validation

Every trait does validation when the user tries to set its content:

reservoir = Reservoir(name='Lac de Vouglans', max\_storage=605)

reservoir.max\_storage = '230'
---------------------------------------------------------------------------
TraitError
Traceback (most recent call last)
.../scipy-lecture-notes/advanced/traits/ in ()
----> 1 reservoir.max\_storage = '230'

18.3. What are Traits

325

Scipy lecture notes, Edition 2015.2

.../traits/trait\_handlers.pyc in error(self, object, name, value)

166
167
--> 168
169
170

"""
raise TraitError( object, name, self.full\_info( object, name, value ),

value )

def arg\_error ( self, method, arg\_num, object, name, value ):

TraitError: The 'max\_storage' trait of a Reservoir instance must be a float, but a value of '23'  was specified.

18.3.3 Documentation

By essence, all the traits do provide documentation about the model itself. The declarative approach to the
creation of classes makes it self-descriptive:

from traits.api import HasTraits, Str, Float

class Reservoir(HasTraits):

name = Str
max\_storage = Float(100)

The desc metadata of the traits can be used to provide a more descriptive information about the trait :

from traits.api import HasTraits, Str, Float

class Reservoir(HasTraits):

name = Str
max\_storage = Float(100, desc='Maximal storage [hm3]')

Let’s now deﬁne the complete reservoir class:

from traits.api import HasTraits, Str, Float, Range

class Reservoir(HasTraits):

name = Str
max\_storage = Float(1e6, desc='Maximal storage [hm3]')
max\_release = Float(10, desc='Maximal release [m3/s]')
head = Float(10, desc='Hydraulic head [m]')
efficiency = Range(0, 1.)

def energy\_production(self, release):

''' Returns the energy production [Wh] for the given release [m3/s]
'''
power = 1000 \* 9.81 \* self.head \* release \* self.efficiency
return power \* 3600

if \_\_name\_\_ == '\_\_main\_\_':
reservoir = Reservoir(

name = 'Project A',
max\_storage = 30,
max\_release = 100.0,
head = 60,
efficiency = 0.8

)

release = 80
print 'Releasing {} m3/s produces {} kWh'.format(

release, reservoir.energy\_production(release)

)

18.3. What are Traits

326

Scipy lecture notes, Edition 2015.2

18.3.4 Visualization: opening a dialog

The Traits library is also aware of user interfaces and can pop up a default view for the Reservoir class:

reservoir1 = Reservoir()
reservoir1.edit\_traits()

TraitsUI simpliﬁes the way user interfaces are created. Every trait on a HasTraits class has a default editor that
will manage the way the trait is rendered to the screen (e.g. the Range trait is displayed as a slider, etc.).

In the very same vein as the Traits declarative way of creating classes, TraitsUI provides a declarative interface
to build user interfaces code:

from traits.api import HasTraits, Str, Float, Range
from traitsui.api import View

class Reservoir(HasTraits):

name = Str
max\_storage = Float(1e6, desc='Maximal storage [hm3]')
max\_release = Float(10, desc='Maximal release [m3/s]')
head = Float(10, desc='Hydraulic head [m]')
efficiency = Range(0, 1.)

traits\_view = View(

'name', 'max\_storage', 'max\_release', 'head', 'efficiency',
title = 'Reservoir',
resizable = True,

)

def energy\_production(self, release):

''' Returns the energy production [Wh] for the given release [m3/s]
'''
power = 1000 \* 9.81 \* self.head \* release \* self.efficiency
return power \* 3600

if \_\_name\_\_ == '\_\_main\_\_':
reservoir = Reservoir(

name = 'Project A',
max\_storage = 30,
max\_release = 100.0,
head = 60,
efficiency = 0.8

)

18.3. What are Traits

327

reservoir.configure\_traits()

Scipy lecture notes, Edition 2015.2

18.3.5 Deferral

Being able to defer the deﬁnition of a trait and its value to another object is a powerful feature of Traits.

from traits.api import HasTraits, Instance, DelegatesTo, Float, Range

from reservoir import Reservoir

class ReservoirState(HasTraits):

"""Keeps track of the reservoir state given the initial storage.
"""
reservoir = Instance(Reservoir, ())
min\_storage = Float
max\_storage = DelegatesTo('reservoir')
min\_release = Float
max\_release = DelegatesTo('reservoir')

# state attributes
storage = Range(low='min\_storage', high='max\_storage')

# control attributes
inflows =
release = Range(low='min\_release', high='max\_release')
spillage = Float(desc='Spillage [hm3]')

Float(desc='Inflows [hm3]')

def print\_state(self):

print 'Storage\tRelease\tInflows\tSpillage'
str\_format = '\t'.join(['{:7.2f}'for i in range(4)])
print str\_format.format(self.storage, self.release, self.inflows,

self.spillage)

print '-' \* 79

if \_\_name\_\_ == '\_\_main\_\_':
projectA = Reservoir(

name = 'Project A',
max\_storage = 30,
max\_release = 100.0,
hydraulic\_head = 60,
efficiency = 0.8

)

state = ReservoirState(reservoir=projectA, storage=10)
state.release = 90
state.inflows = 0
state.print\_state()

18.3. What are Traits

328

Scipy lecture notes, Edition 2015.2

print 'How do we update the current storage ?'

A special trait allows to manage events and trigger function calls using the magic \_xxxx\_ﬁred method:

from traits.api import HasTraits, Instance, DelegatesTo, Float, Range, Event

from reservoir import Reservoir

class ReservoirState(HasTraits):

"""Keeps track of the reservoir state given the initial storage.

For the simplicity of the example, the release is considered in
hm3/timestep and not in m3/s.
"""
reservoir = Instance(Reservoir, ())
min\_storage = Float
max\_storage = DelegatesTo('reservoir')
min\_release = Float
max\_release = DelegatesTo('reservoir')

# state attributes
storage = Range(low='min\_storage', high='max\_storage')

# control attributes
inflows =
release = Range(low='min\_release', high='max\_release')
spillage = Float(desc='Spillage [hm3]')

Float(desc='Inflows [hm3]')

update\_storage = Event(desc='Updates the storage to the next time step')

def \_update\_storage\_fired(self):
# update storage state
new\_storage = self.storage - self.release
self.storage = min(new\_storage, self.max\_storage)
overflow = new\_storage - self.max\_storage
self.spillage = max(overflow, 0)

+ self.inflows

def print\_state(self):

print 'Storage\tRelease\tInflows\tSpillage'
str\_format = '\t'.join(['{:7.2f}'for i in range(4)])
print str\_format.format(self.storage, self.release, self.inflows,

self.spillage)

print '-' \* 79

if \_\_name\_\_ == '\_\_main\_\_':
projectA = Reservoir(

name = 'Project A',
max\_storage = 30,
max\_release = 5.0,
hydraulic\_head = 60,
efficiency = 0.8

)

state = ReservoirState(reservoir=projectA, storage=15)
state.release = 5
state.inflows = 0

# release the maximum amount of water during 3 time steps
state.update\_storage = True
state.print\_state()
state.update\_storage = True
state.print\_state()

18.3. What are Traits

329

Scipy lecture notes, Edition 2015.2

state.update\_storage = True
state.print\_state()

Dependency between objects can be made automatic using the trait Property. The depends\_on attribute
expresses the dependency between the property and other traits. When the other traits gets changed, the
property is invalidated. Again, Traits uses magic method names for the property :

• \_get\_XXX for the getter of the XXX Property trait

• \_set\_XXX for the setter of the XXX Property trait

from traits.api import HasTraits, Instance, DelegatesTo, Float, Range
from traits.api import Property

from reservoir import Reservoir

class ReservoirState(HasTraits):

"""Keeps track of the reservoir state given the initial storage.

For the simplicity of the example, the release is considered in
hm3/timestep and not in m3/s.
"""
reservoir = Instance(Reservoir, ())
max\_storage = DelegatesTo('reservoir')
min\_release = Float
max\_release = DelegatesTo('reservoir')

# state attributes
storage = Property(depends\_on='inflows, release')

# control attributes
inflows =
release = Range(low='min\_release', high='max\_release')
spillage = Property(

Float(desc='Inflows [hm3]')

desc='Spillage [hm3]', depends\_on=['storage', 'inflows', 'release']

)

### Private traits.
\_storage = Float

### Traits property implementation.
def \_get\_storage(self):

new\_storage = self.\_storage - self.release + self.inflows
return min(new\_storage, self.max\_storage)

def \_set\_storage(self, storage\_value):
self.\_storage = storage\_value

def \_get\_spillage(self):

new\_storage = self.\_storage - self.release
overflow = new\_storage - self.max\_storage
return max(overflow, 0)

+ self.inflows

def print\_state(self):

print 'Storage\tRelease\tInflows\tSpillage'
str\_format = '\t'.join(['{:7.2f}'for i in range(4)])
print str\_format.format(self.storage, self.release, self.inflows,

self.spillage)

print '-' \* 79

if \_\_name\_\_ == '\_\_main\_\_':
projectA = Reservoir(

name = 'Project A',
max\_storage = 30,

18.3. What are Traits

330

Scipy lecture notes, Edition 2015.2

max\_release = 5,
hydraulic\_head = 60,
efficiency = 0.8

)

state = ReservoirState(reservoir=projectA, storage=25)
state.release = 4
state.inflows = 0

state.print\_state()

Caching property
Heavy computation or long running computation might be a problem when accessing a property where the
inputs have not changed. The @cached\_property decorator can be used to cache the value and only recompute
them once invalidated.

Let’s extend the TraitsUI introduction with the ReservoirState example:

from traits.api import HasTraits, Instance, DelegatesTo, Float, Range, Property
from traitsui.api import View, Item, Group, VGroup

from reservoir import Reservoir

class ReservoirState(HasTraits):

"""Keeps track of the reservoir state given the initial storage.

For the simplicity of the example, the release is considered in
hm3/timestep and not in m3/s.
"""
reservoir = Instance(Reservoir, ())
name = DelegatesTo('reservoir')
max\_storage = DelegatesTo('reservoir')
max\_release = DelegatesTo('reservoir')
min\_release = Float

# state attributes
storage = Property(depends\_on='inflows, release')

# control attributes
inflows =
release = Range(low='min\_release', high='max\_release')
spillage = Property(

Float(desc='Inflows [hm3]')

desc='Spillage [hm3]', depends\_on=['storage', 'inflows', 'release']

)

### Traits view
traits\_view = View(

Group(

VGroup(Item('name'), Item('storage'), Item('spillage'),

label = 'State', style = 'readonly'

),
VGroup(Item('inflows'), Item('release'), label='Control'),

)

)

### Private traits.
\_storage = Float

### Traits property implementation.
def \_get\_storage(self):

new\_storage = self.\_storage - self.release + self.inflows
return min(new\_storage, self.max\_storage)

18.3. What are Traits

331

Scipy lecture notes, Edition 2015.2

def \_set\_storage(self, storage\_value):
self.\_storage = storage\_value

def \_get\_spillage(self):

new\_storage = self.\_storage - self.release
overflow = new\_storage - self.max\_storage
return max(overflow, 0)

+ self.inflows

def print\_state(self):

print 'Storage\tRelease\tInflows\tSpillage'
str\_format = '\t'.join(['{:7.2f}'for i in range(4)])
print str\_format.format(self.storage, self.release, self.inflows,

self.spillage)

print '-' \* 79

if \_\_name\_\_ == '\_\_main\_\_':
projectA = Reservoir(

name = 'Project A',
max\_storage = 30,
max\_release = 5,
hydraulic\_head = 60,
efficiency = 0.8

)

state = ReservoirState(reservoir=projectA, storage=25)
state.release = 4
state.inflows = 0

state.print\_state()
state.configure\_traits()

Some use cases need the delegation mechanism to be broken by the user when setting the value of the trait.
The PrototypeFrom trait implements this behaviour.

from traits.api import HasTraits, Str, Float, Range, PrototypedFrom, Instance

class Turbine(HasTraits):
turbine\_type = Str
power = Float(1.0, desc='Maximal power delivered by the turbine [Mw]')

class Reservoir(HasTraits):

name = Str
max\_storage = Float(1e6, desc='Maximal storage [hm3]')

18.3. What are Traits

332

Scipy lecture notes, Edition 2015.2

max\_release = Float(10, desc='Maximal release [m3/s]')
head = Float(10, desc='Hydraulic head [m]')
efficiency = Range(0, 1.)

turbine = Instance(Turbine)
installed\_capacity = PrototypedFrom('turbine', 'power')

if \_\_name\_\_ == '\_\_main\_\_':

turbine = Turbine(turbine\_type='type1', power=5.0)

reservoir = Reservoir(

name = 'Project A',
max\_storage = 30,
max\_release = 100.0,
head = 60,
efficiency = 0.8,
turbine = turbine,

)

print 'installed capacity is initialised with turbine.power'
print reservoir.installed\_capacity

print '-' \* 15
print 'updating the turbine power updates the installed capacity'
turbine.power = 10
print reservoir.installed\_capacity

print '-' \* 15
print 'setting the installed capacity breaks the link between turbine.power'
print 'and the installed\_capacity trait'

reservoir.installed\_capacity = 8
print turbine.power, reservoir.installed\_capacity

18.3.6 Notification

Traits implements a Listener pattern. For each trait a list of static and dynamic listeners can be fed with call-
backs. When the trait does change, all the listeners are called.

Static listeners are deﬁned using the \_XXX\_changed magic methods:

from traits.api import HasTraits, Instance, DelegatesTo, Float, Range

from reservoir import Reservoir

class ReservoirState(HasTraits):

"""Keeps track of the reservoir state given the initial storage.
"""
reservoir = Instance(Reservoir, ())
min\_storage = Float
max\_storage = DelegatesTo('reservoir')
min\_release = Float
max\_release = DelegatesTo('reservoir')

# state attributes
storage = Range(low='min\_storage', high='max\_storage')

# control attributes
inflows =
release = Range(low='min\_release', high='max\_release')
spillage = Float(desc='Spillage [hm3]')

Float(desc='Inflows [hm3]')

18.3. What are Traits

333

Scipy lecture notes, Edition 2015.2

def print\_state(self):

print 'Storage\tRelease\tInflows\tSpillage'
str\_format = '\t'.join(['{:7.2f}'for i in range(4)])
print str\_format.format(self.storage, self.release, self.inflows,

self.spillage)

print '-' \* 79

### Traits listeners ###########
def \_release\_changed(self, new):

"""When the release is higher than zero, warn all the inhabitants of
the valley.
"""

if new > 0:

print 'Warning, we are releasing {} hm3 of water'.format(new)

if \_\_name\_\_ == '\_\_main\_\_':
projectA = Reservoir(

name = 'Project A',
max\_storage = 30,
max\_release = 100.0,
hydraulic\_head = 60,
efficiency = 0.8

)

state = ReservoirState(reservoir=projectA, storage=10)
state.release = 90
state.inflows = 0
state.print\_state()

The static trait notiﬁcation signatures can be:

• def \_release\_changed(self ): pass

• def \_release\_changed(self, new): pass

• def \_release\_changed(self, old, new): pass

• def \_release\_changed(self, name, old, new pass

Listening to all the changes

To listen to all the changes on a HasTraits class, the magic \_any\_trait\_changed method can be imple-
mented.

In many situations, you do not know in advance what type of listeners need to be activated. Traits offers the
ability to register listeners on the ﬂy with the dynamic listeners

from reservoir import Reservoir
from reservoir\_state\_property import ReservoirState

def wake\_up\_watchman\_if\_spillage(new\_value):

if new\_value > 0:

print 'Wake up watchman! Spilling {} hm3'.format(new\_value)

if \_\_name\_\_ == '\_\_main\_\_':
projectA = Reservoir(

name = 'Project A',
max\_storage = 30,
max\_release = 100.0,
hydraulic\_head = 60,
efficiency = 0.8

18.3. What are Traits

334

Scipy lecture notes, Edition 2015.2

)

state = ReservoirState(reservoir=projectA, storage=10)

#register the dynamic listener
state.on\_trait\_change(wake\_up\_watchman\_if\_spillage, name='spillage')

state.release = 90
state.inflows = 0
state.print\_state()

print 'Forcing spillage'
state.inflows = 100
state.release = 0

print 'Why do we have two executions of the callback ?'

The dynamic trait notiﬁcation signatures are not the same as the static ones :

• def wake\_up\_watchman(): pass

• def wake\_up\_watchman(new): pass

• def wake\_up\_watchman(name, new): pass

• def wake\_up\_watchman(object, name, new): pass

• def wake\_up\_watchman(object, name, old, new): pass

Removing a dynamic listener can be done by:

• calling the remove\_trait\_listener method on the trait with the listener method as argument,

• calling the on\_trait\_change method with listener method and the keyword remove=True,

• deleting the instance that holds the listener.

Listeners can also be added to classes using the on\_trait\_change decorator:

from traits.api import HasTraits, Instance, DelegatesTo, Float, Range
from traits.api import Property, on\_trait\_change

from reservoir import Reservoir

class ReservoirState(HasTraits):

"""Keeps track of the reservoir state given the initial storage.

For the simplicity of the example, the release is considered in
hm3/timestep and not in m3/s.
"""
reservoir = Instance(Reservoir, ())
max\_storage = DelegatesTo('reservoir')
min\_release = Float
max\_release = DelegatesTo('reservoir')

# state attributes
storage = Property(depends\_on='inflows, release')

# control attributes
inflows =
release = Range(low='min\_release', high='max\_release')
spillage = Property(

Float(desc='Inflows [hm3]')

desc='Spillage [hm3]', depends\_on=['storage', 'inflows', 'release']

)

### Private traits. ##########

18.3. What are Traits

335

Scipy lecture notes, Edition 2015.2

\_storage = Float

### Traits property implementation.
def \_get\_storage(self):

new\_storage = self.\_storage - self.release + self.inflows
return min(new\_storage, self.max\_storage)

def \_set\_storage(self, storage\_value):
self.\_storage = storage\_value

def \_get\_spillage(self):

new\_storage = self.\_storage - self.release
overflow = new\_storage - self.max\_storage
return max(overflow, 0)

+ self.inflows

@on\_trait\_change('storage')
def print\_state(self):

print 'Storage\tRelease\tInflows\tSpillage'
str\_format = '\t'.join(['{:7.2f}'for i in range(4)])
print str\_format.format(self.storage, self.release, self.inflows,

self.spillage)

print '-' \* 79

if \_\_name\_\_ == '\_\_main\_\_':
projectA = Reservoir(

name = 'Project A',
max\_storage = 30,
max\_release = 5,
hydraulic\_head = 60,
efficiency = 0.8

)

state = ReservoirState(reservoir=projectA, storage=25)
state.release = 4
state.inflows = 0

The patterns supported by the on\_trait\_change method and decorator are powerful. The reader should look at
the docstring of HasTraits.on\_trait\_change for the details.

18.3.7 Some more advanced traits

The following example demonstrate the usage of the Enum and List traits :

from traits.api import HasTraits, Str, Float, Range, Enum, List
from traitsui.api import View, Item

class IrrigationArea(HasTraits):

name = Str
surface = Float(desc='Surface [ha]')
crop = Enum('Alfalfa', 'Wheat', 'Cotton')

class Reservoir(HasTraits):

name = Str
max\_storage = Float(1e6, desc='Maximal storage [hm3]')
max\_release = Float(10, desc='Maximal release [m3/s]')
head = Float(10, desc='Hydraulic head [m]')
efficiency = Range(0, 1.)
irrigated\_areas = List(IrrigationArea)

def energy\_production(self, release):

''' Returns the energy production [Wh] for the given release [m3/s]

18.3. What are Traits

336

Scipy lecture notes, Edition 2015.2

'''
power = 1000 \* 9.81 \* self.head \* release \* self.efficiency
return power \* 3600

traits\_view = View(

Item('name'),
Item('max\_storage'),
Item('max\_release'),
Item('head'),
Item('efficiency'),
Item('irrigated\_areas'),
resizable = True

)

if \_\_name\_\_ == '\_\_main\_\_':

upper\_block = IrrigationArea(name='Section C', surface=2000, crop='Wheat')

reservoir = Reservoir(

name='Project A',
max\_storage=30,
max\_release=100.0,
head=60,
efficiency=0.8,
irrigated\_areas=[upper\_block]

)

release = 80
print 'Releasing {} m3/s produces {} kWh'.format(
release, reservoir.energy\_production(release)

)

Trait listeners can be used to listen to changes in the content of the list to e.g. keep track of the total crop
surface on linked to a given reservoir.

from traits.api import HasTraits, Str, Float, Range, Enum, List, Property
from traitsui.api import View, Item

class IrrigationArea(HasTraits):

name = Str
surface = Float(desc='Surface [ha]')
crop = Enum('Alfalfa', 'Wheat', 'Cotton')

class Reservoir(HasTraits):

name = Str
max\_storage = Float(1e6, desc='Maximal storage [hm3]')
max\_release = Float(10, desc='Maximal release [m3/s]')
head = Float(10, desc='Hydraulic head [m]')
efficiency = Range(0, 1.)

irrigated\_areas = List(IrrigationArea)

total\_crop\_surface = Property(depends\_on='irrigated\_areas.surface')

def \_get\_total\_crop\_surface(self):

return sum([iarea.surface for iarea in self.irrigated\_areas])

def energy\_production(self, release):

''' Returns the energy production [Wh] for the given release [m3/s]
'''
power = 1000 \* 9.81 \* self.head \* release \* self.efficiency
return power \* 3600

18.3. What are Traits

337

Scipy lecture notes, Edition 2015.2

traits\_view = View(

Item('name'),
Item('max\_storage'),
Item('max\_release'),
Item('head'),
Item('efficiency'),
Item('irrigated\_areas'),
Item('total\_crop\_surface'),
resizable = True

)

if \_\_name\_\_ == '\_\_main\_\_':

upper\_block = IrrigationArea(name='Section C', surface=2000, crop='Wheat')

reservoir = Reservoir(

name='Project A',
max\_storage=30,
max\_release=100.0,
head=60,
efficiency=0.8,
irrigated\_areas=[upper\_block],

)

release = 80
print 'Releasing {} m3/s produces {} kWh'.format(
release, reservoir.energy\_production(release)

)

The next example shows how the Array trait can be used to feed a specialised TraitsUI Item, the ChacoPlotItem:

import numpy as np

from traits.api import HasTraits, Array, Instance, Float, Property
from traits.api import DelegatesTo
from traitsui.api import View, Item, Group
from chaco.chaco\_plot\_editor import ChacoPlotItem

from reservoir import Reservoir

class ReservoirEvolution(HasTraits):
reservoir = Instance(Reservoir)

name = DelegatesTo('reservoir')

inflows = Array(dtype=np.float64, shape=(None))
releass = Array(dtype=np.float64, shape=(None))

initial\_stock = Float
stock = Property(depends\_on='inflows, releases, initial\_stock')

month = Property(depends\_on='stock')

### Traits view ###########
traits\_view = View(

Item('name'),
Group(

ChacoPlotItem('month', 'stock', show\_label=False),

),
width = 500,
resizable = True

)

18.3. What are Traits

338

Scipy lecture notes, Edition 2015.2

### Traits properties #####
def \_get\_stock(self):

"""
fixme: should handle cases where we go over the max storage
"""
return self.initial\_stock + (self.inflows - self.releases).cumsum()

def \_get\_month(self):

return np.arange(self.stock.size)

if \_\_name\_\_ == '\_\_main\_\_':
reservoir = Reservoir(

name = 'Project A',
max\_storage = 30,
max\_release = 100.0,
head = 60,
efficiency = 0.8

)

initial\_stock = 10.
inflows\_ts = np.array([6., 6, 4, 4, 1, 2, 0, 0, 3, 1, 5, 3])
releases\_ts = np.array([4., 5, 3, 5, 3, 5, 5, 3, 2, 1, 3, 3])

view = ReservoirEvolution(

view.configure\_traits()

)

reservoir = reservoir,
inflows = inflows\_ts,
releases = releases\_ts

See also:

References

• ETS repositories

• Traits manual

• Traits UI manual

• Mailing list : enthought-dev@enthought.com

18.3. What are Traits

339

CHAPTER 19

3D plotting with Mayavi

Author: Gaël Varoquaux

Mayavi is an interactive 3D plotting package. matplotlib can also do simple 3D plotting, but Mayavi relies on a
more powerful engine ( VTK ) and is more suited to displaying large or complex data.

Chapters contents

• Mlab: the scripting interface

– 3D plotting functions

\* Points
\* Lines
\* Elevation surface
\* Arbitrary regular mesh
\* Volumetric data
– Figures and decorations
\* Figure management
\* Changing plot properties
\* Decorations

• Interactive work

– The “pipeline dialog”
– The script recording button

• Slicing and dicing data: sources, modules and ﬁlters
– An example: inspecting magnetic ﬁelds
– Different views on data: sources and modules
\* Different sources: scatters and ﬁelds
\* Transforming data: ﬁlters
\* mlab.pipeline: the scripting layer

• Animating the data
• Making interactive dialogs
– A simple dialog
– Making it interactive

• Putting it together

19.1 Mlab: the scripting interface

The mayavi.mlab module provides simple plotting functions to apply to numpy arrays, similar to matplotlib
or matlab’s plotting interface. Try using them in IPython, by starting IPython with the switch --gui=wx.

340

Scipy lecture notes, Edition 2015.2

19.1.1 3D plotting functions

Points

Points in 3D, represented with markers (or “glyphs”) and optionaly different sizes.

x, y, z, value = np.random.random((4, 40))
mlab.points3d(x, y, z, value)

Lines

A line connecting points in 3D, with optional thickness and varying color.

mlab.clf() # Clear the figure
t = np.linspace(0, 20, 200)
mlab.plot3d(np.sin(t), np.cos(t), 0.1\*t, t)

Elevation surface

A surface given by its elevation, coded as a 2D array

19.1. Mlab: the scripting interface

341

Scipy lecture notes, Edition 2015.2

mlab.clf()
x, y = np.mgrid[-10:10:100j, -10:10:100j]
r = np.sqrt(x\*\*2 + y\*\*2)
z = np.sin(r)/r
mlab.surf(z, warp\_scale='auto')

Arbitrary regular mesh

A surface mesh given by x, y, z positions of its node points

mlab.clf()
phi, theta = np.mgrid[0:np.pi:11j, 0:2\*np.pi:11j]
x = np.sin(phi) \* np.cos(theta)
y = np.sin(phi) \* np.sin(theta)
z = np.cos(phi)
mlab.mesh(x, y, z)
mlab.mesh(x, y, z, representation='wireframe', color=(0, 0, 0))

A surface is deﬁned by points connected to form triangles or polygones.
and mayavi.mlab.mesh(), the connectivity is implicity given by the layout of the arrays.
mayavi.mlab.triangular\_mesh().

In mayavi.mlab.surf()
See also

Our data is often more than points and values: it needs some connectivity information

Volumetric data

If your data is dense in 3D, it is more difﬁcult to display. One option is to take iso-contours of the data.

mlab.clf()
x, y, z = np.mgrid[-5:5:64j, -5:5:64j, -5:5:64j]
values = x\*x\*0.5 + y\*y + z\*z\*2.0
mlab.contour3d(values)

19.1. Mlab: the scripting interface

342

Scipy lecture notes, Edition 2015.2

This function works with a regular orthogonal grid: the value array is a 3D array that gives the shape of the
grid.

19.1.2 Figures and decorations

Figure management

Here is a list of functions useful to control the current ﬁgure

Get the current ﬁgure:
Clear the current ﬁgure:
Set the current ﬁgure:
Save ﬁgure to image ﬁle:
Change the view:

mlab.gcf()
mlab.clf()
mlab.figure(1, bgcolor=(1, 1, 1), fgcolor=(0.5, 0.5, 0.5)
mlab.savefig(’foo.png’, size=(300, 300))

mlab.view(azimuth=45, elevation=54, distance=1.)

Changing plot properties

In general, many properties of the various objects on the ﬁgure can be changed. If these visualization are
created via mlab functions, the easiest way to change them is to use the keyword arguments of these functions,
as described in the docstrings.

19.1. Mlab: the scripting interface

343

Scipy lecture notes, Edition 2015.2

Example docstring: mlab.mesh

Plots a surface using grid-spaced data supplied as 2D arrays.
Function signatures:

mesh(x, y, z, ...)

x, y, z are 2D arrays, all of the same shape, giving the positions of the vertices of the surface. The connec-
tivity between these points is implied by the connectivity on the arrays.
For simple structures (such as orthogonal grids) prefer the surf function, as it will create more efﬁcient
data structures.
Keyword arguments:

color the color of the vtk object. Overides the colormap, if any, when speciﬁed.

This is speciﬁed as a triplet of ﬂoat ranging from 0 to 1, eg (1, 1, 1) for white.

colormap type of colormap to use.
extent [xmin, xmax, ymin, ymax, zmin, zmax] Default is the x, y, z arrays extents.

Use this to change the extent of the object created.

ﬁgure Figure to populate.
line\_width The with of the lines, if any used. Must be a ﬂoat. Default: 2.0
mask boolean mask array to suppress some data points.
mask\_points If supplied, only one out of ‘mask\_points’ data point is displayed.
This option is usefull to reduce the number of points displayed on large
datasets Must be an integer or None.

‘2ddash’ or

mode the mode of the glyphs. Must be ‘2darrow’ or ‘2dcircle’ or ‘2dcross’
or
‘2dsquare’ or
‘2dthick\_arrow’ or ‘2dthick\_cross’ or ‘2dtriangle’ or ‘2dvertex’ or ‘arrow’
or ‘cone’ or ‘cube’ or ‘cylinder’ or ‘point’ or ‘sphere’. Default: sphere

‘2dhooked\_arrow’ or

‘2ddiamond’ or

name the name of the vtk object created.
representation the representation type used for the surface. Must be ‘surface’ or

‘wireframe’ or ‘points’ or ‘mesh’ or ‘fancymesh’. Default: surface

resolution The resolution of the glyph created. For spheres, for instance, this is

the number of divisions along theta and phi. Must be an integer. Default: 8

scalars optional scalar data.
scale\_factor scale factor of the glyphs used to represent the vertices,

in

fancy\_mesh mode. Must be a ﬂoat. Default: 0.05

scale\_mode the scaling mode for the glyphs (‘vector’, ‘scalar’, or ‘none’).
transparent make the opacity of the actor depend on the scalar.
tube\_radius radius of the tubes used to represent the lines, in mesh mode. If

None, simple lines are used.

tube\_sides number of sides of the tubes used to represent the lines. Must be an

integer. Default: 6

vmax vmax is used to scale the colormap If None, the max of the data will be used
vmin vmin is used to scale the colormap If None, the min of the data will be used

19.1. Mlab: the scripting interface

344

Scipy lecture notes, Edition 2015.2

Example:

In [1]: import numpy as np

In [2]: r, theta = np.mgrid[0:10, -np.pi:np.pi:10j]

In [3]: x = r \* np.cos(theta)

In [4]: y = r \* np.sin(theta)

In [5]: z = np.sin(r)/r

In [6]: from mayavi import mlab

In [7]: mlab.mesh(x, y, z, colormap='gist\_earth', extent=[0, 1, 0, 1, 0, 1])
Out[7]: 

In [8]: mlab.mesh(x, y, z, extent=[0, 1, 0, 1, 0, 1],

...: representation='wireframe', line\_width=1, color=(0.5, 0.5, 0.5))

Out[8]: 

Decorations

Different items can be added to the ﬁgure to carry extra information, such as a colorbar or a title.

In [9]: mlab.colorbar(Out[7], orientation='vertical')
Out[9]: 

In [10]: mlab.title('polar mesh')
Out[10]: 

In [11]: mlab.outline(Out[7])
Out[11]: 

In [12]: mlab.axes(Out[7])
Out[12]: 

19.1. Mlab: the scripting interface

345

Scipy lecture notes, Edition 2015.2

(cid:66)

extent: If we speciﬁed extents for a plotting object, mlab.outline’ and ‘mlab.axes don’t get them by de-
fault.

19.2 Interactive work

The quickest way to create beautiful visualization with Mayavi is probably to interactively tweak the various
settings.

19.2.1 The “pipeline dialog”

Click on the ‘Mayavi’ button in the scene, and you can control properties of objects with dialogs.

• Set the background of the ﬁgure in the Mayavi Scene node
• Set the colormap in the Colors and legends node

• Right click on the node to add modules or ﬁlters

19.2.

Interactive work

346

Scipy lecture notes, Edition 2015.2

19.2.2 The script recording button

To ﬁnd out what code can be used to program these changes, click on the red button as you modify those
properties, and it will generate the corresponding lines of code.

19.3 Slicing and dicing data: sources, modules and filters

19.3.1 An example: inspecting magnetic fields

are

simulating

Suppose we
The
examples/compute\_field.py script does this computation and gives you a B array, that is (3 x n),
where the ﬁrst axis is the direction of the ﬁeld (Bx, By, Bz), and the second axis the index number of the point.
Arrays X, Y and Z give the positions of these data points.

by Helmholtz

the magnetic

generated

coils.

ﬁeld

Excercise

Visualize this ﬁeld. Your goal is to make sure that the simulation code is correct.

Suggestions

• If you compute the norm of the vector ﬁeld, you can apply an isosurface to it.
• using mayavi.mlab.quiver3d() you can plot vectors. You can also use the ‘masking’ options (in

the GUI) to make the plot a bit less dense.

19.3.2 Different views on data: sources and modules

As we see above, it may be desirable to look at the same data in different ways.

Mayavi visualization are created by loading the data in a data source and then displayed on the screen using
modules.

19.3. Slicing and dicing data: sources, modules and filters

347

Scipy lecture notes, Edition 2015.2

This can be seen by looking at the “pipeline” view. By right-clicking on the nodes of the pipeline, you can add
new modules.

Quiz
Why is it not possible to add a VectorCutPlane to the vectors created by mayavi.mlab.quiver3d()?

Different sources: scatters and fields

Data comes in different descriptions.

• A 3D block of regularly-spaced value is structured: it is easy to know how one measurement is related to
another neighboring and how to continuously interpolate between these. We can call such data a ﬁeld,
borrowing from terminology used in physics, as it is continuously deﬁned in space.

• A set of data points measured at random positions in a random order gives rise to much more difﬁcult
and ill-posed interpolation problems: the data structure itself does not tell us what are the neighbors of
a data point. We call such data a scatter.

Unstructured and unconnected data: a scatter
mlab.points3d, mlab.quiver3d

Structured and connected data: a ﬁeld
mlab.contour3d

Data sources corresponding to scatters can be created with mayavi.mlab.pipeline.scalar\_scatter()
or
created with
mlab.pipeline.scalar\_field() or mlab.pipeline.vector\_field().

mayavi.mlab.pipeline.vector\_scatter();

sources

ﬁeld

data

can

be

Exercice:

1. Create a contour (for instance of the magnetic ﬁeld norm) by using one of those functions and

adding the right module by clicking on the GUI dialog.

2. Create the right source to apply a ‘vector\_cut\_plane’ and reproduce the picture of the magnetic

ﬁeld shown previously.

Note that one of the difﬁculties is providing the data in the right form (number of arrays, shape) to the
functions. This is often the case with real-life data.

See also:

Sources are described in details in the Mayavi manual.

Transforming data: filters

If you create a vector ﬁeld, you may want to visualize the iso-contours of its magnitude. But the isosurface
module can only be applied to scalar data, and not vector data. We can use a ﬁlter, ExtractVectorNorm to
add this scalar value to the vector ﬁeld.

Filters apply a transformation to data, and can be added between sources and modules

19.3. Slicing and dicing data: sources, modules and filters

348

Scipy lecture notes, Edition 2015.2

Excercice

Using the GUI, add the ExtractVectorNorm ﬁlter to display iso-contours of the ﬁeld magnitude.

mlab.pipeline: the scripting layer

The mlab scripting layer builds pipelines for you. You can reproduce these pipelines programmatically with
the mlab.pipeline interface: each step has a corresponding mlab.pipeline function (simply convert the
name of the step to lower-case underscore-separated: ExtractVectorNorm gives extract\_vector\_norm). This
function takes as an argument the node that it applies to, as well as optional parameters, and returns the new
node.

For example, iso-contours of the magnitude are coded as:

mlab.pipeline.iso\_surface(mlab.pipeline.extract\_vector\_norm(field),

contours=[0.1\*Bmax, 0.4\*Bmax],
opacity=0.5)

Excercice

Using the mlab.pipeline interface, generate a complete visualization, with iso-contours of the ﬁeld mag-
nitude, and a vector cut plane.
(click on the ﬁgure for a solution)

19.4 Animating the data

To make movies, or interactive application, you may want to change the data represented on a given visualiza-
tion.
If you have built a visualization, using the mlab plotting functions, or the mlab.pipeline function, we can
update the data by assigning new values to the mlab\_source attributes

x , y , z = np.ogrid[-5:5:100j ,-5:5:100j, -5:5:100j]
scalars = np.sin(x \* y \* z) / (x \* y \* z)

iso = mlab.contour3d(scalars, transparent=True, contours=[0.5])
for i in range(1, 20):

scalars = np.sin(i \* x \* y \* z) /(x \* y \* z)
iso.mlab\_source.scalars = scalars

19.4. Animating the data

349

Scipy lecture notes, Edition 2015.2

See also:

More details in the Mayavi documentation

Event loops

For the interaction with the user (for instance changing the view with the mouse), Mayavi needs some
time to process these events. The for loop above prevents this. The Mayavi documentation details a
workaround

19.5 Making interactive dialogs

It is very simple to make interactive dialogs with Mayavi using the Traits library (see the dedicated chapter
Traits: building interactive dialogs).

19.5.1 A simple dialog

from traits.api import HasTraits, Instance
from traitsui.api import View, Item, HGroup
from mayavi.core.ui.api import SceneEditor, MlabSceneModel

def curve(n\_turns):

"The function creating the x, y, z coordinates needed to plot"
phi = np.linspace(0, 2\*np.pi, 2000)
return [np.cos(phi) \* (1 + 0.5\*np.cos(n\_turns\*phi)),
np.sin(phi) \* (1 + 0.5\*np.cos(n\_turns\*phi)),
0.5\*np.sin(n\_turns\*phi)]

class Visualization(HasTraits):

"The class that contains the dialog"
scene

= Instance(MlabSceneModel, ())

def \_\_init\_\_(self):

HasTraits.\_\_init\_\_(self)
x, y, z = curve(n\_turns=2)
# Populating our plot
self.plot = self.scene.mlab.plot3d(x, y, z)

# Describe the dialog
view = View(Item('scene', height=300, show\_label=False,
editor=SceneEditor()),

HGroup('n\_turns'), resizable=True)

# Fire up the dialog
Visualization().configure\_traits()

Let us read a bit the code above (examples/mlab\_dialog.py).
First, the curve function is used to compute the coordinate of the curve we want to plot.
Second, the dialog is deﬁned by an object inheriting from HasTraits, as it is done with Traits. The important
point here is that a Mayavi scene is added as a speciﬁc Traits attribute (Instance). This is important for
embedding it in the dialog. The view of this dialog is deﬁned by the view attribute of the object. In the init of
this object, we populate the 3D scene with a curve.
Finally, the configure\_traits method creates the dialog and starts the event loop.

See also:

There are a few things to be aware of when doing dialogs with Mayavi. Please read the Mayavi documentation

19.5. Making interactive dialogs

350

Scipy lecture notes, Edition 2015.2

19.5.2 Making it interactive

We can combine the Traits events handler with the mlab\_source to modify the visualization with the dialog.
We will enable the user to vary the n\_turns parameter in the deﬁnition of the curve. For this, we need:

• to deﬁne an n\_turns attribute on our visualization object, so that it can appear in the dialog. We use a

Range type.

• to wire modiﬁcation of this attribute to a recomputation of the curve.

on\_traits\_change decorator.

For this, we use the

from traits.api import Range, on\_trait\_change

class Visualization(HasTraits):
n\_turns = Range(0, 30, 11)
scene

= Instance(MlabSceneModel, ())

def \_\_init\_\_(self):

HasTraits.\_\_init\_\_(self)
x, y, z = curve(self.n\_turns)
self.plot = self.scene.mlab.plot3d(x, y, z)

@on\_trait\_change('n\_turns')
def update\_plot(self):

x, y, z = curve(self.n\_turns)
self.plot.mlab\_source.set(x=x, y=y, z=z)

view = View(Item('scene', height=300, show\_label=False,
editor=SceneEditor()),

HGroup('n\_turns'), resizable=True)

# Fire up the dialog
Visualization().configure\_traits()

Full code of the example: examples/mlab\_dialog.py.

19.6 Putting it together

19.6. Putting it together

351

Scipy lecture notes, Edition 2015.2

Exercise

Using the code from the magnetic ﬁeld simulation, create a dialog that enable to move the 2 coils: change
their parameters.
Hint: to deﬁne a dialog entry for a vector of dimension 3

direction = Array(float, value=(0, 0, 1), cols=3, shape=(3,))

You can look at the example\_coil\_application.py to see a full-blown application for coil design in 270 lines of
code.

19.6. Putting it together

352

CHAPTER 20

scikit-learn: machine learning in Python

Authors: Fabian Pedregosa, Gael Varoquaux

Prerequisites

• Numpy, Scipy
• IPython
• matplotlib
• scikit-learn (http://scikit-learn.org)

Chapters contents

• Loading an example dataset

– Learning and Predicting

• Classiﬁcation

– k-Nearest neighbors classiﬁer
– Support vector machines (SVMs) for classiﬁcation

• Clustering: grouping observations together

– K-means clustering

• Dimension Reduction with Principal Component Analysis
• Putting it all together: face recognition
• Linear model: from regression to sparsity

– Sparse models

• Model selection: choosing estimators and their parameters

– Grid-search and cross-validated estimators

353

20.1 Loading an example dataset

Scipy lecture notes, Edition 2015.2

First we will load some data to play with. The data we will use is a very simple ﬂower database known as the
Iris dataset.

We have 150 observations of the iris ﬂower specifying some measurements: sepal length, sepal width, petal
length and petal width together with its subtype: Iris setosa, Iris versicolor, Iris virginica.

To load the dataset into a Python object:

>>> from sklearn import datasets
>>> iris = datasets.load\_iris()

This data is stored in the .data member, which is a (n\_samples, n\_features) array.

>>> iris.data.shape
(150, 4)

The class of each observation is stored in the .target attribute of the dataset. This is an integer 1D array of
length n\_samples:

>>> iris.target.shape
(150,)
>>> import numpy as np
>>> np.unique(iris.target)
array([0, 1, 2])

20.1. Loading an example dataset

354

Scipy lecture notes, Edition 2015.2

An example of reshaping data: the digits dataset

The digits dataset consists of 1797 images, where each one is an 8x8 pixel image representing a hand-
written digit

>>> digits = datasets.load\_digits()
>>> digits.images.shape
(1797, 8, 8)
>>> import pylab as pl
>>> pl.imshow(digits.images[0], cmap=pl.cm.gray\_r)


To use this dataset with the scikit, we transform each 8x8 image into a vector of length 64

>>> data = digits.images.reshape((digits.images.shape[0], -1))

20.1.1 Learning and Predicting

Now that we’ve got some data, we would like to learn from it and predict on new one. In scikit-learn, we
learn from existing data by creating an estimator and calling its fit(X, Y) method.

>>> from sklearn import svm
>>> clf = svm.LinearSVC()
>>> clf.fit(iris.data, iris.target) # learn from the data
LinearSVC(...)

Once we have learned from the data, we can use our model to predict the most likely outcome on unseen data:

>>> clf.predict([[ 5.0,
array([0])

3.6,

1.3,

0.25]])

We can access the parameters of the model via its attributes ending with an underscore:

>>> clf.coef\_
array([[ 0...]])

20.2 Classification

20.2.1 k-Nearest neighbors classifier

The simplest possible classiﬁer is the nearest neighbor: given a new observation, take the label of the training
samples closest to it in n-dimensional space, where n is the number of features in each sample.

20.2. Classification

355

Scipy lecture notes, Edition 2015.2

The k-nearest neighbors classiﬁer internally uses an algorithm based on ball trees to represent the samples it
is trained on.

KNN (k-nearest neighbors) classiﬁcation example:

>>> # Create and fit a nearest-neighbor classifier
>>> from sklearn import neighbors
>>> knn = neighbors.KNeighborsClassifier()
>>> knn.fit(iris.data, iris.target)
KNeighborsClassifier(...)
>>> knn.predict([[0.1, 0.2, 0.3, 0.4]])
array([0])

Training set and testing set

When experimenting with learning algorithms, it is important not to test the prediction of an estima-
tor on the data used to ﬁt the estimator. Indeed, with the kNN estimator, we would always get perfect
prediction on the training set.

>>> perm = np.random.permutation(iris.target.size)
>>> iris.data = iris.data[perm]
>>> iris.target = iris.target[perm]
>>> knn.fit(iris.data[:100], iris.target[:100])
KNeighborsClassifier(...)
>>> knn.score(iris.data[100:], iris.target[100:])
0.95999...

Bonus question: why did we use a random permutation?

20.2.2 Support vector machines (SVMs) for classification

Linear Support Vector Machines

SVMs try to construct a hyperplane maximizing the margin between the two classes. It selects a subset of the
input, called the support vectors, which are the observations closest to the separating hyperplane.

20.2. Classification

356

Scipy lecture notes, Edition 2015.2

>>> from sklearn import svm
>>> svc = svm.SVC(kernel='linear')
>>> svc.fit(iris.data, iris.target)
SVC(...)

There are several support vector machine implementations in scikit-learn. The most commonly used ones
are svm.SVC, svm.NuSVC and svm.LinearSVC; “SVC” stands for Support Vector Classiﬁer (there also exist
SVMs for regression, which are called “SVR” in scikit-learn).

Excercise
Train an svm.SVC on the digits dataset. Leave out the last 10% and test prediction performance on these
observations.

Using kernels

Classes are not always separable by a hyperplane, so it would be desirable to have a decision function that is
not linear but that may be for instance polynomial or exponential:

Linear kernel

Polynomial kernel

RBF kernel (Radial Basis Func-
tion)

>>> svc = svm.SVC(kernel='linear')

>>> svc = svm.SVC(kernel='poly',
...
>>> # degree: polynomial degree

degree=3)

>>> svc = svm.SVC(kernel='rbf')
>>> # gamma: inverse of size of
>>> # radial kernel

Exercise

Which of the kernels noted above has a better prediction performance on the digits dataset?

20.3 Clustering: grouping observations together

Given the iris dataset, if we knew that there were 3 types of iris, but did not have access to their labels, we could
try unsupervised learning: we could cluster the observations into several groups by some criterion.

20.3. Clustering: grouping observations together

357

Scipy lecture notes, Edition 2015.2

20.3.1 K-means clustering

The simplest clustering algorithm is k-means. This divides a set into k clusters, assigning each observation to
a cluster so as to minimize the distance of that observation (in n-dimensional space) to the cluster’s mean; the
means are then recomputed. This operation is run iteratively until the clusters converge, for a maximum for
max\_iter rounds.
(An alternative implementation of k-means is available in SciPy’s cluster package. The scikit-learn im-
plementation differs from that by offering an object API and several additional features, including smart ini-
tialization.)

>>> from sklearn import cluster, datasets
>>> iris = datasets.load\_iris()
>>> k\_means = cluster.KMeans(n\_clusters=3)
>>> k\_means.fit(iris.data)
KMeans(...)
>>> print(k\_means.labels\_[::10])
[1 1 1 1 1 0 0 0 0 0 2 2 2 2 2]
>>> print(iris.target[::10])
[0 0 0 0 0 1 1 1 1 1 2 2 2 2 2]

Ground truth

K-means (3 clusters)

K-means (8 clusters)

Application to Image Compression

Clustering can be seen as a way of choosing a small number of observations from the information. For
instance, this can be used to posterize an image (conversion of a continuous gradation of tone to several
regions of fewer tones):

>>> from scipy import misc
>>> lena = misc.lena().astype(np.float32)
>>> X = lena.reshape((-1, 1)) # We need an (n\_sample, n\_feature) array
>>> k\_means = cluster.KMeans(n\_clusters=5)
>>> k\_means.fit(X)
KMeans(...)
>>> values = k\_means.cluster\_centers\_.squeeze()
>>> labels = k\_means.labels\_
>>> lena\_compressed = np.choose(labels, values)
>>> lena\_compressed.shape = lena.shape

Raw image

K-means quantization

20.3. Clustering: grouping observations together

358

20.4 Dimension Reduction with Principal Component Analysis

Scipy lecture notes, Edition 2015.2

The cloud of points spanned by the observations above is very ﬂat in one direction, so that one feature can
almost be exactly computed using the 2 other. PCA ﬁnds the directions in which the data is not ﬂat and it can
reduce the dimensionality of the data by projecting on a subspace.

(cid:66)

Depending on your version of scikit-learn PCA will be in module decomposition or pca.

>>> from sklearn import decomposition
>>> pca = decomposition.PCA(n\_components=2)
>>> pca.fit(iris.data)
PCA(copy=True, n\_components=2, whiten=False)
>>> X = pca.transform(iris.data)

Now we can visualize the (transformed) iris dataset:

>>> import pylab as pl
>>> pl.scatter(X[:, 0], X[:, 1], c=iris.target)


PCA is not just useful for visualization of high dimensional datasets. It can also be used as a preprocessing step
to help speed up supervised methods that are not efﬁcient with high dimensions.

20.4. Dimension Reduction with Principal Component Analysis

359

Scipy lecture notes, Edition 2015.2

20.5 Putting it all together: face recognition

An example showcasing face recognition using Principal Component Analysis for dimension reduction and
Support Vector Machines for classiﬁcation.

Stripped-down version of the face recognition example:

import numpy as np
import pylab as pl
from sklearn import cross\_val, datasets, decomposition, svm

# ..
# .. load data ..
lfw\_people = datasets.fetch\_lfw\_people(min\_faces\_per\_person=70, resize=0.4)
perm = np.random.permutation(lfw\_people.target.size)
lfw\_people.data = lfw\_people.data[perm]
lfw\_people.target = lfw\_people.target[perm]
faces = np.reshape(lfw\_people.data, (lfw\_people.target.shape[0], -1))
train, test = iter(cross\_val.StratifiedKFold(lfw\_people.target, k=4)).next()
X\_train, X\_test = faces[train], faces[test]
y\_train, y\_test = lfw\_people.target[train], lfw\_people.target[test]

# ..
# .. dimension reduction ..
pca = decomposition.RandomizedPCA(n\_components=150, whiten=True)
pca.fit(X\_train)
X\_train\_pca = pca.transform(X\_train)
X\_test\_pca = pca.transform(X\_test)

# ..
# .. classification ..
clf = svm.SVC(C=5., gamma=0.001)
clf.fit(X\_train\_pca, y\_train)

20.5. Putting it all together: face recognition

360

Scipy lecture notes, Edition 2015.2

# ..
# .. predict on new images ..
for i in range(10):

print(lfw\_people.target\_names[clf.predict(X\_test\_pca[i])[0]])
\_ = pl.imshow(X\_test[i].reshape(50, 37), cmap=pl.cm.gray)
\_ = raw\_input()

20.6 Linear model: from regression to sparsity

Diabetes dataset

The diabetes dataset consists of 10 physiological variables (age, sex, weight, blood pressure) measure on
442 patients, and an indication of disease progression after one year:

>>> diabetes = datasets.load\_diabetes()
>>> diabetes\_X\_train = diabetes.data[:-20]
>>> diabetes\_X\_test
= diabetes.data[-20:]
>>> diabetes\_y\_train = diabetes.target[:-20]
= diabetes.target[-20:]
>>> diabetes\_y\_test

The task at hand is to predict disease prediction from physiological variables.

20.6.1 Sparse models

To improve the conditioning of the problem (uninformative variables, mitigate the curse of dimensionality, as
a feature selection preprocessing, etc.), it would be interesting to select only the informative features and set
non-informative ones to 0. This penalization approach, called Lasso, can set some coefﬁcients to zero. Such
methods are called sparse method, and sparsity can be seen as an application of Occam’s razor: prefer simpler
models to complex ones.

>>> from sklearn import linear\_model
>>> regr = linear\_model.Lasso(alpha=.3)
>>> regr.fit(diabetes\_X\_train, diabetes\_y\_train)
Lasso(...)
>>> regr.coef\_ # very sparse coefficients
,
array([
,
430.9379595 ,

,
497.34075682,
, -118.89291545,
])

-0.
-0.
0.

0.
-0.

199.17441034,
,

0.

>>> regr.score(diabetes\_X\_test, diabetes\_y\_test)
0.5510835453...

being the score very similar to linear regression (Least Squares):

>>> lin = linear\_model.LinearRegression()
>>> lin.fit(diabetes\_X\_train, diabetes\_y\_train)
LinearRegression(...)
>>> lin.score(diabetes\_X\_test, diabetes\_y\_test)
0.5850753022...

Different algorithms for a same problem
Different algorithms can be used to solve the same mathematical problem. For instance the Lasso ob-
ject in the sklearn solves the lasso regression using a coordinate descent method, that is efﬁcient on
large datasets. However, the sklearn also provides the LassoLARS object, using the LARS which is very
efﬁcient for problems in which the weight vector estimated is very sparse, that is problems with very few
observations.

20.6. Linear model: from regression to sparsity

361

Scipy lecture notes, Edition 2015.2

20.7 Model selection: choosing estimators and their parameters

20.7.1 Grid-search and cross-validated estimators

Grid-search

The scikit-learn provides an object that, given data, computes the score during the ﬁt of an estimator on a
parameter grid and chooses the parameters to maximize the cross-validation score. This object takes an esti-
mator during the construction and exposes an estimator API:

>>> from sklearn import svm, grid\_search
>>> gammas = np.logspace(-6, -1, 10)
>>> svc = svm.SVC()
>>> clf = grid\_search.GridSearchCV(estimator=svc, param\_grid=dict(gamma=gammas),
...
>>> clf.fit(digits.data[:1000], digits.target[:1000])
GridSearchCV(cv=None,...)
>>> clf.best\_score\_
0.9...
>>> clf.best\_estimator\_.gamma
0.00059948425031894088

n\_jobs=-1)

By default the GridSearchCV uses a 3-fold cross-validation. However, if it detects that a classiﬁer is passed,
rather than a regressor, it uses a stratiﬁed 3-fold.

Cross-validated estimators

Cross-validation to set a parameter can be done more efﬁciently on an algorithm-by-algorithm basis. This is
why, for certain estimators, the scikit-learn exposes “CV” estimators, that set their parameter automatically by
cross-validation:

>>> from sklearn import linear\_model, datasets
>>> lasso = linear\_model.LassoCV()
>>> diabetes = datasets.load\_diabetes()
>>> X\_diabetes = diabetes.data
>>> y\_diabetes = diabetes.target
>>> lasso.fit(X\_diabetes, y\_diabetes)
LassoCV(alphas=None, ...)
>>> # The estimator chose automatically its lambda:
>>> lasso.alpha\_
0.012...

These estimators are called similarly to their counterparts, with ‘CV’ appended to their name.

Exercise

On the diabetes dataset, ﬁnd the optimal regularization parameter alpha.

20.7. Model selection: choosing estimators and their parameters

362

D
diff, 304, 307
differentiation, 304
dsolve, 307

E
equations

algebraic, 305
differential, 307

I
integration, 305

M
Matrix, 306

P
Python Enhancement Proposals

PEP 255, 145
PEP 3118, 182
PEP 3129, 155
PEP 318, 147, 155
PEP 342, 145
PEP 343, 155
PEP 380, 147
PEP 380#id13, 147
PEP 8, 150

S
solve, 305

Index

363

