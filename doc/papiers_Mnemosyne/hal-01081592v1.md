Antialiased 2D Grid, Marker, and Arrow Shaders
Nicolas P. Rougier

To cite this version:

Nicolas P. Rougier. Antialiased 2D Grid, Marker, and Arrow Shaders. Journal of Computer Graphics
Techniques, 2014, 3 (4), pp.52. ￿hal-01081592￿

HAL Id: hal-01081592

https://hal.science/hal-01081592

Submitted on 10 Nov 2014

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est
destinée au dépôt et à la diffusion de documents
scientifiques de niveau recherche, publiés ou non,
émanant des établissements d’enseignement et de
recherche français ou étrangers, des laboratoires
publics ou privés.

Distributed under a Creative Commons Attribution - NoDerivatives 4.0 International License

Journal of Computer Graphics Techniques Vol. 3, No. 4, 2014

http://jcgt.org

Antialiased 2D Grid, Marker, and Arrow Shaders

Nicolas P. Rougier
INRIA, CNRS, Université de Bordeaux

Figure 1. Antialiased arrows, markers, and grid as drawn by the GPU.

Abstract

Grids, markers, and arrows are important components in scientiﬁc visualisation. Grids are
widely used in scientiﬁc plots and help visually locate data. Markers visualize individual
points and aggregated data. Quiver plots show vector ﬁelds, such as a velocity buffer, through
regularly-placed arrows. Being able to draw these components quickly is critical if one wants
to offer interactive visualisation. This article provides algorithms with GLSL implementations
for drawing grids, markers, and arrows using implicit surfaces that make it possible quickly
render pixel-perfect antialiased shapes.

1.

Introduction

Grids, markers and arrows are important components in scientiﬁc visualization.
Grids are widely used in scientiﬁc plots and help visually locate data. In the most
simple case (orthographic mode, cartesian axis, no rotation), such grids can easily be
drawn using a simple set of straight lines, without the need of anti-aliasing techniques.
Complexity arises when one want to use other projection systems like polar projection
or those found in cartography (e.g., Hammer, Mercator, etc.). In such a case, rendering
a grid might require highly tessellated lines to cope with curvature as well as precise
anti-aliasing techniques [Chan and Durand 2005; Rougier 2013]. Furthermore, any

1

ISSN 2331-7418

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

change in the projection (zoom, translate, scale) requires a new tessellation stage. In
order to achieve resolution independence (e.g., for curves [Loop and Blinn 2005]),
I describe an alternative and versatile approach where an anti-aliased grid is drawn
directly by the GPU, provided the forward and inverse projection are known (either
analytically or approximated). Using the same implicit surface technique, we can
advance by drawing different markers (e.g., cross, circle, square, etc) as well as arrows
and generate beautiful and efﬁcient scatter or quiver plots.

In this paper, I introduce the different antialiasing techniques that are relatively
easy to understand before introducing an atlas of markers and arrows built from them.
Then, using the same implicit surface approach, I will explain how this method can
be extended to drawing a grid using any kind of projection as long as the topological
relationships are preserved.

As most of this paper is structured as a cookbook or reference manual for 2D
visualization elements, I provide a hyperlinked table of contents for quickly jumping
to the section of interest when reading the PDF ﬁle on a computer instead of a printout.

Contents

Markers

5

6
3.1 Generic vertex and fragment marker shaders . . . . . . . . . . . . . .
7
3.2 Disc marker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
3.3 Square marker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
3.4 Triangle marker . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3.5 Diamond marker
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
3.6 Heart marker
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
3.7 Spade marker
3.8 Club marker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
3.9 Chevron marker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.10 Clover marker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
3.11 Ring marker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
3.12 Tag marker
3.13 Cross marker
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
3.14 Asterisk marker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3.15 Inﬁnity marker
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.16 Pin marker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
3.17 Block arrow marker . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.18 Ellipse marker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23

Arrows

25

4.1 Curved arrows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
4.2 Stealth arrows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

2

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

4.3 Triangle arrow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
4.3.1 Generic triangle arrow . . . . . . . . . . . . . . . . . . . . . 29
4.3.2 Triangle arrow (30◦)
. . . . . . . . . . . . . . . . . . . . . . 30
4.3.3 Triangle arrow (60◦)
. . . . . . . . . . . . . . . . . . . . . . 31
4.3.4 Triangle arrow (90◦)
. . . . . . . . . . . . . . . . . . . . . . 32
4.4 Angle arrow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
4.4.1 Generic angle arrow . . . . . . . . . . . . . . . . . . . . . . 33
4.4.2 Angle arrow (30◦)
. . . . . . . . . . . . . . . . . . . . . . . 34
4.4.3 Angle arrow (60◦)
. . . . . . . . . . . . . . . . . . . . . . . 35
4.4.4 Angle arrow (90◦)
. . . . . . . . . . . . . . . . . . . . . . . 36

Grids

37

5.1 Cartesian projection . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
5.2 Polar projection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
5.3 Hammer projection . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
. . . . . . . . . . . . . . . . . . . . . . . . . . 49
5.4 Transverse Mercator

2. Antialiasing using implicit surfaces

Chan and Durand [2005] introduced an antialiasing technique for lines (based on
work originally developed by McNamara [2000]) where the fragment distance to the
mathematical line is used to compute fragment coverage. This idea can be further ex-
tended using a signed distance that distinguishes between exterior and interior. Then,
as it has been proposed by Green [2007], we can easily ﬁll, outline, and stroke shapes
as illustrated on ﬁgure 2. In the code listings that follow, all units are in pixels.

Figure 2. Antialias functions. From bottom to top: ﬁlled, outlined, stroked. From left to
right: increasing linewidth. Top row from left to right: increading antialiased area.

3

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

2.1 Stroked shape

vec4 stroke(float distance,

// Signed distance to line

float linewidth, // Stroke line width
float antialias, // Stroke antialiased area
vec4 stroke)

// Stroke color

{

}

float t = linewidth / 2.0 - antialias;
float signed\_distance = distance;
float border\_distance = abs(signed\_distance) - t;
float alpha = border\_distance / antialias;
alpha = exp(-alpha \* alpha);

if( border\_distance < 0.0 )

return stroke;

else

return vec4(stroke.rgb, stroke.a \* alpha);

Listing 1. Antialiased stroked shape.

2.2 Filled shape

vec4 filled(float distance,

// Signed distance to line

float linewidth, // Stroke line width
float antialias, // Stroke antialiased area
vec4 fill)

// Fill color

{

}

float t = linewidth / 2.0 - antialias;
float signed\_distance = distance;
float border\_distance = abs(signed\_distance) - t;
float alpha = border\_distance / antialias;
alpha = exp(-alpha \* alpha);

if( border\_distance < 0.0 )

return fill;

else if( signed\_distance < 0.0 )

return fill;

else

return vec4(fill.rgb, alpha \* fill.a);

Listing 2. Antialiased ﬁlled shape.

4

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

2.3 Outlined shape

vec4 outline(float distance, // Signed distance to line

float linewidth, // Stroke line width
float antialias, // Stroke antialiased area
vec4 stroke,
vec4 fill)

// Stroke color
// Fill color

{

}

float t = linewidth / 2.0 - antialias;
float signed\_distance = distance;
float border\_distance = abs(signed\_distance) - t;
float alpha = border\_distance / antialias;
alpha = exp(-alpha \* alpha);

if( border\_distance < 0.0 )

return stroke;

else if( signed\_distance < 0.0 )

return mix(fill, stroke, sqrt(alpha));

else

return vec4(stroke.rgb, stroke.a \* alpha);

Listing 3. Antialiased outlined shape.

3. Markers

An elementary shape is deﬁned by an implicit function giving the signed distance
to the shape frontiers. We use an arbitrary convention such that negative values are
inside the shape and positive values are outside the shape. Considering two implicit
surfaces S1 and S2, we can deﬁne the union, difference and intersection operators as
follow:

• Union(S1, S2) : ∀x, y,U(x, y) = min(S1(x, y), S2(x, y))

• Difference(S1, S2) : ∀x, y, D(x, y) = max(S1(x, y), −S2(x, y))

• Intersection(S1, S2) : ∀x, y, I(x, y) = max(S1(x, y), S2(x, y))

This provides a simple two-dimensional constructive geometry, a simple application
of the larger ideas presented by Schmidt [2011]. All of the subsequent markers are
combinations of half-planes and circles, except for the ellipse, which is is a special
case. These use the base vertex and fragment shaders so that only the marker needs
to be replaced with the marker actual code. I described some common markers; any
traditional constructive solid geometry operations can be applied as well.

Finally, I note that markers may be rotated. We must to take this into account

when computing the size of the Point.

5

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

3.1. Generic vertex and fragment marker shaders

Here are the vertex and fragment shaders that are used to display markers using points.

#version 120

const float SQRT\_2 = 1.4142135623730951;

uniform mat4 ortho;
uniform float size, orientation, linewidth, antialias;
attribute vec3 position;
varying vec2 rotation;
varying vec2 v\_size;
void main (void)
{

rotation = vec2(cos(orientation), sin(orientation));
gl\_Position = ortho \* vec4(position, 1.0);
v\_size = M\_SQRT\_2 \* size + 2.0\*(linewidth + 1.5\*antialias);
gl\_PointSize = v\_size;

}

#version 120

Listing 4. Marker vertex

const float PI = 3.14159265358979323846264;
const float SQRT\_2 = 1.4142135623730951;

uniform float size, linewidth, antialias;
uniform vec4 fg\_color, bg\_color;
varying vec2 rotation;
varying vec2 v\_size;
void main()
{

vec2 P = gl\_PointCoord.xy - vec2(0.5,0.5);
P = vec2(rotation.x\*P.x - rotation.y\*P.y,

rotation.y\*P.x + rotation.x\*P.y);

float distance = marker(P\*v\_size, size);
gl\_FragColor = outline(distance,

}

linewidth, antialias, fg\_color, bg\_color);

Listing 5. Marker fragment.

6

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

3.2. Disc marker

A simple disc.

Figure 3. Disc marker.

float disc(vec2 P, float size)
{

return length(P) - size/2;

}

Listing 6. Disc marker.

7

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

3.3. Square marker

A square is the intersection of four half-planes but we can use the symmetry of the
object (abs) to shorten the code.

Figure 4. Square marker.

float square(vec2 P, float size)
{

return max(abs(P.x), abs(P.y)) - size/(2.0\*M\_SQRT\_2);

}

Listing 7. Square marker.

8

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

3.4. Triangle marker

A triangle is the intersection of three half-planes.

Figure 5. Triangle marker.

float triangle(vec2 P, float size)
{

float x = M\_SQRT\_2/2.0 \* (P.x - P.y);
float y = M\_SQRT\_2/2.0 \* (P.x + P.y);

float r1 = max(abs(x), abs(y)) - size/(2\*M\_SQRT\_2);
float r2 = P.y;
return max(r1,r2);

}

Listing 8. Triangle marker.

9

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

3.5. Diamond marker

A diamond is the rotation of a square.

Figure 6. Diamond marker.

float diamond(vec2 P, float size)
{

float x = M\_SQRT\_2/2.0 \* (P.x - P.y);
float y = M\_SQRT\_2/2.0 \* (P.x + P.y);

return max(abs(x), abs(y)) - size/(2.0\*M\_SQRT\_2);

}

Listing 9. Diamond marker.

10

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

3.6. Heart marker

A heart is the union of a diamond and two discs.

Figure 7. Heart marker.

float heart(vec2 P, float size)
{

float x = M\_SQRT\_2/2.0 \* (P.x - P.y);
float y = M\_SQRT\_2/2.0 \* (P.x + P.y);
float r1 = max(abs(x),abs(y))-size/3.5;
float r2 = length(P - M\_SQRT\_2/2.0\*vec2(+1.0,-1.0)\*size/3.5)

- size/3.5;

float r3 = length(P - M\_SQRT\_2/2.0\*vec2(-1.0,-1.0)\*size/3.5)

- size/3.5;

return min(min(r1,r2),r3);

}

Listing 10. Heart marker.

11

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

3.7. Spade marker

A spade is an inverted heart and a tail is made of two discs and two half-planes.

Figure 8. Spade marker.

float spade(vec2 P, float size)
{

// Reversed heart (diamond + 2 circles)
float s= size \* 0.85 / 3.5;
float x = M\_SQRT\_2/2.0 \* (P.x + P.y) + 0.4\*s;
float y = M\_SQRT\_2/2.0 \* (P.x - P.y) - 0.4\*s;
float r1 = max(abs(x),abs(y)) - s;
float r2 = length(P - M\_SQRT\_2/2.0\*vec2(+1.0,+0.2)\*s) - s;
float r3 = length(P - M\_SQRT\_2/2.0\*vec2(-1.0,+0.2)\*s) - s;
float r4 = min(min(r1,r2),r3);

// Root (2 circles and 2 half-planes)
const vec2 c1 = vec2(+0.65, 0.125);
const vec2 c2 = vec2(-0.65, 0.125);
float r5 = length(P-c1\*size) - size/1.6;
float r6 = length(P-c2\*size) - size/1.6;
float r7 = P.y - 0.5\*size;
float r8 = 0.1\*size - P.y;
float r9 = max(-min(r5,r6), max(r7,r8));

return min(r4,r9);

}

Listing 11. Spade marker.

12

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

3.8. Club marker

A club is a clover and a tail.

Figure 9. Club marker.

float club(vec2 P, float size)
{

// clover (3 discs)
const float t1 = -M\_PI/2.0;
const vec2 c1 = 0.225\*vec2(cos(t1),sin(t1));
const float t2 = t1+2\*M\_PI/3.0;
const vec2 c2 = 0.225\*vec2(cos(t2),sin(t2));
const float t3 = t2+2\*M\_PI/3.0;
const vec2 c3 = 0.225\*vec2(cos(t3),sin(t3));
float r1 = length( P - c1\*size) - size/4.25;
float r2 = length( P - c2\*size) - size/4.25;
float r3 = length( P - c3\*size) - size/4.25;
float r4 = min(min(r1,r2),r3);

// Root (2 circles and 2 half-planes)
const vec2 c4 = vec2(+0.65, 0.125);
const vec2 c5 = vec2(-0.65, 0.125);
float r5 = length(P-c4\*size) - size/1.6;
float r6 = length(P-c5\*size) - size/1.6;
float r7 = P.y - 0.5\*size;
float r8 = 0.2\*size - P.y;
float r9 = max(-min(r5,r6), max(r7,r8));

return min(r4,r9);

}

Listing 12. Club marker.

13

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

3.9. Chevron marker

A chevron is the difference of two diamonds.

Figure 10. Chevron marker.

float chevron(vec2 P, float size)
{

float x = 1.0/M\_SQRT\_2 \* (P.x - P.y);
float y = 1.0/M\_SQRT\_2 \* (P.x + P.y);
float r1 = max(abs(x), abs(y)) - size/3.0;
float r2 = max(abs(x-size/3.0), abs(y-size/3.0)) - size/3.0;
return max(r1,-r2);

}

Listing 13. Chevron marker.

14

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

3.10. Clover marker

A clover is the union of three discs.

Figure 11. Clover marker.

float clover(vec2 P, float size)
{

const float PI = 3.14159265358979323846264;
const float t1 = -PI/2;
const vec2 c1 = 0.25\*vec2(cos(t1),sin(t1));
const float t2 = t1+2\*PI/3;
const vec2 c2 = 0.25\*vec2(cos(t2),sin(t2));
const float t3 = t2+2\*PI/3;
const vec2 c3 = 0.25\*vec2(cos(t3),sin(t3));

float r1 = length( P - c1\*size) - size/3.5;
float r2 = length( P - c2\*size) - size/3.5;
float r3 = length( P - c3\*size) - size/3.5;
return min(min(r1,r2),r3);

}

Listing 14. Clover marker.

15

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

3.11. Ring marker

A ring is the difference of two discs.

Figure 12. Ring marker.

float ring(vec2 P, float size)
{

float r1 = length(P) - size/2.0;
float r2 = length(P) - size/4.0;
return max(r1,-r2);

}

Listing 15. Ring marker.

16

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

3.12. Tag marker

A tag is the interesection of ﬁve half-planes.

Figure 13. Tag marker.

float tag(vec2 P, float size)
{

float r1 = max(abs(P.x)- size/2.0, abs(P.y)- size/6.0);
float r2 = abs(P.x-size/1.5)+abs(P.y)-size;
return max(r1,0.75\*r2);

}

Listing 16. Tag marker.

17

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

3.13. Cross marker

A cross is the intersection of eight half-planes that can be reduced to four using sym-
metries.

Figure 14. Cross marker.

float cross(vec2 P, float size)
{

float x = M\_SQRT\_2/2.0 \* (P.x - P.y);
float y = M\_SQRT\_2/2.0 \* (P.x + P.y);
float r1 = max(abs(x - size/3.0), abs(x + size/3.0));
float r2 = max(abs(y - size/3.0), abs(y + size/3.0));
float r3 = max(abs(x), abs(y));
return max(min(r1,r2),r3) - size/2.0;

}

Listing 17. Cross marker.

18

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

3.14. Asterisk marker

An asterisk is the union of two crosses.

Figure 15. Asterisk marker.

float asterisk(vec2 P, float size)
{

float x = M\_SQRT\_2/2.0 \* (P.x - P.y);
float y = M\_SQRT\_2/2.0 \* (P.x + P.y);

float r1 = max(abs(x)- size/2.0, abs(y)- size/10.0);
float r2 = max(abs(y)- size/2.0, abs(x)- size/10.0);
float r3 = max(abs(P.x)- size/2.0, abs(P.y)- size/10.0);
float r4 = max(abs(P.y)- size/2.0, abs(P.x)- size/10.0);
return min( min(r1,r2), min(r3,r4));

}

Listing 18. Asterisk marker.

19

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

3.15.

Inﬁnity marker

Inﬁnity is the union of two rings.

Figure 16. Inﬁnity marker.

float infinity(vec2 P, float size)
{

const vec2 c1 = vec2(+0.2125, 0.00);
const vec2 c2 = vec2(-0.2125, 0.00);
float r1 = length(P-c1\*size) - size/3.5;
float r2 = length(P-c1\*size) - size/7.5;
float r3 = length(P-c2\*size) - size/3.5;
float r4 = length(P-c2\*size) - size/7.5;
return min( max(r1,-r2), max(r3,-r4));

}

Listing 19. Inﬁnity marker.

20

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

3.16. Pin marker

A pin is the difference between the union of three discs and a disc.

Figure 17. Pin marker.

float pin(vec2 P, float size) {

vec2 c1 = vec2(0.0,-0.15)\*size;
float r1 = length(P-c1)-size/2.675;
vec2 c2 = vec2(+1.49,-0.80)\*size;
float r2 = length(P-c2) - 2.\*size;
vec2 c3 = vec2(-1.49,-0.80)\*size;
float r3 = length(P-c3) - 2.\*size;
float r4 = length(P-c1)-size/5;
return max( min(r1,max(max(r2,r3),-P.y)), -r4);

}

Listing 20. Pin marker.

21

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

3.17. Block arrow marker

Block arrow is the intersection of several half-planes using symmetries.

Figure 18. Block arrow marker.

float arrow(vec2 P, float size)
{

float x = P.x;
float y = P.y;
float r1 = abs(x) + abs(y) - size/2;
float r2 = max(abs(x+size/2), abs(y)) - size/2;
float r3 = max(abs(x-size/6)-size/4, abs(y)- size/4);
return min(r3,max(.75\*r1,r2));

}

Listing 21. Block arrow marker.

22

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

3.18. Ellipse marker

Ellipse markers are quite different from other markers because there is no easy solu-
tion for computing the distance to an ellipse. Fortunately, [Quílez 2009] provided a
complete analysis and implementation.

Figure 19. Ellipse marker by Iñigo Quilez.

23

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

float ellipse(vec2 P, float size) {
// Created by inigo quilez - iq/2013
// License Creative Commons
// Attribution-NonCommercial-ShareAlike 3.0 Unported License.

vec2 ab = vec2(size/3.0, size/2.0);
vec2 p = abs( P );
if( p.x > p.y ){
p = p.yx;
ab = ab.yx;

}
float l = ab.y\*ab.y - ab.x\*ab.x;
float m = ab.x\*p.x/l;
float n = ab.y\*p.y/l;
float m2 = m\*m;
float n2 = n\*n;
float c = (m2 + n2 - 1.0)/3.0;
float c3 = c\*c\*c;
float q = c3 + m2\*n2\*2.0;
float d = c3 + m2\*n2;
float g = m + m\*n2;
float co;

if(d < 0.0)
{

float p = acos(q/c3)/3.0;
float s = cos(p);
float t = sin(p)\*sqrt(3.0);
float rx = sqrt( -c\*(s + t + 2.0) + m2 );
float ry = sqrt( -c\*(s - t + 2.0) + m2 );
co = ( ry + sign(l)\*rx + abs(g)/(rx\*ry) - m)/2.0;

}
else
{

float h = 2.0\*m\*n\*sqrt( d );
float s = sign(q+h)\*pow( abs(q+h), 1.0/3.0 );
float u = sign(q-h)\*pow( abs(q-h), 1.0/3.0 );
float rx = -s - u - c\*4.0 + 2.0\*m2;
float ry = (s - u)\*sqrt(3.0);
float rm = sqrt( rx\*rx + ry\*ry );
float p = ry/sqrt(rm-rx);
co = (p + 2.0\*g/rm - m)/2.0;

}

float si = sqrt(1.0 - co\*co);
vec2 closestPoint = vec2(ab.x\*co, ab.y\*si);
return length(closestPoint - p ) \* sign(p.y-closestPoint.y);

}

Listing 22. Ellipse marker by Iñigo Quilez.

24

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

4. Arrows

Styled arrows require different approaches because only the heads of the arrows are
plain, while the bodies are thick line. Furthermore, arrows are parameterized on
length and the thickness of the head relatively to the length of the body. I took the
same approach as the one introduced by Morgan McGuire [2014] in his quiver plot
demonstration, and implemented a set of helper functions to measure the signed dis-
tance to an inﬁnite line and line segment, and to compute the center of a circle passing
through two points with a speciﬁed radius needed for the curved styled arrow.

// Computes the signed distance from a line
float line\_distance(vec2 p, vec2 p1, vec2 p2) {

vec2 center = (p1 + p2) \* 0.5;
float len = length(p2 - p1);
vec2 dir = (p2 - p1) / len;
vec2 rel\_p = p - center;
return dot(rel\_p, vec2(dir.y, -dir.x));

}

Listing 23. Signed line distance.

// Computes the signed distance from a line segment
float segment\_distance(vec2 p, vec2 p1, vec2 p2) {

vec2 center = (p1 + p2) \* 0.5;
float len = length(p2 - p1);
vec2 dir = (p2 - p1) / len;
vec2 rel\_p = p - center;
float dist1 = abs(dot(rel\_p, vec2(dir.y, -dir.x)));
float dist2 = abs(dot(rel\_p, dir)) - 0.5\*len;
return max(dist1, dist2);

}

Listing 24. Signed segment distance.

// Computes the centers of a circle with
// given radius passing through p1 & p2
vec4 inscribed\_circle(vec2 p1, vec2 p2, float radius)
{

float q = length(p2-p1);
vec2 m = (p1+p2)/2.0;
vec2 d = vec2( sqrt(radius\*radius - (q\*q/4.0)) \* (p1.y-p2.y)/q,

sqrt(radius\*radius - (q\*q/4.0)) \* (p2.x-p1.x)/q);

return

vec4(m+d, m-d);

}

Listing 25. Inscribed circle.

25

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

4.1. Curved arrows

The head of a curved arrow is made of the intersection of three circles.

Figure 20. Curved arrow using using length(head) = 0.25 ∗ length(body).

float arrow\_curved(vec2 texcoord, float body, float head,

float linewidth, float antialias)

{

float w = linewidth/2.0 + antialias;
vec2 start = -vec2(body/2.0, 0.0);
vec2 end
= +vec2(body/2.0, 0.0);
float height = 0.5;

vec2 p1 = end - head\*vec2(+1.0,+height);
vec2 p2 = end - head\*vec2(+1.0,-height);
vec2 p3 = end;

// Head : 3 circles
vec2 c1
float d1 = length(texcoord - c1) - 1.25\*body;

= inscribed\_circle(p1, p3, 1.25\*body).zw;

vec2 c2
float d2 = length(texcoord - c2) - 1.25\*body;

= inscribed\_circle(p2, p3, 1.25\*body).xy;

vec2 c3
float d3 = length(texcoord - c3) - max(body-head, 1.0\*body);

= inscribed\_circle(p1, p2, max(body-head, 1.0\*body)).xy;

// Body : 1 segment
float d4 = segment\_distance(texcoord,

start, end - vec2(linewidth,0.0));

// Outside rejection (because of circles)

26

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

if( texcoord.y > +(2.0\*head + antialias) )

return 1000.0;

if( texcoord.y < -(2.0\*head + antialias) )

return 1000.0;

if( texcoord.x < -(body/2.0 + antialias) )

return 1000.0;
if( texcoord.x > c1.x )
return 1000.0;

return min( d4, -min(d3,min(d1,d2)));

}

Listing 26. Curved arrow.

27

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

4.2. Stealth arrows

The head of a stealth arrow is made of the intersection of four half-planes.

Figure 21. Stealth arrow using using length(head) = 0.25 ∗ length(body).

float arrow\_stealth(vec2 texcoord, float body, float head,

float linewidth, float antialias)

{

}

float w = linewidth/2.0 + antialias;
vec2 start = -vec2(body/2.0, 0.0);
vec2 end
= +vec2(body/2.0, 0.0);
float height = 0.5;

// Head : 4 lines
float d1 = line\_distance(texcoord, end-head\*vec2(+1.0,-height), end);
float d2 = line\_distance(texcoord, end-head\*vec2(+1.0,-height),
end-vec2(3.0\*head/4.0,0.0));

float d3 = line\_distance(texcoord, end-head\*vec2(+1.0,+height), end);
float d4 = line\_distance(texcoord, end-head\*vec2(+1.0,+0.5),

end-vec2(3.0\*head/4.0,0.0));

// Body : 1 segment
float d5 = segment\_distance(texcoord,

start,
end - vec2(linewidth,0.0));

return min(d5, max( max(-d1, d3), - max(-d2,d4)));

Listing 27. Stealth arrow.

28

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

4.3. Triangle arrow

The head of a triangle arrow is made of the intersection of three half-planes.

4.3.1. Generic triangle arrow

float arrow\_triangle(vec2 texcoord,

float body, float head, float height,
float linewidth, float antialias)

{

}

float w = linewidth/2.0 + antialias;
vec2 start = -vec2(body/2.0, 0.0);
= +vec2(body/2.0, 0.0);
vec2 end

// Head : 3 lines
float d1 = line\_distance(texcoord,

float d2 = line\_distance(texcoord,

end, end - head\*vec2(+1.0,-height));

end - head\*vec2(+1.0,+height), end);

float d3 = texcoord.x - end.x + head;

// Body : 1 segment
float d4 = segment\_distance(texcoord,

start, end - vec2(linewidth,0.0));

float d = min(max(max(d1, d2), -d3), d4);
return d;

Listing 28. Triangle arrow.

29

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

4.3.2. Triangle arrow (30◦

)

Figure 22. Triangle arrow (30◦

) using length(head) = 0.25 ∗ length(body).

float arrow\_triangle\_30(vec2 texcoord,

float body, float head,
float linewidth, float antialias)

{

}

return arrow\_triangle(texcoord, body, head,

0.25, linewidth, antialias);

Listing 29. Triangle arrow (30◦

).

30

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

4.3.3. Triangle arrow (60◦

)

Figure 23. Triangle arrow (60◦

) using length(head) = 0.20 ∗ length(body).

float arrow\_triangle\_60(vec2 texcoord,

float body, float head,
float linewidth, float antialias)

{

}

return arrow\_triangle(texcoord, body, head,

0.50, linewidth, antialias);

Listing 30. Triangle arrow (60◦

).

31

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

4.3.4. Triangle arrow (90◦

)

Figure 24. Triangle arrow (90◦

) using length(head) = 0.15 ∗ length(body).

float arrow\_triangle\_90(vec2 texcoord,

float body, float head,
float linewidth, float antialias)

{

}

return arrow\_triangle(texcoord, body, head,

1.00, linewidth, antialias);

Listing 31. Triangle arrow (90◦

).

32

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

4.4. Angle arrow

The head of an angle arrow is made of two lines. Note that we have to consider the
tip of the head located beyond the end segment and ensure that head lines are cut and
replaced by the corresponding triangle that forms the tip of the head.

4.4.1. Generic angle arrow

float arrow\_angle(vec2 texcoord,

float body, float head, float height,
float linewidth, float antialias)

{

float d;
float w = linewidth/2.0 + antialias;
vec2 start = -vec2(body/2.0, 0.0);
= +vec2(body/2.0, 0.0);
vec2 end

// Arrow tip (beyond segment end)
if( texcoord.x > body/2.0) {
// Head : 2 segments
float d1 = line\_distance(texcoord,

float d2 = line\_distance(texcoord,

end, end - head\*vec2(+1.0,-height));

end - head\*vec2(+1.0,+height), end);

// Body : 1 segment
float d3 = end.x - texcoord.x;
d = max(max(d1,d2), d3);

} else {

// Head : 2 segments
float d1 = segment\_distance(texcoord,

float d2 = segment\_distance(texcoord,

end - head\*vec2(+1.0,-height), end);

end - head\*vec2(+1.0,+height), end);

// Body : 1 segment
float d3 = segment\_distance(texcoord,

start, end - vec2(linewidth,0.0));

d = min(min(d1,d2), d3);

}
return d;

}

Listing 32. Angle arrow.

33

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

4.4.2. Angle arrow (30◦

)

Figure 25. Angle arrow (30◦

) using length(head) = 0.33 ∗ length(body)

float arrow\_angle\_30(vec2 texcoord,

float body, float head,
float linewidth, float antialias)

{

}

return arrow\_angle(texcoord, body, head,

0.25, linewidth, antialias);

Listing 33. Angle arrow (30◦

).

34

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

4.4.3. Angle arrow (60◦

)

Figure 26. Angle arrow (60◦

) using length(head) = 0.25 ∗ length(body).

float arrow\_angle\_60(vec2 texcoord,

float body, float head,
float linewidth, float antialias)

{

}

return arrow\_angle(texcoord, body, head,

0.50, linewidth, antialias);

Listing 34. Angle arrow (60◦

).

35

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

4.4.4. Angle arrow (90◦

)

Figure 27. Angle arrow (90◦

) using length(head) = 0.15 ∗ length(body).

float arrow\_angle\_90(vec2 texcoord,

float body, float head,
float linewidth, float antialias)

{

}

return arrow\_angle(texcoord, body, head,

1.00, linewidth, antialias);

Listing 35. Angle arrow (90◦

).

36

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

5. Grids

Grids are the most complex shapes considered in this paper. They require dynamic
generation of the implicit surface function, which itself depends on the parameters of
the grid:

• Projection function (both forward and inverse).

• Spacing between major and minor grid lines respectively.

• Limits of the cartesian domain (axis 1) containing the projected grid.

• Limits of the projected domain (axis 2).

• Thickness of major and minor grid lines.

• Color of major and minor grid lines.

Fortunately, the implementation is straightforward. Considering a quad whose tex-
ture coordinates span the [−0.5, +0.5]2 domain, for any quad fragment with texture
coordinates P, we need to:

1. Compute the corresponding coordinates P1 in cartesian reference using the

scale\_forward function).

2. Compute the corresponding coordinates P2 in projected reference using the

transform\_inverse function).

3. Compute the nearest ticks for all grids (X major, Y major, X minor, Y minor)

in projected reference using the get\_tick function.

4. Compute the cartesian projection of the tick using the transform\_forward

function.

5. Compute the screen distance (in pixels) between the current fragment and all

computed ticks location.

6. Compute the dominant color according to the distance of the fragment to the

ticks location.

We also must to take into account the border of the grid. If we directly enforced
the limits of the projected domain, then the external borders would be cut in half due
to their thickness. We instead must ensure those lines are properly drawn by tracking
when we are outside the domain, and then drawing those lines later (see listing 39).

The fragment shader is long because of the parameterization. The caller can con-
trol the location of ticks, the transform functions, and the projected domain. It works

37

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

in both orthographic and perspective mode using a ﬁxed apparent-line thickness and
assumes that the quad is lying on the xz plane. To make the code easier to read, I
present it in four parts:

• Listing 36 Grid Fragment: Parameters

• Listing 37 Grid Fragment: Projection functions

• Listing 38 Grid Fragment: Helper functions

• Listing 39 Grid Fragment: Main function

// Line antialias area (usually 1 pixel)
uniform float u\_antialias;

// Cartesian and projected limits as xmin,xmax,ymin,ymax
uniform vec4 u\_limits1, u\_limits2;

// Major and minor grid steps
uniform vec2 u\_major\_grid\_step, u\_minor\_grid\_step;

// Major and minor grid line widths (1.50 pixel, 0.75 pixel)
uniform float u\_major\_grid\_width, u\_minor\_grid\_width;

// Major grid line color
uniform vec4 u\_major\_grid\_color;

// Minor grid line color
uniform vec4 u\_minor\_grid\_color;

// Texture coordinates (from (-0.5,-0.5) to (+0.5,+0.5)
varying vec2 v\_texcoord;

// View matrix
uniform mat4 view;

// Model matrix
uniform mat4 model;

// Projection matrix
uniform mat4 projection;

// Viewport resolution (in pixels)
uniform vec2 iResolution;

Listing 36. Grid fragment: parameters.

38

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

// Forward transform (polar)
vec2 transform\_forward(vec2 P)
{

float x = P.x \* cos(P.y);
float y = P.x \* sin(P.y);
return vec2(x,y);

}

// Inverse transform (polar)
vec2 transform\_inverse(vec2 P)
{

float rho = length(P);
float theta = atan(P.y,P.x);
if( theta < 0.0 )

theta = 2.0\*M\_PI+theta;

return vec2(rho,theta);

}

// [-0.5,-0.5]x[0.5,0.5] -> [xmin,xmax]x[ymin,ymax]
vec2 scale\_forward(vec2 P, vec4 limits)
{

// limits = xmin,xmax,ymin,ymax
P += vec2(.5,.5);
P \*= vec2(limits[1] - limits[0], limits[3]-limits[2]);
P += vec2(limits[0], limits[2]);
return P;

}

// [xmin,xmax]x[ymin,ymax] -> [-0.5,-0.5]x[0.5,0.5]
vec2 scale\_inverse(vec2 P, vec4 limits)
{

// limits = xmin,xmax,ymin,ymax
P -= vec2(limits[0], limits[2]);
P /= vec2(limits[1]-limits[0], limits[3]-limits[2]);
return P - vec2(.5,.5);

}

Listing 37. Grid fragment: projection and scaling.

39

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

// Antialias stroke alpha coeff
float stroke\_alpha(float distance, float linewidth, float antialias)
{

float t = linewidth/2.0 - antialias;
float signed\_distance = distance;
float border\_distance = abs(signed\_distance) - t;
float alpha = border\_distance/antialias;
alpha = exp(-alpha\*alpha);
if( border\_distance > (linewidth/2.0 + antialias) )

return 0.0;

else if( border\_distance < 0.0 )

return 1.0;

else

return alpha;

}

// Compute the nearest tick from a (normalized) t value
float get\_tick(float t, float vmin, float vmax, float step)
{

float first\_tick = floor((vmin + step/2.0)/step) \* step;
float last\_tick = floor((vmax + step/2.0)/step) \* step;
float tick = vmin + t\*(vmax-vmin);
if (tick < (vmin + (first\_tick-vmin)/2.0))

return vmin;

if (tick > (last\_tick + (vmax-last\_tick)/2.0))

return vmax;

tick += step/2.0;
tick = floor(tick/step)\*step;
return min(max(vmin,tick),vmax);

}

// Compute the distance (in screen coordinates) between A and B
float screen\_distance(vec4 A, vec4 B)
{

vec4 pA = projection\*view\*model\*A;
pA /= pA.w;
pA.xy = pA.xy \* iResolution/2.0;

vec4 pB = projection\*view\*model\*B;
pB /= pB.w;
pB.xy = pB.xy \* iResolution/2.0;

return length(pA.xy - pB.xy);

}

Listing 38. Grid fragment: helper functions.

40

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

void main()
{

vec2 NP1 = v\_texcoord;
vec2 P1 = scale\_forward(NP1, u\_limits1);
vec2 P2 = transform\_inverse(P1);

// Test if we are within limits but we do not discard the
// fragment yet because we want to draw border.
// would mean that the exterior would not be drawn.
bvec2 outside = bvec2(false);
if( P2.x < u\_limits2[0] ) outside.x = true;
if( P2.x > u\_limits2[1] ) outside.x = true;
if( P2.y < u\_limits2[2] ) outside.y = true;
if( P2.y > u\_limits2[3] ) outside.y = true;

Discarding

vec2 NP2 = scale\_inverse(P2,u\_limits2);
vec2 P;
float tick;

// Major tick, X axis
tick = get\_tick(NP2.x+.5, u\_limits2[0], u\_limits2[1], u\_major\_grid\_step[0]);
P = transform\_forward(vec2(tick,P2.y));
P = scale\_inverse(P, u\_limits1);
// float Mx = length(v\_size \* (NP1 - P));
// Here we assume the quad is contained in the XZ plane
float Mx = screen\_distance(vec4(NP1,0,1), vec4(P,0,1));

// Minor tick, X axis
tick = get\_tick(NP2.x+.5, u\_limits2[0], u\_limits2[1], u\_minor\_grid\_step[0]);
P = transform\_forward(vec2(tick,P2.y));
P = scale\_inverse(P, u\_limits1);
// float mx = length(v\_size \* (NP1 - P));
// Here we assume the quad is contained in the XZ plane
float mx = screen\_distance(vec4(NP1,0,1), vec4(P,0,1));

// Major tick, Y axis
tick = get\_tick(NP2.y+.5, u\_limits2[2], u\_limits2[3], u\_major\_grid\_step[1]);
P = transform\_forward(vec2(P2.x,tick));
P = scale\_inverse(P, u\_limits1);
// float My = length(v\_size \* (NP1 - P));
// Here we assume the quad is contained in the XZ plane
float My = screen\_distance(vec4(NP1,0,1), vec4(P,0,1));

// Minor tick, Y axis
tick = get\_tick(NP2.y+.5, u\_limits2[2], u\_limits2[3], u\_minor\_grid\_step[1]);
P = transform\_forward(vec2(P2.x,tick));
P = scale\_inverse(P, u\_limits1);
// float my = length(v\_size \* (NP1 - P));
// Here we assume the quad is contained in the XZ plane

41

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

float my = screen\_distance(vec4(NP1,0,1), vec4(P,0,1));

float M = min(Mx,My);
float m = min(mx,my);

// Here we take care of "finishing" the border lines
if( outside.x && outside.y ) {

if (Mx > 0.5\*(u\_major\_grid\_width + u\_antialias)) {

discard;

} else if (My > 0.5\*(u\_major\_grid\_width + u\_antialias)) {

discard;

} else {

M = max(Mx,My);

}

} else if( outside.x ) {

if (Mx > 0.5\*(u\_major\_grid\_width + u\_antialias)) {

discard;

} else {

M = m = Mx;

}

} else if( outside.y ) {

if (My > 0.5\*(u\_major\_grid\_width + u\_antialias)) {

discard;

} else {

M = m = My;

}

}

// Mix major/minor colors to get dominant color
vec4 color = u\_major\_grid\_color;
float alpha1 = stroke\_alpha( M, u\_major\_grid\_width, u\_antialias);
float alpha2 = stroke\_alpha( m, u\_minor\_grid\_width, u\_antialias);
float alpha
if( alpha2 > alpha1\*1.5 )
{

= alpha1;

alpha = alpha2;
color = u\_minor\_grid\_color;

}

// Without extra cost, we can also project a texture
// vec4 texcolor = texture2D(u\_texture, vec2(NP2.x, 1.0-NP2.y));
// gl\_FragColor = mix(texcolor, color, alpha);
gl\_FragColor = vec4(color.rgb, color.a\*alpha);

}

Listing 39. Grid fragment: main.

42

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

5.1. Cartesian projection

This is the most simple projection because transformations are actually identity func-
tions. However, to take the border into account, the respective domains are not exactly
the same (the cartesian domain needs to be slightly bigger to make room for borders).

• u\_limits1 = [-5.1,+5.1,-5.1,+5.1]

• u\_limits2 = [-5.0,+5.0,-5.0,+5.0]

• u\_major\_grid\_step = [1.0,1.0]

• u\_minor\_grid\_step = [0.1,0.1]

• u\_major\_grid\_width = 1.50

• u\_minor\_grid\_width = 0.75

vec2 transform\_forward(vec2 P)
{

return P;

}

vec2 transform\_inverse(vec2 P)
{

return P;

}

Listing 40. Cartesian transformation functions.

43

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

Figure 28. Cartesian projection in perspective mode using grid and texture.

44

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

5.2. Polar projection
In a polar projection, the region around θ = 0 is tricky, because a fragment can be
considered to belong to either the start region (θ > 0) or the end region (θ < 0). This
is mostly visible when the lower limit of the projected domain is 0 and upper limit of
the projected domain is strictly less than 2π. So, I handle this case specially.

• u\_limits1 = [-5.1,+5.1,-5.1,+5.1]

• u\_limits2 = [-5.0,+5.0, M\_PI/6.0, 11.0\*M\_PI/6.0]

• u\_major\_grid\_step = [1.00,M\_PI/ 6.0]

• u\_minor\_grid\_step = [0.25,M\_PI/60.0]

• u\_major\_grid\_width = 1.50

• u\_minor\_grid\_width = 0.75

const float M\_PI = 3.14159265358979323846;

vec2 transform\_forward(vec2 P)
{

float x = P.x \* cos(P.y);
float y = P.x \* sin(P.y);
return vec2(x,y);

}

vec2 transform\_inverse(vec2 P)
{

float rho = length(P);
float theta = atan(P.y,P.x);
if( theta < 0.0 )

theta = 2.0\*M\_PI+theta;

return vec2(rho,theta);

}

Listing 41. Polar transformation functions.

45

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

Figure 29. Polar projection using grid only.

46

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

5.3. Hammer projection

Hammer projection is one of the standard projection used in cartography to project
the Earth’s surface onto a plane. For this projection, I use:

• u\_limits1 = [-3.0, +3.0, -1.5, +1.5]

• u\_limits2 = [-M\_PI, +M\_PI, -M\_PI/3, +M\_PI/3]

• u\_major\_grid\_step = [M\_PI/ 6.0,M\_PI/ 6.0]

• u\_minor\_grid\_step = [M\_PI/30.0,M\_PI/30.0]

• u\_major\_grid\_width = 1.50

• u\_minor\_grid\_width = 0.75

vec2 transform\_forward(vec2 P)
{

const float B = 2.0;
float longitude = P.x;
float latitude
= P.y;
float cos\_lat = cos(latitude);
float sin\_lat = sin(latitude);
float cos\_lon = cos(longitude/B);
float sin\_lon = sin(longitude/B);
float d = sqrt(1.0 + cos\_lat \* cos\_lon);
float x = (B \* M\_SQRT2 \* cos\_lat \* sin\_lon) / d;
float y =
return vec2(x,y);

(M\_SQRT2 \* sin\_lat) / d;

}

vec2 transform\_inverse(vec2 P)
{

const float B = 2.0;
float x = P.x;
float y = P.y;
float z = 1.0 - (x\*x/16.0) - (y\*y/4.0);
if (z < 0.0)
discard;
z = sqrt(z);
float lon = 2.0\*atan( (z\*x),(2.0\*(2.0\*z\*z - 1.0)));
float lat = asin(z\*y);
return vec2(lon,lat);

}

Listing 42. Hammer transformation functions.

47

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

Figure 30. Hammer projection (without pole regions) using a grid only.

48

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

5.4. Transverse Mercator

Transverse Mercator is another one of the standard projection used in cartography to
project the earth surface onto a plane.

• u\_limits1 = [-3.0, +3.0, -1.5, +1.5]

• u\_limits2 = [-M\_PI, +M\_PI, -M\_PI/2, +M\_PI/2]

• u\_major\_grid\_step = [M\_PI/ 6.0,M\_PI/ 6.0]

• u\_minor\_grid\_step = [M\_PI/30.0,M\_PI/30.0]

• u\_major\_grid\_width = 1.50

• u\_minor\_grid\_width = 0.75

// Constants
// ------------------------
const float k0 = 0.75;
const float a = 1.00;

// Helper functions
// ------------------------
float cosh(float x) { return 0.5 \* (exp(x)+exp(-x)); }
float sinh(float x) { return 0.5 \* (exp(x)-exp(-x)); }

// Forward transform
// ------------------------
vec2 transform\_forward(vec2 P)
{

float lambda = P.x;
float phi = P.y;
float x = 0.5\*k0\*log((1.0+sin(lambda)\*cos(phi))
/ (1.0 - sin(lambda)\*cos(phi)));

float y = k0\*a\*atan(tan(phi), cos(lambda));
return vec2(x,y);

}

// Inverse transform
// ------------------------
vec2 transform\_inverse(vec2 P)
{

float x = P.x;
float y = P.y;
float lambda = atan(sinh(x/(k0\*a)),cos(y/(k0\*a)));
float phi
= asin(sin(y/(k0\*a))/cosh(x/(k0\*a)));
return vec2(lambda,phi);

}

Listing 43. Transverse Mercator transformation functions.

49

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

Acknowledgements

This work was inspired by a particular set of online demos:

• Morgan McGuire:

– https://www.shadertoy.com/view/4s23DG
– https://www.shadertoy.com/view/4slGDB

• Iñigo Quilez:

– https://www.shadertoy.com/view/4sS3zz
– https://www.shadertoy.com/view/MdfGWn

Thanks to Amanda Turner of Williams College for additional text editing.

References

CHAN, E., AND DURAND, F. 2005. GPU Gems II: Programming Techniques for High-
Performance Graphics and General-Purpose Computation . Addison-Wesley Professional,
ch. 22. Fast Preﬁltered Lines, 345–369. URL: http://http.developer.nvidia.
com/GPUGems2/gpugems2\_chapter22.html. 1, 3

GREEN, C. 2007.

Improved alpha-tested magniﬁcation for vector textures and special
In ACM SIGGRAPH 2007 courses, ACM, New York, NY, USA, SIGGRAPH
effects.
’07, 9–18. URL: http://www.valvesoftware.com/publications/2007/
SIGGRAPH2007\_AlphaTestedMagnification.pdf. 3

LOOP, C., AND BLINN, J.

Resolution Independent Curve Rendering Us-
In ACM Trans. Graph., ACM, vol. 24,
ing Programmable Graphics Hardware.
1000–1009. URL: http://research.microsoft.com/en-us/um/people/
cloop/LoopBlinn05.pdf. 2

2005.

MCGUIRE, M., 2014. 2d vector ﬁeld ﬂow. https://www.shadertoy.com/view/

4s23DG. 25

MCNAMARA, R., MCCORMACK, J., AND JOUPPI, N.

2000. Preﬁltered Antialiased
In ACM SIGGRAPH/Eurographics Work-
Lines Using Half-Plane Distance Functions.
shop on Graphics Hardware, ACM, 77–85. URL: http://www.hpl.hp.com/
techreports/Compaq-DEC/WRL-98-2.pdf. 3

QUÍLEZ, I., 2009. Distance to an ellipse. http://www.iquilezles.org/www/

articles/ellipsedist/ellipsedist.htm. 23

ROUGIER, N. P. 2013. Shader-based antialiased dashed stroked polylines. Journal of Com-
puter Graphics Techniques 2, 2, 105–121. URL: http://jcgt.org/published/
0002/02/08/. 1

SCHMIDT, R., AND WYVILL, B.

J.
Jorge and F. Samavati, ch. ShapeShop: Free-Form 3D Design with Implicit Solid Mod-
eling. URL: http://www.springer.com/computer/image+processing/
book/978-1-84882-811-7. 5

Sketch-based Interfaces and Modeling.

2011.

50

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

Index of Supplemental Materials

The shaders are available from the JCGT website and I have also released them on the
shadertoy.com website for easy browsing:

• Transverse Mercator grid: https://www.shadertoy.com/view/lsSXzm

• Cartesian grid: https://www.shadertoy.com/view/MdSXRm

• Polar grid: https://www.shadertoy.com/view/MsBSRm

• Hammer grid: https://www.shadertoy.com/view/ldSXRm

• Arrows: https://www.shadertoy.com/view/ldlSWj

• Markers: https://www.shadertoy.com/view/XsXXDX

Author Contact Information

Nicolas P. Rougier
Mnemosyne, INRIA Bordeaux - Sud Ouest
LaBRI, UMR 5800 CNRS, Bordeaux University
Institute of Neurodegenerative Diseases, UMR 5293
351, Cours de la Libération
33405 Talence Cedex, France
Nicolas.Rougier@inria.fr
http://www.loria.fr/~rougier

Nicolas P. Rougier, Antialiased 2D Grid, Marker, and Arrow Shaders, Journal of Computer
Graphics Techniques (JCGT), vol. 3, no. 4, 1–52, 2014
http://jcgt.org/published/0003/04/01/

Received:
Recommended:
Published:

2014-09-09
2014-09-10
2014-11-02

Corresponding Editor: Morgan McGuire
Morgan McGuire
Editor-in-Chief:

c(cid:13) 2014 Nicolas P. Rougier (the Authors).
The Authors provide this document (the Work) under the Creative Commons CC BY-ND
3.0 license available online at http://creativecommons.org/licenses/by-nd/3.0/. The Authors
further grant permission reuse of images and text from the ﬁrst page of the Work, provided
that the reuse is for the purpose of promoting and/or summarizing the Work in scholarly
venues and that any reuse is accompanied by a scientiﬁc citation to the Work.

51

Journal of Computer Graphics Techniques
Antialiased 2D Grid, Marker, and Arrow Shaders

Vol. 3, No. 4, 2014
http://jcgt.org

Figure 31. Transverse Mercator projection using grid and texture.

52

